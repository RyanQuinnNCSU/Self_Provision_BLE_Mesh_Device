/***************************************************************************//**
 * @brief Bluetooth BGAPI for target applications in NCP mode
 *******************************************************************************
 * # License
 * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
 *******************************************************************************
 *
 * The licensor of this software is Silicon Laboratories Inc. Your use of this
 * software is governed by the terms of Silicon Labs Master Software License
 * Agreement (MSLA) available at
 * www.silabs.com/about-us/legal/master-software-license-agreement. This
 * software is distributed to you in Source Code format and is governed by the
 * sections of the MSLA applicable to Source Code.
 *
 ******************************************************************************/

#ifndef NCP_GECKO_H
#define NCP_GECKO_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef HAL_CONFIG
#include "hal-config.h"
#endif

#include <string.h>
#include "bg_types.h"
#include "gecko_configuration.h"
#include "bg_errorcodes.h"
typedef uint8_t   uint8;
typedef uint16_t  uint16;
typedef uint32_t  uint32;
typedef uint64_t  uint64;
typedef int8_t    int8;
typedef int16_t   int16;
typedef int32_t   int32;
typedef int64_t   int64;

typedef struct {
  uint16_t len;
  uint8_t  data[];
}uint16array;



/* Compatibility */
#ifndef PACKSTRUCT
/*Default packed configuration*/
#ifdef __GNUC__
#ifdef _WIN32
#define PACKSTRUCT( decl ) decl __attribute__((__packed__,gcc_struct))
#else
#define PACKSTRUCT( decl ) decl __attribute__((__packed__))
#endif
#define ALIGNED __attribute__((aligned(0x4)))
#elif __IAR_SYSTEMS_ICC__

#define PACKSTRUCT( decl ) __packed decl

#define ALIGNED
#elif _MSC_VER  /*msvc*/

#define PACKSTRUCT( decl ) __pragma( pack(push, 1) ) decl __pragma( pack(pop) )
#define ALIGNED
#else 
#define PACKSTRUCT(a) a PACKED 
#endif
#endif


#define BGLIB_DEPRECATED_API __attribute__((deprecated))
#define BGLIB_MSG_ID(HDR) ((HDR)&0xffff00f8)
#define BGLIB_MSG_HEADER_LEN (4)
#define BGLIB_MSG_LEN(HDR) ((((HDR)&0x7)<<8)|(((HDR)&0xff00)>>8))


#define BGLIB_BIT_ENCRYPTED (1 << 6) // Bit indicating whether the packet is encrypted
#define BGLIB_MSG_ENCRYPTED(HDR) ((HDR) & BGLIB_BIT_ENCRYPTED)

/**
 * Tells if a BGAPI message is sensitive.
 * @param[in] message_id the BGAPI message identifier
 * @return 1 if the message is sensitive; otherwise 0
 */
uint8_t gecko_is_sensitive_message(uint32_t message_id);

/**
 * Blocks until new event arrives which requires processing by user application.
 * 
 * @return pointer to received event
 */
struct gecko_cmd_packet* gecko_wait_event(void);

/**
 * Same as gecko_wait_event but does not block if no events waiting, instead returns NULL
 *
 * @return pointer to received event or NULL if no event waiting
 */
struct gecko_cmd_packet* gecko_peek_event(void);

/**
 * Events are in queue waiting for processing
 * Call gecko_wait_event or gecko_peek_event to process pending events
 *
 * @return nonzero if processing required
 */
int gecko_event_pending(void);

/**
 * Initialize stack.
 * @param config The pointer to configuration parameters, cannot be NULL.
 * @return bg_err_success if the initialization was successful; Other error code
 *         indicates a failure on initializing persistent storage.
 */
errorcode_t gecko_stack_init(const gecko_configuration_t *config);

/**
 * Initialize multiprotocol. Please note that multiprotocol version of RAIL
 * is needed.
 * @param config, set to NULL
 */
void gecko_init_multiprotocol(const void *config);


/**
 * Poll the stack how long it can sleep until the time it will process the next message.
 * A very large returned value indicates that the stack does not have pending message to process.
 * For example, 0x07CFFFFF will be returned in this case when the clock frequency is 32768 ticks per second.
 * @return maximum sleep time in milliseconds; 0 if the stack cannot sleep
 */
uint32 gecko_can_sleep_ms(void);

/**
 * Poll the stack how long it can sleep until the time it will process the next message.
 * Note the tick is calculated with sleep timer clock frequency.
 * @return maximum sleep time in ticks; 0 if the stack cannot sleep; 0xFFFFFFFF if it has no pending message
 */
uint32 gecko_can_sleep_ticks(void);

/**
 * Priority message handler function if user application requires the use of PendSV interrupt.
 *
 * If scheduler_callback function pointer in configuration struct is something else than NULL,
 * then stack will not install its own PendSV IRQ handler but instead uses callback/handler functions.
 *
 * When application receives call to the scheduler_callback function it must schedule the call to
 * gecko_priority_handle function to later time to run on high priority thread. This callback
 * may happen inside radio IRQ so processing must not block and has to happen as fast as possible.
 *
 * Recommended implemenation:
 * High priority thread is loop that waits on binary semaphore and calls gecko_priority_handler.
 * The scheduler_callback is simple function that only signals the semaphore.
 *
 */
void gecko_priority_handle(void);

/**
 * Put the stack to sleep for a maximum of @param max milliseconds.
 * Note that the stack may wake up earlier due to an external event.
 * @param max number of milliseconds request to sleep. This cannot be greater than the value
 * sl_sleeptimer_get_max_ms32_conversion API returns.
 * @return number of milliseconds actually slept.
 */
uint32 gecko_sleep_for_ms(uint32 max);

/**
 * Signals stack that external event has happened. Signals can be used to report status change from interrupt
 * context or from other threads to application. Signals are bits that are automatically cleared after
 * application has been notified.
 * 
 * @param signals is a bitmask defining active signals that are reported back to the application by system_external_signal-event.
 *
 */
void gecko_external_signal(uint32 signals);

/**
 * Signals stack to send system_awake event when application received wakeup signal.
 */
void gecko_send_system_awake();

/**
 * Signals stack to send system_error event when in case of an error.
 */
void gecko_send_system_error(uint16 reason, uint8 data_len, const uint8* data);





enum system_linklayer_config_key
{
    system_linklayer_config_key_halt                             = 0x1,
    system_linklayer_config_key_priority_range                   = 0x2,
    system_linklayer_config_key_scan_channels                    = 0x3,
    system_linklayer_config_key_set_flags                        = 0x4,
    system_linklayer_config_key_clr_flags                        = 0x5,
    system_linklayer_config_key_set_afh_interval                 = 0x7,
    system_linklayer_config_key_set_priority_table               = 0x9
};

enum le_gap_address_type
{
    le_gap_address_type_public                                   = 0x0,
    le_gap_address_type_random                                   = 0x1
};

enum le_gap_phy_type
{
    le_gap_phy_1m                                                = 0x1,
    le_gap_phy_2m                                                = 0x2,
    le_gap_phy_coded                                             = 0x4
};

enum le_gap_connectable_mode
{
    le_gap_non_connectable                                       = 0x0,
    le_gap_directed_connectable                                  = 0x1,
    le_gap_undirected_connectable                                = 0x2,
    le_gap_connectable_scannable                                 = 0x2,
    le_gap_scannable_non_connectable                             = 0x3,
    le_gap_connectable_non_scannable                             = 0x4
};

enum le_gap_discoverable_mode
{
    le_gap_non_discoverable                                      = 0x0,
    le_gap_limited_discoverable                                  = 0x1,
    le_gap_general_discoverable                                  = 0x2,
    le_gap_broadcast                                             = 0x3,
    le_gap_user_data                                             = 0x4
};

enum le_gap_discover_mode
{
    le_gap_discover_limited                                      = 0x0,
    le_gap_discover_generic                                      = 0x1,
    le_gap_discover_observation                                  = 0x2
};

enum le_gap_adv_address_type
{
    le_gap_identity_address                                      = 0x0,
    le_gap_non_resolvable                                        = 0x1
};

enum sync_advertiser_clock_accuracy
{
    sync_clock_accuracy_500                                      = 0x1f4,
    sync_clock_accuracy_250                                      = 0xfa,
    sync_clock_accuracy_150                                      = 0x96,
    sync_clock_accuracy_100                                      = 0x64,
    sync_clock_accuracy_75                                       = 0x4b,
    sync_clock_accuracy_50                                       = 0x32,
    sync_clock_accuracy_30                                       = 0x1e,
    sync_clock_accuracy_20                                       = 0x14
};

enum le_connection_security
{
    le_connection_mode1_level1                                   = 0x0,
    le_connection_mode1_level2                                   = 0x1,
    le_connection_mode1_level3                                   = 0x2,
    le_connection_mode1_level4                                   = 0x3
};

enum gatt_att_opcode
{
    gatt_read_by_type_request                                    = 0x8,
    gatt_read_by_type_response                                   = 0x9,
    gatt_read_request                                            = 0xa,
    gatt_read_response                                           = 0xb,
    gatt_read_blob_request                                       = 0xc,
    gatt_read_blob_response                                      = 0xd,
    gatt_read_multiple_request                                   = 0xe,
    gatt_read_multiple_response                                  = 0xf,
    gatt_write_request                                           = 0x12,
    gatt_write_response                                          = 0x13,
    gatt_write_command                                           = 0x52,
    gatt_prepare_write_request                                   = 0x16,
    gatt_prepare_write_response                                  = 0x17,
    gatt_execute_write_request                                   = 0x18,
    gatt_execute_write_response                                  = 0x19,
    gatt_handle_value_notification                               = 0x1b,
    gatt_handle_value_indication                                 = 0x1d
};

enum gatt_client_config_flag
{
    gatt_disable                                                 = 0x0,
    gatt_notification                                            = 0x1,
    gatt_indication                                              = 0x2
};

enum gatt_execute_write_flag
{
    gatt_cancel                                                  = 0x0,
    gatt_commit                                                  = 0x1
};

enum gatt_server_characteristic_status_flag
{
    gatt_server_client_config                                    = 0x1,
    gatt_server_confirmation                                     = 0x2
};


enum test_packet_type
{
    test_pkt_prbs9                                               = 0x0,
    test_pkt_11110000                                            = 0x1,
    test_pkt_10101010                                            = 0x2,
    test_pkt_11111111                                            = 0x4,
    test_pkt_00000000                                            = 0x5,
    test_pkt_00001111                                            = 0x6,
    test_pkt_01010101                                            = 0x7,
    test_pkt_pn9                                                 = 0xfd,
    test_pkt_carrier                                             = 0xfe
};

enum test_phy
{
    test_phy_1m                                                  = 0x1,
    test_phy_2m                                                  = 0x2,
    test_phy_125k                                                = 0x3,
    test_phy_500k                                                = 0x4
};

enum sm_bonding_key
{
    sm_bonding_key_ltk                                           = 0x1,
    sm_bonding_key_addr_public                                   = 0x2,
    sm_bonding_key_addr_static                                   = 0x4,
    sm_bonding_key_irk                                           = 0x8,
    sm_bonding_key_edivrand                                      = 0x10,
    sm_bonding_key_csrk                                          = 0x20,
    sm_bonding_key_masterid                                      = 0x40
};

enum sm_io_capability
{
    sm_io_capability_displayonly                                 = 0x0,
    sm_io_capability_displayyesno                                = 0x1,
    sm_io_capability_keyboardonly                                = 0x2,
    sm_io_capability_noinputnooutput                             = 0x3,
    sm_io_capability_keyboarddisplay                             = 0x4
};

enum homekit_category
{
    homekit_not_allowed                                          = 0x0,
    homekit_other                                                = 0x1,
    homekit_bridge                                               = 0x2,
    homekit_fan                                                  = 0x3,
    homekit_garage                                               = 0x4,
    homekit_lightbulb                                            = 0x5,
    homekit_doorlock                                             = 0x6,
    homekit_outlet                                               = 0x7,
    homekit_switch_accessory                                     = 0x8,
    homekit_thermostat                                           = 0x9,
    homekit_sensor                                               = 0xa,
    homekit_security_system                                      = 0xb,
    homekit_door                                                 = 0xc,
    homekit_window                                               = 0xd,
    homekit_window_covering                                      = 0xe,
    homekit_programmable_switch                                  = 0xf,
    homekit_ip_camera                                            = 0x11,
    homekit_video_door_bell                                      = 0x12,
    homekit_air_purifier                                         = 0x13,
    homekit_heater                                               = 0x14,
    homekit_air_conditioner                                      = 0x15,
    homekit_humidifier                                           = 0x16,
    homekit_dehumidifier                                         = 0x17,
    homekit_sprinkler                                            = 0x1c,
    homekit_faucet                                               = 0x1d,
    homekit_shower_system                                        = 0x1e,
    homekit_remote                                               = 0x20,
    homekit_wifi_router                                          = 0x21
};

enum homekit_status_code
{
    homekit_success                                              = 0x0,
    homekit_invalid_request                                      = 0x6
};

enum mesh_node_auth_method_flag
{
    mesh_node_auth_method_flag_none                              = 0x1,
    mesh_node_auth_method_flag_static                            = 0x2,
    mesh_node_auth_method_flag_input                             = 0x4,
    mesh_node_auth_method_flag_output                            = 0x8
};

enum mesh_node_oob_input_action_flag
{
    mesh_node_oob_input_action_flag_push                         = 0x1,
    mesh_node_oob_input_action_flag_twist                        = 0x2,
    mesh_node_oob_input_action_flag_numeric                      = 0x4,
    mesh_node_oob_input_action_flag_alpha                        = 0x8
};

enum mesh_node_oob_input_action
{
    mesh_node_oob_input_action_push                              = 0x0,
    mesh_node_oob_input_action_twist                             = 0x1,
    mesh_node_oob_input_action_numeric                           = 0x2,
    mesh_node_oob_input_action_alpha                             = 0x3
};

enum mesh_node_oob_output_action_flag
{
    mesh_node_oob_output_action_flag_blink                       = 0x1,
    mesh_node_oob_output_action_flag_beep                        = 0x2,
    mesh_node_oob_output_action_flag_vibrate                     = 0x4,
    mesh_node_oob_output_action_flag_numeric                     = 0x8,
    mesh_node_oob_output_action_flag_alpha                       = 0x10
};

enum mesh_node_oob_output_action
{
    mesh_node_oob_output_action_blink                            = 0x0,
    mesh_node_oob_output_action_beep                             = 0x1,
    mesh_node_oob_output_action_vibrate                          = 0x2,
    mesh_node_oob_output_action_numeric                          = 0x3,
    mesh_node_oob_output_action_alpha                            = 0x4
};

enum mesh_node_config_state
{
    mesh_node_dcd                                                = 0x8008,
    mesh_node_beacon                                             = 0x8009,
    mesh_node_default_ttl                                        = 0x800c,
    mesh_node_friendship                                         = 0x800f,
    mesh_node_gatt_proxy                                         = 0x8012,
    mesh_node_key_refresh                                        = 0x8015,
    mesh_node_relay                                              = 0x8023,
    mesh_node_identity                                           = 0x8042,
    mesh_node_nettx                                              = 0x8024
};




enum coex_option
{
    coex_option_enable                                           = 0x100,
    coex_option_tx_abort                                         = 0x400,
    coex_option_high_priority                                    = 0x800
};

enum mesh_test_key_type
{
    mesh_test_key_type_net                                       = 0x0,
    mesh_test_key_type_app                                       = 0x1
};

enum mesh_lpn_settings
{
    mesh_lpn_queue_length                                        = 0x0,
    mesh_lpn_poll_timeout                                        = 0x1,
    mesh_lpn_receive_delay                                       = 0x2,
    mesh_lpn_request_retries                                     = 0x3,
    mesh_lpn_retry_interval                                      = 0x4
};

enum l2cap_coc_connection_result
{
    l2cap_connection_successful                                  = 0x0,
    l2cap_le_psm_not_supported                                   = 0x2,
    l2cap_no_resources_available                                 = 0x4,
    l2cap_insufficient_authentication                            = 0x5,
    l2cap_insufficient_authorization                             = 0x6,
    l2cap_insufficient_encryption_key_size                       = 0x7,
    l2cap_insufficient_encryption                                = 0x8,
    l2cap_invalid_source_cid                                     = 0x9,
    l2cap_source_cid_already_allocated                           = 0xa,
    l2cap_unacceptable_parameters                                = 0xb
};

enum l2cap_command_reject_reason
{
    l2cap_command_not_understood                                 = 0x0,
    l2cap_signaling_mtu_exceeded                                 = 0x1,
    l2cap_invalid_cid_request                                    = 0x2
};

enum l2cap_command_code
{
    l2cap_disconnection_request                                  = 0x6,
    l2cap_connection_request                                     = 0x14,
    l2cap_flow_control_credit                                    = 0x16
};

enum mesh_lc_server_lc_state
{
    mesh_lc_server_lc_state_off                                  = 0x0,
    mesh_lc_server_lc_state_standby                              = 0x1,
    mesh_lc_server_lc_state_fade_on                              = 0x2,
    mesh_lc_server_lc_state_run                                  = 0x3,
    mesh_lc_server_lc_state_fade                                 = 0x4,
    mesh_lc_server_lc_state_prolong                              = 0x5,
    mesh_lc_server_lc_state_fade_standby_auto                    = 0x6,
    mesh_lc_server_lc_state_fade_standby_manual                  = 0x7
};

enum mesh_lc_server_lc_debug_events
{
    mesh_lc_server_lc_event_state_updated                        = 0x1,
    mesh_lc_server_lc_event_regulator_debug_info                 = 0x2
};

enum mesh_time_client_time_roles
{
    mesh_time_client_time_role_none                              = 0x0,
    mesh_time_client_time_role_authority                         = 0x1,
    mesh_time_client_time_role_relay                             = 0x2,
    mesh_time_client_time_role_client                            = 0x3
};

enum gecko_parameter_types
{
    gecko_msg_parameter_uint8=2,
    gecko_msg_parameter_int8=3,
    gecko_msg_parameter_uint16=4,
    gecko_msg_parameter_int16=5,
    gecko_msg_parameter_uint32=6,
    gecko_msg_parameter_int32=7,
    gecko_msg_parameter_uint8array=8,
    gecko_msg_parameter_string=9,
    gecko_msg_parameter_hwaddr=10,
    gecko_msg_parameter_uint16array=11
};

enum gecko_msg_types
{
    gecko_msg_type_cmd=0x00,
    gecko_msg_type_rsp=0x00,
    gecko_msg_type_evt=0x80
};
enum gecko_dev_types
{
    gecko_dev_type_gecko   =0x20
};



#define FLASH_PS_KEY_LOCAL_BD_ADDR                                   0x2c
#define FLASH_PS_KEY_TX_POWER                                        0x31
#define FLASH_PS_KEY_CTUNE                                           0x32
#define FLASH_PS_KEY_APPLICATION_GSN                                 0x33
#define FLASH_PS_KEY_OTA_FLAGS                                       0x35
#define FLASH_PS_KEY_OTA_DEVICE_NAME                                 0x36
#define FLASH_PS_KEY_DEVICE_IRK                                      0x37
#define FLASH_PS_KEY_BONDING_PRIORITY_LIST                           0x38
#define FLASH_PS_KEY_OTA_ADVERTISEMENT_PACKET                        0x39
#define FLASH_PS_KEY_OTA_SCAN_RESPONSE_PACKET                        0x3a
#define FLASH_PS_KEY_APPLICATION_AI                                  0x3b
#define FLASH_PS_KEY_IDENTITY_ADDR_TYPE                              0x3c
#define FLASH_PS_KEY_GATT_DB_HASH                                    0x3d
#define FLASH_PS_KEY_OTA_RF_PATH                                     0x3e
#define FLASH_PS_KEY_BONDING_DB_CONFIG                               0x3fff
#define MESH_PROV_OOB_OTHER                                          0x1
#define MESH_PROV_OOB_URI                                            0x2
#define MESH_PROV_OOB_2D_MR_CODE                                     0x4
#define MESH_PROV_OOB_BAR_CODE                                       0x8
#define MESH_PROV_OOB_NFC                                            0x10
#define MESH_PROV_OOB_NUMBER                                         0x20
#define MESH_PROV_OOB_STRING                                         0x40
#define MESH_PROV_OOB_RFU_7                                          0x80
#define MESH_PROV_OOB_RFU_8                                          0x100
#define MESH_PROV_OOB_RFU_9                                          0x200
#define MESH_PROV_OOB_RFU_A                                          0x400
#define MESH_PROV_OOB_LOC_ON_BOX                                     0x800
#define MESH_PROV_OOB_LOC_IN_BOX                                     0x1000
#define MESH_PROV_OOB_LOC_PAPER                                      0x2000
#define MESH_PROV_OOB_LOC_MANUAL                                     0x4000
#define MESH_PROV_OOB_LOC_DEVICE                                     0x8000
#define MESH_PROV_OOB_RFU_MASK                                       0x780
#define MESH_GENERIC_CLIENT_STATE_ON_OFF                             0x0
#define MESH_GENERIC_CLIENT_STATE_ON_POWER_UP                        0x1
#define MESH_GENERIC_CLIENT_STATE_LEVEL                              0x2
#define MESH_GENERIC_CLIENT_STATE_POWER_LEVEL                        0x3
#define MESH_GENERIC_CLIENT_STATE_POWER_LEVEL_LAST                   0x4
#define MESH_GENERIC_CLIENT_STATE_POWER_LEVEL_DEFAULT                0x5
#define MESH_GENERIC_CLIENT_STATE_POWER_LEVEL_RANGE                  0x6
#define MESH_GENERIC_CLIENT_STATE_TRANSITION_TIME                    0x6
#define MESH_GENERIC_CLIENT_STATE_BATTERY                            0x8
#define MESH_GENERIC_CLIENT_STATE_LOCATION_GLOBAL                    0x9
#define MESH_GENERIC_CLIENT_STATE_LOCATION_LOCAL                     0xa
#define MESH_GENERIC_CLIENT_STATE_PROPERTY_USER                      0xb
#define MESH_GENERIC_CLIENT_STATE_PROPERTY_ADMIN                     0xc
#define MESH_GENERIC_CLIENT_STATE_PROPERTY_MANUF                     0xd
#define MESH_GENERIC_CLIENT_STATE_PROPERTY_LIST_USER                 0xe
#define MESH_GENERIC_CLIENT_STATE_PROPERTY_LIST_ADMIN                0xf
#define MESH_GENERIC_CLIENT_STATE_PROPERTY_LIST_MANUF                0x10
#define MESH_GENERIC_CLIENT_STATE_PROPERTY_LIST_CLIENT               0x11
#define MESH_GENERIC_CLIENT_STATE_LIGHTNESS_ACTUAL                   0x80
#define MESH_GENERIC_CLIENT_STATE_LIGHTNESS_LINEAR                   0x81
#define MESH_GENERIC_CLIENT_STATE_LIGHTNESS_LAST                     0x82
#define MESH_GENERIC_CLIENT_STATE_LIGHTNESS_DEFAULT                  0x83
#define MESH_GENERIC_CLIENT_STATE_LIGHTNESS_RANGE                    0x84
#define MESH_GENERIC_CLIENT_STATE_CTL                                0x85
#define MESH_GENERIC_CLIENT_STATE_CTL_TEMPERATURE                    0x86
#define MESH_GENERIC_CLIENT_STATE_CTL_DEFAULT                        0x87
#define MESH_GENERIC_CLIENT_STATE_CTL_RANGE                          0x88
#define MESH_GENERIC_CLIENT_STATE_CTL_LIGHTNESS_TEMPERATURE          0x89
#define MESH_GENERIC_CLIENT_REQUEST_ON_OFF                           0x0
#define MESH_GENERIC_CLIENT_REQUEST_ON_POWER_UP                      0x1
#define MESH_GENERIC_CLIENT_REQUEST_LEVEL                            0x2
#define MESH_GENERIC_CLIENT_REQUEST_LEVEL_DELTA                      0x3
#define MESH_GENERIC_CLIENT_REQUEST_LEVEL_MOVE                       0x4
#define MESH_GENERIC_CLIENT_REQUEST_LEVEL_HALT                       0x5
#define MESH_GENERIC_CLIENT_REQUEST_POWER_LEVEL                      0x6
#define MESH_GENERIC_CLIENT_REQUEST_POWER_LEVEL_DEFAULT              0x7
#define MESH_GENERIC_CLIENT_REQUEST_POWER_LEVEL_RANGE                0x8
#define MESH_GENERIC_CLIENT_REQUEST_TRANSITION_TIME                  0x9
#define MESH_GENERIC_CLIENT_REQUEST_LOCATION_GLOBAL                  0xa
#define MESH_GENERIC_CLIENT_REQUEST_LOCATION_LOCAL                   0xb
#define MESH_GENERIC_CLIENT_REQUEST_PROPERTY_USER                    0xc
#define MESH_GENERIC_CLIENT_REQUEST_PROPERTY_ADMIN                   0xd
#define MESH_GENERIC_CLIENT_REQUEST_PROPERTY_MANUF                   0xe
#define MESH_GENERIC_CLIENT_REQUEST_LIGHTNESS_ACTUAL                 0x80
#define MESH_GENERIC_CLIENT_REQUEST_LIGHTNESS_LINEAR                 0x81
#define MESH_GENERIC_CLIENT_REQUEST_LIGHTNESS_DEFAULT                0x82
#define MESH_GENERIC_CLIENT_REQUEST_LIGHTNESS_RANGE                  0x83
#define MESH_GENERIC_CLIENT_REQUEST_CTL                              0x84
#define MESH_GENERIC_CLIENT_REQUEST_CTL_TEMPERATURE                  0x85
#define MESH_GENERIC_CLIENT_REQUEST_CTL_DEFAULT                      0x86
#define MESH_GENERIC_CLIENT_REQUEST_CTL_RANGE                        0x87


#define gecko_cmd_dfu_reset_id                                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00000000)
#define gecko_cmd_dfu_flash_set_address_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01000000)
#define gecko_cmd_dfu_flash_upload_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02000000)
#define gecko_cmd_dfu_flash_upload_finish_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03000000)
#define gecko_cmd_system_hello_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00010000)
#define gecko_cmd_system_reset_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01010000)
#define gecko_cmd_system_get_bt_address_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03010000)
#define gecko_cmd_system_set_bt_address_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04010000)
#define gecko_cmd_system_set_tx_power_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0a010000)
#define gecko_cmd_system_get_random_data_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0b010000)
#define gecko_cmd_system_halt_id                                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0c010000)
#define gecko_cmd_system_set_device_name_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0d010000)
#define gecko_cmd_system_linklayer_configure_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0e010000)
#define gecko_cmd_system_get_counters_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0f010000)
#define gecko_cmd_system_data_buffer_write_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x12010000)
#define gecko_cmd_system_set_identity_address_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x13010000)
#define gecko_cmd_system_data_buffer_clear_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x14010000)
#define gecko_cmd_le_gap_open_id                                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00030000)
#define gecko_cmd_le_gap_set_mode_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01030000)
#define gecko_cmd_le_gap_discover_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02030000)
#define gecko_cmd_le_gap_end_procedure_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03030000)
#define gecko_cmd_le_gap_set_adv_parameters_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04030000)
#define gecko_cmd_le_gap_set_conn_parameters_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x05030000)
#define gecko_cmd_le_gap_set_scan_parameters_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x06030000)
#define gecko_cmd_le_gap_set_adv_data_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x07030000)
#define gecko_cmd_le_gap_set_adv_timeout_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x08030000)
#define gecko_cmd_le_gap_set_conn_phy_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x09030000)
#define gecko_cmd_le_gap_bt5_set_mode_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0a030000)
#define gecko_cmd_le_gap_bt5_set_adv_parameters_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0b030000)
#define gecko_cmd_le_gap_bt5_set_adv_data_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0c030000)
#define gecko_cmd_le_gap_set_privacy_mode_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0d030000)
#define gecko_cmd_le_gap_set_advertise_timing_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0e030000)
#define gecko_cmd_le_gap_set_advertise_channel_map_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0f030000)
#define gecko_cmd_le_gap_set_advertise_report_scan_request_id         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x10030000)
#define gecko_cmd_le_gap_set_advertise_phy_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x11030000)
#define gecko_cmd_le_gap_set_advertise_configuration_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x12030000)
#define gecko_cmd_le_gap_clear_advertise_configuration_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x13030000)
#define gecko_cmd_le_gap_start_advertising_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x14030000)
#define gecko_cmd_le_gap_stop_advertising_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x15030000)
#define gecko_cmd_le_gap_set_discovery_timing_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x16030000)
#define gecko_cmd_le_gap_set_discovery_type_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x17030000)
#define gecko_cmd_le_gap_start_discovery_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x18030000)
#define gecko_cmd_le_gap_set_data_channel_classification_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x19030000)
#define gecko_cmd_le_gap_connect_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x1a030000)
#define gecko_cmd_le_gap_set_advertise_tx_power_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x1b030000)
#define gecko_cmd_le_gap_set_discovery_extended_scan_response_id      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x1c030000)
#define gecko_cmd_le_gap_start_periodic_advertising_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x1d030000)
#define gecko_cmd_le_gap_stop_periodic_advertising_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x1f030000)
#define gecko_cmd_le_gap_set_long_advertising_data_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x20030000)
#define gecko_cmd_le_gap_enable_whitelisting_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x21030000)
#define gecko_cmd_le_gap_set_conn_timing_parameters_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x22030000)
#define gecko_cmd_le_gap_set_advertise_random_address_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x25030000)
#define gecko_cmd_le_gap_clear_advertise_random_address_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x26030000)
#define gecko_cmd_sync_open_id                                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00420000)
#define gecko_cmd_sync_close_id                                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01420000)
#define gecko_cmd_le_connection_set_parameters_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00080000)
#define gecko_cmd_le_connection_get_rssi_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01080000)
#define gecko_cmd_le_connection_disable_slave_latency_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02080000)
#define gecko_cmd_le_connection_set_phy_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03080000)
#define gecko_cmd_le_connection_close_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04080000)
#define gecko_cmd_le_connection_set_timing_parameters_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x05080000)
#define gecko_cmd_le_connection_read_channel_map_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x06080000)
#define gecko_cmd_le_connection_set_preferred_phy_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x07080000)
#define gecko_cmd_gatt_set_max_mtu_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00090000)
#define gecko_cmd_gatt_discover_primary_services_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01090000)
#define gecko_cmd_gatt_discover_primary_services_by_uuid_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02090000)
#define gecko_cmd_gatt_discover_characteristics_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03090000)
#define gecko_cmd_gatt_discover_characteristics_by_uuid_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04090000)
#define gecko_cmd_gatt_set_characteristic_notification_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x05090000)
#define gecko_cmd_gatt_discover_descriptors_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x06090000)
#define gecko_cmd_gatt_read_characteristic_value_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x07090000)
#define gecko_cmd_gatt_read_characteristic_value_by_uuid_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x08090000)
#define gecko_cmd_gatt_write_characteristic_value_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x09090000)
#define gecko_cmd_gatt_write_characteristic_value_without_response_id  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0a090000)
#define gecko_cmd_gatt_prepare_characteristic_value_write_id          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0b090000)
#define gecko_cmd_gatt_execute_characteristic_value_write_id          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0c090000)
#define gecko_cmd_gatt_send_characteristic_confirmation_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0d090000)
#define gecko_cmd_gatt_read_descriptor_value_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0e090000)
#define gecko_cmd_gatt_write_descriptor_value_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0f090000)
#define gecko_cmd_gatt_find_included_services_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x10090000)
#define gecko_cmd_gatt_read_multiple_characteristic_values_id         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x11090000)
#define gecko_cmd_gatt_read_characteristic_value_from_offset_id       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x12090000)
#define gecko_cmd_gatt_prepare_characteristic_value_reliable_write_id  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x13090000)
#define gecko_cmd_gatt_server_read_attribute_value_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x000a0000)
#define gecko_cmd_gatt_server_read_attribute_type_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x010a0000)
#define gecko_cmd_gatt_server_write_attribute_value_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x020a0000)
#define gecko_cmd_gatt_server_send_user_read_response_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x030a0000)
#define gecko_cmd_gatt_server_send_user_write_response_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x040a0000)
#define gecko_cmd_gatt_server_send_characteristic_notification_id     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x050a0000)
#define gecko_cmd_gatt_server_find_attribute_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x060a0000)
#define gecko_cmd_gatt_server_set_capabilities_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x080a0000)
#define gecko_cmd_gatt_server_set_max_mtu_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0a0a0000)
#define gecko_cmd_gatt_server_get_mtu_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0b0a0000)
#define gecko_cmd_gatt_server_enable_capabilities_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0c0a0000)
#define gecko_cmd_gatt_server_disable_capabilities_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0d0a0000)
#define gecko_cmd_gatt_server_get_enabled_capabilities_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0e0a0000)
#define gecko_cmd_hardware_set_soft_timer_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x000c0000)
#define gecko_cmd_hardware_get_time_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0b0c0000)
#define gecko_cmd_hardware_set_lazy_soft_timer_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0c0c0000)
#define gecko_cmd_flash_ps_erase_all_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x010d0000)
#define gecko_cmd_flash_ps_save_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x020d0000)
#define gecko_cmd_flash_ps_load_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x030d0000)
#define gecko_cmd_flash_ps_erase_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x040d0000)
#define gecko_cmd_test_dtm_tx_id                                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x000e0000)
#define gecko_cmd_test_dtm_rx_id                                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x010e0000)
#define gecko_cmd_test_dtm_end_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x020e0000)
#define gecko_cmd_sm_set_bondable_mode_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x000f0000)
#define gecko_cmd_sm_configure_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x010f0000)
#define gecko_cmd_sm_store_bonding_configuration_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x020f0000)
#define gecko_cmd_sm_increase_security_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x040f0000)
#define gecko_cmd_sm_delete_bonding_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x060f0000)
#define gecko_cmd_sm_delete_bondings_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x070f0000)
#define gecko_cmd_sm_enter_passkey_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x080f0000)
#define gecko_cmd_sm_passkey_confirm_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x090f0000)
#define gecko_cmd_sm_set_oob_data_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0a0f0000)
#define gecko_cmd_sm_list_all_bondings_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0b0f0000)
#define gecko_cmd_sm_bonding_confirm_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0e0f0000)
#define gecko_cmd_sm_set_debug_mode_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0f0f0000)
#define gecko_cmd_sm_set_passkey_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x100f0000)
#define gecko_cmd_sm_use_sc_oob_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x110f0000)
#define gecko_cmd_sm_set_sc_remote_oob_data_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x120f0000)
#define gecko_cmd_sm_add_to_whitelist_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x130f0000)
#define gecko_cmd_sm_set_minimum_key_size_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x140f0000)
#define gecko_cmd_homekit_configure_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00130000)
#define gecko_cmd_homekit_advertise_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01130000)
#define gecko_cmd_homekit_delete_pairings_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02130000)
#define gecko_cmd_homekit_check_authcp_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03130000)
#define gecko_cmd_homekit_get_pairing_id_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04130000)
#define gecko_cmd_homekit_send_write_response_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x05130000)
#define gecko_cmd_homekit_send_read_response_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x06130000)
#define gecko_cmd_homekit_gsn_action_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x07130000)
#define gecko_cmd_homekit_event_notification_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x08130000)
#define gecko_cmd_homekit_broadcast_action_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x09130000)
#define gecko_cmd_homekit_configure_product_data_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0a130000)
#define gecko_cmd_mesh_node_init_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00140000)
#define gecko_cmd_mesh_node_start_unprov_beaconing_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01140000)
#define gecko_cmd_mesh_node_stop_unprov_beaconing_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x16140000)
#define gecko_cmd_mesh_node_rssi_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x17140000)
#define gecko_cmd_mesh_node_input_oob_request_rsp_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02140000)
#define gecko_cmd_mesh_node_get_uuid_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03140000)
#define gecko_cmd_mesh_node_set_provisioning_data_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04140000)
#define gecko_cmd_mesh_node_init_oob_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x05140000)
#define gecko_cmd_mesh_node_set_ivrecovery_mode_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x06140000)
#define gecko_cmd_mesh_node_get_ivrecovery_mode_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x07140000)
#define gecko_cmd_mesh_node_set_adv_event_filter_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x08140000)
#define gecko_cmd_mesh_node_get_statistics_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x09140000)
#define gecko_cmd_mesh_node_clear_statistics_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0a140000)
#define gecko_cmd_mesh_node_set_net_relay_delay_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0b140000)
#define gecko_cmd_mesh_node_get_net_relay_delay_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0c140000)
#define gecko_cmd_mesh_node_get_ivupdate_state_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0d140000)
#define gecko_cmd_mesh_node_request_ivupdate_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0e140000)
#define gecko_cmd_mesh_node_get_seq_remaining_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0f140000)
#define gecko_cmd_mesh_node_save_replay_protection_list_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x10140000)
#define gecko_cmd_mesh_node_set_uuid_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x11140000)
#define gecko_cmd_mesh_node_get_element_address_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x12140000)
#define gecko_cmd_mesh_node_static_oob_request_rsp_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x13140000)
#define gecko_cmd_mesh_node_reset_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x15140000)
#define gecko_cmd_mesh_node_set_beacon_reporting_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x18140000)
#define gecko_cmd_mesh_node_set_iv_update_age_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x19140000)
#define gecko_cmd_mesh_prov_init_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00150000)
#define gecko_cmd_mesh_prov_scan_unprov_beacons_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01150000)
#define gecko_cmd_mesh_prov_provision_device_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02150000)
#define gecko_cmd_mesh_prov_create_network_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03150000)
#define gecko_cmd_mesh_prov_get_dcd_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04150000)
#define gecko_cmd_mesh_prov_get_config_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x05150000)
#define gecko_cmd_mesh_prov_set_config_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x06150000)
#define gecko_cmd_mesh_prov_create_appkey_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x07150000)
#define gecko_cmd_mesh_prov_oob_pkey_rsp_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x08150000)
#define gecko_cmd_mesh_prov_oob_auth_rsp_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x09150000)
#define gecko_cmd_mesh_prov_set_oob_requirements_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0a150000)
#define gecko_cmd_mesh_prov_key_refresh_start_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0b150000)
#define gecko_cmd_mesh_prov_get_key_refresh_blacklist_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0c150000)
#define gecko_cmd_mesh_prov_set_key_refresh_blacklist_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0d150000)
#define gecko_cmd_mesh_prov_appkey_add_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0e150000)
#define gecko_cmd_mesh_prov_appkey_delete_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0f150000)
#define gecko_cmd_mesh_prov_model_app_bind_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x10150000)
#define gecko_cmd_mesh_prov_model_app_unbind_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x11150000)
#define gecko_cmd_mesh_prov_model_app_get_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x12150000)
#define gecko_cmd_mesh_prov_model_sub_add_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x13150000)
#define gecko_cmd_mesh_prov_model_pub_set_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x14150000)
#define gecko_cmd_mesh_prov_provision_gatt_device_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x15150000)
#define gecko_cmd_mesh_prov_ddb_get_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x16150000)
#define gecko_cmd_mesh_prov_ddb_delete_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x17150000)
#define gecko_cmd_mesh_prov_ddb_add_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x18150000)
#define gecko_cmd_mesh_prov_ddb_list_devices_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x19150000)
#define gecko_cmd_mesh_prov_network_add_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x1a150000)
#define gecko_cmd_mesh_prov_network_delete_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x1b150000)
#define gecko_cmd_mesh_prov_nettx_get_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x1c150000)
#define gecko_cmd_mesh_prov_nettx_set_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x1d150000)
#define gecko_cmd_mesh_prov_model_sub_del_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x1e150000)
#define gecko_cmd_mesh_prov_model_sub_add_va_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x1f150000)
#define gecko_cmd_mesh_prov_model_sub_del_va_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x20150000)
#define gecko_cmd_mesh_prov_model_sub_set_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x21150000)
#define gecko_cmd_mesh_prov_model_sub_set_va_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x22150000)
#define gecko_cmd_mesh_prov_heartbeat_publication_get_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x23150000)
#define gecko_cmd_mesh_prov_heartbeat_publication_set_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x24150000)
#define gecko_cmd_mesh_prov_heartbeat_subscription_get_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x25150000)
#define gecko_cmd_mesh_prov_heartbeat_subscription_set_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x26150000)
#define gecko_cmd_mesh_prov_relay_get_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x27150000)
#define gecko_cmd_mesh_prov_relay_set_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x28150000)
#define gecko_cmd_mesh_prov_reset_node_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x29150000)
#define gecko_cmd_mesh_prov_appkey_get_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x2a150000)
#define gecko_cmd_mesh_prov_network_get_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x2b150000)
#define gecko_cmd_mesh_prov_model_sub_clear_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x2c150000)
#define gecko_cmd_mesh_prov_model_pub_get_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x2d150000)
#define gecko_cmd_mesh_prov_model_pub_set_va_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x2e150000)
#define gecko_cmd_mesh_prov_model_pub_set_cred_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x2f150000)
#define gecko_cmd_mesh_prov_model_pub_set_va_cred_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x30150000)
#define gecko_cmd_mesh_prov_model_sub_get_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x31150000)
#define gecko_cmd_mesh_prov_friend_timeout_get_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x32150000)
#define gecko_cmd_mesh_prov_get_default_configuration_timeout_id      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x33150000)
#define gecko_cmd_mesh_prov_set_default_configuration_timeout_id      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x34150000)
#define gecko_cmd_mesh_prov_provision_device_with_address_id          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x35150000)
#define gecko_cmd_mesh_prov_provision_gatt_device_with_address_id     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x36150000)
#define gecko_cmd_mesh_prov_initialize_network_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x37150000)
#define gecko_cmd_mesh_prov_get_key_refresh_appkey_blacklist_id       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x38150000)
#define gecko_cmd_mesh_prov_set_key_refresh_appkey_blacklist_id       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x39150000)
#define gecko_cmd_mesh_prov_stop_scan_unprov_beacons_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x3a150000)
#define gecko_cmd_mesh_prov_ddb_update_netkey_index_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x3b150000)
#define gecko_cmd_mesh_prov_key_refresh_suspend_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x3c150000)
#define gecko_cmd_mesh_prov_key_refresh_resume_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x3d150000)
#define gecko_cmd_mesh_prov_get_key_refresh_phase_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x3e150000)
#define gecko_cmd_mesh_prov_key_refresh_start_from_phase_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x3f150000)
#define gecko_cmd_mesh_prov_flush_key_refresh_state_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x40150000)
#define gecko_cmd_mesh_proxy_connect_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00180000)
#define gecko_cmd_mesh_proxy_disconnect_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01180000)
#define gecko_cmd_mesh_proxy_set_filter_type_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02180000)
#define gecko_cmd_mesh_proxy_allow_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03180000)
#define gecko_cmd_mesh_proxy_deny_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04180000)
#define gecko_cmd_mesh_vendor_model_send_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00190000)
#define gecko_cmd_mesh_vendor_model_set_publication_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01190000)
#define gecko_cmd_mesh_vendor_model_clear_publication_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02190000)
#define gecko_cmd_mesh_vendor_model_publish_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03190000)
#define gecko_cmd_mesh_vendor_model_init_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04190000)
#define gecko_cmd_mesh_vendor_model_deinit_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x05190000)
#define gecko_cmd_mesh_health_client_get_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x001a0000)
#define gecko_cmd_mesh_health_client_clear_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x011a0000)
#define gecko_cmd_mesh_health_client_test_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x021a0000)
#define gecko_cmd_mesh_health_client_get_period_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x031a0000)
#define gecko_cmd_mesh_health_client_set_period_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x041a0000)
#define gecko_cmd_mesh_health_client_get_attention_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x051a0000)
#define gecko_cmd_mesh_health_client_set_attention_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x061a0000)
#define gecko_cmd_mesh_health_server_set_fault_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x001b0000)
#define gecko_cmd_mesh_health_server_clear_fault_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x011b0000)
#define gecko_cmd_mesh_health_server_test_response_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x021b0000)
#define gecko_cmd_mesh_generic_client_get_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x001e0000)
#define gecko_cmd_mesh_generic_client_set_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x011e0000)
#define gecko_cmd_mesh_generic_client_publish_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x021e0000)
#define gecko_cmd_mesh_generic_client_get_params_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x031e0000)
#define gecko_cmd_mesh_generic_client_init_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x041e0000)
#define gecko_cmd_mesh_generic_client_init_common_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x051e0000)
#define gecko_cmd_mesh_generic_client_init_on_off_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x061e0000)
#define gecko_cmd_mesh_generic_client_init_level_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x071e0000)
#define gecko_cmd_mesh_generic_client_init_default_transition_time_id  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x081e0000)
#define gecko_cmd_mesh_generic_client_init_power_on_off_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x091e0000)
#define gecko_cmd_mesh_generic_client_init_power_level_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0a1e0000)
#define gecko_cmd_mesh_generic_client_init_battery_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0b1e0000)
#define gecko_cmd_mesh_generic_client_init_location_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0c1e0000)
#define gecko_cmd_mesh_generic_client_init_property_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0d1e0000)
#define gecko_cmd_mesh_generic_client_init_lightness_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0e1e0000)
#define gecko_cmd_mesh_generic_client_init_ctl_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0f1e0000)
#define gecko_cmd_mesh_generic_server_response_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x001f0000)
#define gecko_cmd_mesh_generic_server_update_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x011f0000)
#define gecko_cmd_mesh_generic_server_publish_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x021f0000)
#define gecko_cmd_mesh_generic_server_init_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x041f0000)
#define gecko_cmd_mesh_generic_server_init_common_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x051f0000)
#define gecko_cmd_mesh_generic_server_init_on_off_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x061f0000)
#define gecko_cmd_mesh_generic_server_init_level_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x071f0000)
#define gecko_cmd_mesh_generic_server_init_default_transition_time_id  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x081f0000)
#define gecko_cmd_mesh_generic_server_init_power_on_off_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x091f0000)
#define gecko_cmd_mesh_generic_server_init_power_level_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0a1f0000)
#define gecko_cmd_mesh_generic_server_init_battery_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0b1f0000)
#define gecko_cmd_mesh_generic_server_init_location_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0c1f0000)
#define gecko_cmd_mesh_generic_server_init_property_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0d1f0000)
#define gecko_cmd_mesh_generic_server_init_lightness_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0e1f0000)
#define gecko_cmd_mesh_generic_server_init_ctl_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0f1f0000)
#define gecko_cmd_coex_set_options_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00200000)
#define gecko_cmd_coex_get_counters_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01200000)
#define gecko_cmd_coex_set_parameters_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02200000)
#define gecko_cmd_coex_set_directional_priority_pulse_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03200000)
#define gecko_cmd_mesh_test_get_nettx_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00220000)
#define gecko_cmd_mesh_test_set_nettx_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01220000)
#define gecko_cmd_mesh_test_get_relay_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02220000)
#define gecko_cmd_mesh_test_set_relay_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03220000)
#define gecko_cmd_mesh_test_set_adv_scan_params_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04220000)
#define gecko_cmd_mesh_test_set_ivupdate_test_mode_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x05220000)
#define gecko_cmd_mesh_test_get_ivupdate_test_mode_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x06220000)
#define gecko_cmd_mesh_test_set_segment_send_delay_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x07220000)
#define gecko_cmd_mesh_test_set_ivupdate_state_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x08220000)
#define gecko_cmd_mesh_test_send_beacons_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x09220000)
#define gecko_cmd_mesh_test_bind_local_model_app_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0a220000)
#define gecko_cmd_mesh_test_unbind_local_model_app_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0b220000)
#define gecko_cmd_mesh_test_add_local_model_sub_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0c220000)
#define gecko_cmd_mesh_test_del_local_model_sub_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0d220000)
#define gecko_cmd_mesh_test_add_local_model_sub_va_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0e220000)
#define gecko_cmd_mesh_test_del_local_model_sub_va_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0f220000)
#define gecko_cmd_mesh_test_get_local_model_sub_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x10220000)
#define gecko_cmd_mesh_test_set_local_model_pub_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x11220000)
#define gecko_cmd_mesh_test_set_local_model_pub_va_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x12220000)
#define gecko_cmd_mesh_test_get_local_model_pub_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x13220000)
#define gecko_cmd_mesh_test_set_local_heartbeat_subscription_id       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x14220000)
#define gecko_cmd_mesh_test_get_local_heartbeat_subscription_id       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x15220000)
#define gecko_cmd_mesh_test_get_local_heartbeat_publication_id        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x16220000)
#define gecko_cmd_mesh_test_set_local_heartbeat_publication_id        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x17220000)
#define gecko_cmd_mesh_test_set_local_config_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x18220000)
#define gecko_cmd_mesh_test_get_local_config_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x19220000)
#define gecko_cmd_mesh_test_add_local_key_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x1a220000)
#define gecko_cmd_mesh_test_del_local_key_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x1b220000)
#define gecko_cmd_mesh_test_update_local_key_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x1c220000)
#define gecko_cmd_mesh_test_set_sar_config_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x1d220000)
#define gecko_cmd_mesh_test_get_element_seqnum_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x1e220000)
#define gecko_cmd_mesh_test_set_adv_bearer_state_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x1f220000)
#define gecko_cmd_mesh_test_get_key_count_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x20220000)
#define gecko_cmd_mesh_test_get_key_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x21220000)
#define gecko_cmd_mesh_test_prov_get_device_key_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x23220000)
#define gecko_cmd_mesh_test_prov_prepare_key_refresh_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x24220000)
#define gecko_cmd_mesh_test_cancel_segmented_tx_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x25220000)
#define gecko_cmd_mesh_test_set_iv_index_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x26220000)
#define gecko_cmd_mesh_test_set_element_seqnum_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x27220000)
#define gecko_cmd_mesh_test_set_model_option_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x28220000)
#define gecko_cmd_mesh_test_get_local_model_app_bindings_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x29220000)
#define gecko_cmd_mesh_lpn_init_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00230000)
#define gecko_cmd_mesh_lpn_deinit_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01230000)
#define gecko_cmd_mesh_lpn_configure_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02230000)
#define gecko_cmd_mesh_lpn_establish_friendship_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03230000)
#define gecko_cmd_mesh_lpn_poll_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04230000)
#define gecko_cmd_mesh_lpn_terminate_friendship_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x05230000)
#define gecko_cmd_mesh_lpn_config_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x06230000)
#define gecko_cmd_mesh_friend_init_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00240000)
#define gecko_cmd_mesh_friend_deinit_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01240000)
#define gecko_cmd_mesh_config_client_cancel_request_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00270000)
#define gecko_cmd_mesh_config_client_get_request_status_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01270000)
#define gecko_cmd_mesh_config_client_get_default_timeout_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x2e270000)
#define gecko_cmd_mesh_config_client_set_default_timeout_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x2f270000)
#define gecko_cmd_mesh_config_client_add_netkey_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02270000)
#define gecko_cmd_mesh_config_client_remove_netkey_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03270000)
#define gecko_cmd_mesh_config_client_list_netkeys_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04270000)
#define gecko_cmd_mesh_config_client_add_appkey_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x05270000)
#define gecko_cmd_mesh_config_client_remove_appkey_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x06270000)
#define gecko_cmd_mesh_config_client_list_appkeys_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x07270000)
#define gecko_cmd_mesh_config_client_bind_model_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x08270000)
#define gecko_cmd_mesh_config_client_unbind_model_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x09270000)
#define gecko_cmd_mesh_config_client_list_bindings_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0a270000)
#define gecko_cmd_mesh_config_client_get_model_pub_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0b270000)
#define gecko_cmd_mesh_config_client_set_model_pub_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0c270000)
#define gecko_cmd_mesh_config_client_set_model_pub_va_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0d270000)
#define gecko_cmd_mesh_config_client_add_model_sub_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0e270000)
#define gecko_cmd_mesh_config_client_add_model_sub_va_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0f270000)
#define gecko_cmd_mesh_config_client_remove_model_sub_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x10270000)
#define gecko_cmd_mesh_config_client_remove_model_sub_va_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x11270000)
#define gecko_cmd_mesh_config_client_set_model_sub_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x12270000)
#define gecko_cmd_mesh_config_client_set_model_sub_va_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x13270000)
#define gecko_cmd_mesh_config_client_clear_model_sub_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x14270000)
#define gecko_cmd_mesh_config_client_list_subs_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x15270000)
#define gecko_cmd_mesh_config_client_get_heartbeat_pub_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x16270000)
#define gecko_cmd_mesh_config_client_set_heartbeat_pub_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x17270000)
#define gecko_cmd_mesh_config_client_get_heartbeat_sub_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x19270000)
#define gecko_cmd_mesh_config_client_set_heartbeat_sub_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x1a270000)
#define gecko_cmd_mesh_config_client_get_beacon_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x1b270000)
#define gecko_cmd_mesh_config_client_set_beacon_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x1c270000)
#define gecko_cmd_mesh_config_client_get_default_ttl_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x1d270000)
#define gecko_cmd_mesh_config_client_set_default_ttl_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x1e270000)
#define gecko_cmd_mesh_config_client_get_gatt_proxy_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x1f270000)
#define gecko_cmd_mesh_config_client_set_gatt_proxy_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x20270000)
#define gecko_cmd_mesh_config_client_get_relay_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x21270000)
#define gecko_cmd_mesh_config_client_set_relay_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x22270000)
#define gecko_cmd_mesh_config_client_get_network_transmit_id          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x23270000)
#define gecko_cmd_mesh_config_client_set_network_transmit_id          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x24270000)
#define gecko_cmd_mesh_config_client_get_identity_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x25270000)
#define gecko_cmd_mesh_config_client_set_identity_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x26270000)
#define gecko_cmd_mesh_config_client_get_friend_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x27270000)
#define gecko_cmd_mesh_config_client_set_friend_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x28270000)
#define gecko_cmd_mesh_config_client_get_lpn_polltimeout_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x2b270000)
#define gecko_cmd_mesh_config_client_get_dcd_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x2c270000)
#define gecko_cmd_mesh_config_client_reset_node_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x2d270000)
#define gecko_cmd_l2cap_coc_send_connection_request_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01430000)
#define gecko_cmd_l2cap_coc_send_connection_response_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02430000)
#define gecko_cmd_l2cap_coc_send_le_flow_control_credit_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03430000)
#define gecko_cmd_l2cap_coc_send_disconnection_request_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04430000)
#define gecko_cmd_l2cap_coc_send_data_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x05430000)
#define gecko_cmd_cte_transmitter_enable_connection_cte_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00440000)
#define gecko_cmd_cte_transmitter_disable_connection_cte_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01440000)
#define gecko_cmd_cte_transmitter_enable_connectionless_cte_id        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02440000)
#define gecko_cmd_cte_transmitter_disable_connectionless_cte_id       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03440000)
#define gecko_cmd_cte_transmitter_set_dtm_parameters_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04440000)
#define gecko_cmd_cte_transmitter_clear_dtm_parameters_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x05440000)
#define gecko_cmd_cte_transmitter_enable_silabs_cte_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x06440000)
#define gecko_cmd_cte_transmitter_disable_silabs_cte_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x07440000)
#define gecko_cmd_cte_receiver_configure_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00450000)
#define gecko_cmd_cte_receiver_enable_connection_cte_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01450000)
#define gecko_cmd_cte_receiver_disable_connection_cte_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02450000)
#define gecko_cmd_cte_receiver_enable_connectionless_cte_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03450000)
#define gecko_cmd_cte_receiver_disable_connectionless_cte_id          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04450000)
#define gecko_cmd_cte_receiver_set_dtm_parameters_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x05450000)
#define gecko_cmd_cte_receiver_clear_dtm_parameters_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x06450000)
#define gecko_cmd_cte_receiver_enable_silabs_cte_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x07450000)
#define gecko_cmd_cte_receiver_disable_silabs_cte_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x08450000)
#define gecko_cmd_mesh_sensor_server_init_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00470000)
#define gecko_cmd_mesh_sensor_server_deinit_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01470000)
#define gecko_cmd_mesh_sensor_server_send_descriptor_status_id        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02470000)
#define gecko_cmd_mesh_sensor_server_send_status_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03470000)
#define gecko_cmd_mesh_sensor_server_send_column_status_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04470000)
#define gecko_cmd_mesh_sensor_server_send_series_status_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x05470000)
#define gecko_cmd_mesh_sensor_setup_server_send_cadence_status_id     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00480000)
#define gecko_cmd_mesh_sensor_setup_server_send_settings_status_id    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01480000)
#define gecko_cmd_mesh_sensor_setup_server_send_setting_status_id     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02480000)
#define gecko_cmd_mesh_sensor_client_init_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00490000)
#define gecko_cmd_mesh_sensor_client_deinit_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01490000)
#define gecko_cmd_mesh_sensor_client_get_descriptor_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02490000)
#define gecko_cmd_mesh_sensor_client_get_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03490000)
#define gecko_cmd_mesh_sensor_client_get_column_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04490000)
#define gecko_cmd_mesh_sensor_client_get_series_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x05490000)
#define gecko_cmd_mesh_sensor_client_get_cadence_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x06490000)
#define gecko_cmd_mesh_sensor_client_set_cadence_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x07490000)
#define gecko_cmd_mesh_sensor_client_get_settings_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x08490000)
#define gecko_cmd_mesh_sensor_client_get_setting_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x09490000)
#define gecko_cmd_mesh_sensor_client_set_setting_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0a490000)
#define gecko_cmd_mesh_lc_client_init_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x004c0000)
#define gecko_cmd_mesh_lc_client_get_mode_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x014c0000)
#define gecko_cmd_mesh_lc_client_set_mode_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x024c0000)
#define gecko_cmd_mesh_lc_client_get_om_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x044c0000)
#define gecko_cmd_mesh_lc_client_set_om_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x054c0000)
#define gecko_cmd_mesh_lc_client_get_light_onoff_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x074c0000)
#define gecko_cmd_mesh_lc_client_set_light_onoff_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x084c0000)
#define gecko_cmd_mesh_lc_client_get_property_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x094c0000)
#define gecko_cmd_mesh_lc_client_set_property_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0a4c0000)
#define gecko_cmd_mesh_lc_server_init_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x004d0000)
#define gecko_cmd_mesh_lc_server_deinit_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x014d0000)
#define gecko_cmd_mesh_lc_server_update_mode_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x024d0000)
#define gecko_cmd_mesh_lc_server_update_om_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x034d0000)
#define gecko_cmd_mesh_lc_server_update_light_onoff_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x044d0000)
#define gecko_cmd_mesh_lc_server_init_all_properties_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x054d0000)
#define gecko_cmd_mesh_lc_server_set_publish_mask_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x064d0000)
#define gecko_cmd_mesh_lc_server_set_regulator_interval_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x074d0000)
#define gecko_cmd_mesh_lc_server_set_event_mask_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x084d0000)
#define gecko_cmd_mesh_lc_server_get_lc_state_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x094d0000)
#define gecko_cmd_mesh_lc_setup_server_update_property_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x004e0000)
#define gecko_cmd_mesh_scene_client_init_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x004f0000)
#define gecko_cmd_mesh_scene_client_get_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x014f0000)
#define gecko_cmd_mesh_scene_client_get_register_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x024f0000)
#define gecko_cmd_mesh_scene_client_recall_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x034f0000)
#define gecko_cmd_mesh_scene_client_store_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x044f0000)
#define gecko_cmd_mesh_scene_client_delete_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x054f0000)
#define gecko_cmd_mesh_scene_server_init_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00500000)
#define gecko_cmd_mesh_scene_server_deinit_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01500000)
#define gecko_cmd_mesh_scene_server_reset_register_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02500000)
#define gecko_cmd_mesh_scene_setup_server_init_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00510000)
#define gecko_cmd_mesh_scheduler_client_init_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00540000)
#define gecko_cmd_mesh_scheduler_client_deinit_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01540000)
#define gecko_cmd_mesh_scheduler_client_get_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02540000)
#define gecko_cmd_mesh_scheduler_client_get_action_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03540000)
#define gecko_cmd_mesh_scheduler_client_set_action_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04540000)
#define gecko_cmd_mesh_scheduler_server_init_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00550000)
#define gecko_cmd_mesh_scheduler_server_deinit_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01550000)
#define gecko_cmd_mesh_scheduler_server_get_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02550000)
#define gecko_cmd_mesh_scheduler_server_get_action_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03550000)
#define gecko_cmd_mesh_scheduler_server_set_action_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04550000)
#define gecko_cmd_mesh_time_server_init_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00520000)
#define gecko_cmd_mesh_time_server_deinit_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01520000)
#define gecko_cmd_mesh_time_server_get_time_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02520000)
#define gecko_cmd_mesh_time_server_set_time_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03520000)
#define gecko_cmd_mesh_time_server_get_time_zone_offset_new_id        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04520000)
#define gecko_cmd_mesh_time_server_set_time_zone_offset_new_id        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x05520000)
#define gecko_cmd_mesh_time_server_get_tai_utc_delta_new_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x06520000)
#define gecko_cmd_mesh_time_server_set_tai_utc_delta_new_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x07520000)
#define gecko_cmd_mesh_time_server_get_time_role_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x08520000)
#define gecko_cmd_mesh_time_server_set_time_role_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x09520000)
#define gecko_cmd_mesh_time_server_get_datetime_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0a520000)
#define gecko_cmd_mesh_time_client_init_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00530000)
#define gecko_cmd_mesh_time_client_deinit_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01530000)
#define gecko_cmd_mesh_time_client_get_time_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02530000)
#define gecko_cmd_mesh_time_client_set_time_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03530000)
#define gecko_cmd_mesh_time_client_get_time_zone_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04530000)
#define gecko_cmd_mesh_time_client_set_time_zone_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x05530000)
#define gecko_cmd_mesh_time_client_get_tai_utc_delta_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x06530000)
#define gecko_cmd_mesh_time_client_set_tai_utc_delta_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x07530000)
#define gecko_cmd_mesh_time_client_get_time_role_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x08530000)
#define gecko_cmd_mesh_time_client_set_time_role_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x09530000)
#define gecko_cmd_user_message_to_target_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00ff0000)

#define gecko_rsp_dfu_reset_id                                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00000000)
#define gecko_rsp_dfu_flash_set_address_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01000000)
#define gecko_rsp_dfu_flash_upload_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02000000)
#define gecko_rsp_dfu_flash_upload_finish_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03000000)
#define gecko_rsp_system_hello_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00010000)
#define gecko_rsp_system_reset_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01010000)
#define gecko_rsp_system_get_bt_address_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03010000)
#define gecko_rsp_system_set_bt_address_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04010000)
#define gecko_rsp_system_set_tx_power_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0a010000)
#define gecko_rsp_system_get_random_data_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0b010000)
#define gecko_rsp_system_halt_id                                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0c010000)
#define gecko_rsp_system_set_device_name_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0d010000)
#define gecko_rsp_system_linklayer_configure_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0e010000)
#define gecko_rsp_system_get_counters_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0f010000)
#define gecko_rsp_system_data_buffer_write_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x12010000)
#define gecko_rsp_system_set_identity_address_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x13010000)
#define gecko_rsp_system_data_buffer_clear_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x14010000)
#define gecko_rsp_le_gap_open_id                                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00030000)
#define gecko_rsp_le_gap_set_mode_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01030000)
#define gecko_rsp_le_gap_discover_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02030000)
#define gecko_rsp_le_gap_end_procedure_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03030000)
#define gecko_rsp_le_gap_set_adv_parameters_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04030000)
#define gecko_rsp_le_gap_set_conn_parameters_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x05030000)
#define gecko_rsp_le_gap_set_scan_parameters_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x06030000)
#define gecko_rsp_le_gap_set_adv_data_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x07030000)
#define gecko_rsp_le_gap_set_adv_timeout_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x08030000)
#define gecko_rsp_le_gap_set_conn_phy_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x09030000)
#define gecko_rsp_le_gap_bt5_set_mode_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0a030000)
#define gecko_rsp_le_gap_bt5_set_adv_parameters_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0b030000)
#define gecko_rsp_le_gap_bt5_set_adv_data_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0c030000)
#define gecko_rsp_le_gap_set_privacy_mode_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0d030000)
#define gecko_rsp_le_gap_set_advertise_timing_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0e030000)
#define gecko_rsp_le_gap_set_advertise_channel_map_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0f030000)
#define gecko_rsp_le_gap_set_advertise_report_scan_request_id         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x10030000)
#define gecko_rsp_le_gap_set_advertise_phy_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x11030000)
#define gecko_rsp_le_gap_set_advertise_configuration_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x12030000)
#define gecko_rsp_le_gap_clear_advertise_configuration_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x13030000)
#define gecko_rsp_le_gap_start_advertising_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x14030000)
#define gecko_rsp_le_gap_stop_advertising_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x15030000)
#define gecko_rsp_le_gap_set_discovery_timing_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x16030000)
#define gecko_rsp_le_gap_set_discovery_type_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x17030000)
#define gecko_rsp_le_gap_start_discovery_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x18030000)
#define gecko_rsp_le_gap_set_data_channel_classification_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x19030000)
#define gecko_rsp_le_gap_connect_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x1a030000)
#define gecko_rsp_le_gap_set_advertise_tx_power_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x1b030000)
#define gecko_rsp_le_gap_set_discovery_extended_scan_response_id      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x1c030000)
#define gecko_rsp_le_gap_start_periodic_advertising_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x1d030000)
#define gecko_rsp_le_gap_stop_periodic_advertising_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x1f030000)
#define gecko_rsp_le_gap_set_long_advertising_data_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x20030000)
#define gecko_rsp_le_gap_enable_whitelisting_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x21030000)
#define gecko_rsp_le_gap_set_conn_timing_parameters_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x22030000)
#define gecko_rsp_le_gap_set_advertise_random_address_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x25030000)
#define gecko_rsp_le_gap_clear_advertise_random_address_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x26030000)
#define gecko_rsp_sync_open_id                                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00420000)
#define gecko_rsp_sync_close_id                                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01420000)
#define gecko_rsp_le_connection_set_parameters_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00080000)
#define gecko_rsp_le_connection_get_rssi_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01080000)
#define gecko_rsp_le_connection_disable_slave_latency_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02080000)
#define gecko_rsp_le_connection_set_phy_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03080000)
#define gecko_rsp_le_connection_close_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04080000)
#define gecko_rsp_le_connection_set_timing_parameters_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x05080000)
#define gecko_rsp_le_connection_read_channel_map_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x06080000)
#define gecko_rsp_le_connection_set_preferred_phy_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x07080000)
#define gecko_rsp_gatt_set_max_mtu_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00090000)
#define gecko_rsp_gatt_discover_primary_services_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01090000)
#define gecko_rsp_gatt_discover_primary_services_by_uuid_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02090000)
#define gecko_rsp_gatt_discover_characteristics_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03090000)
#define gecko_rsp_gatt_discover_characteristics_by_uuid_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04090000)
#define gecko_rsp_gatt_set_characteristic_notification_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x05090000)
#define gecko_rsp_gatt_discover_descriptors_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x06090000)
#define gecko_rsp_gatt_read_characteristic_value_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x07090000)
#define gecko_rsp_gatt_read_characteristic_value_by_uuid_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x08090000)
#define gecko_rsp_gatt_write_characteristic_value_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x09090000)
#define gecko_rsp_gatt_write_characteristic_value_without_response_id  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0a090000)
#define gecko_rsp_gatt_prepare_characteristic_value_write_id          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0b090000)
#define gecko_rsp_gatt_execute_characteristic_value_write_id          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0c090000)
#define gecko_rsp_gatt_send_characteristic_confirmation_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0d090000)
#define gecko_rsp_gatt_read_descriptor_value_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0e090000)
#define gecko_rsp_gatt_write_descriptor_value_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0f090000)
#define gecko_rsp_gatt_find_included_services_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x10090000)
#define gecko_rsp_gatt_read_multiple_characteristic_values_id         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x11090000)
#define gecko_rsp_gatt_read_characteristic_value_from_offset_id       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x12090000)
#define gecko_rsp_gatt_prepare_characteristic_value_reliable_write_id  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x13090000)
#define gecko_rsp_gatt_server_read_attribute_value_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x000a0000)
#define gecko_rsp_gatt_server_read_attribute_type_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x010a0000)
#define gecko_rsp_gatt_server_write_attribute_value_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x020a0000)
#define gecko_rsp_gatt_server_send_user_read_response_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x030a0000)
#define gecko_rsp_gatt_server_send_user_write_response_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x040a0000)
#define gecko_rsp_gatt_server_send_characteristic_notification_id     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x050a0000)
#define gecko_rsp_gatt_server_find_attribute_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x060a0000)
#define gecko_rsp_gatt_server_set_capabilities_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x080a0000)
#define gecko_rsp_gatt_server_set_max_mtu_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0a0a0000)
#define gecko_rsp_gatt_server_get_mtu_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0b0a0000)
#define gecko_rsp_gatt_server_enable_capabilities_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0c0a0000)
#define gecko_rsp_gatt_server_disable_capabilities_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0d0a0000)
#define gecko_rsp_gatt_server_get_enabled_capabilities_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0e0a0000)
#define gecko_rsp_hardware_set_soft_timer_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x000c0000)
#define gecko_rsp_hardware_get_time_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0b0c0000)
#define gecko_rsp_hardware_set_lazy_soft_timer_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0c0c0000)
#define gecko_rsp_flash_ps_erase_all_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x010d0000)
#define gecko_rsp_flash_ps_save_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x020d0000)
#define gecko_rsp_flash_ps_load_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x030d0000)
#define gecko_rsp_flash_ps_erase_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x040d0000)
#define gecko_rsp_test_dtm_tx_id                                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x000e0000)
#define gecko_rsp_test_dtm_rx_id                                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x010e0000)
#define gecko_rsp_test_dtm_end_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x020e0000)
#define gecko_rsp_sm_set_bondable_mode_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x000f0000)
#define gecko_rsp_sm_configure_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x010f0000)
#define gecko_rsp_sm_store_bonding_configuration_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x020f0000)
#define gecko_rsp_sm_increase_security_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x040f0000)
#define gecko_rsp_sm_delete_bonding_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x060f0000)
#define gecko_rsp_sm_delete_bondings_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x070f0000)
#define gecko_rsp_sm_enter_passkey_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x080f0000)
#define gecko_rsp_sm_passkey_confirm_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x090f0000)
#define gecko_rsp_sm_set_oob_data_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0a0f0000)
#define gecko_rsp_sm_list_all_bondings_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0b0f0000)
#define gecko_rsp_sm_bonding_confirm_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0e0f0000)
#define gecko_rsp_sm_set_debug_mode_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0f0f0000)
#define gecko_rsp_sm_set_passkey_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x100f0000)
#define gecko_rsp_sm_use_sc_oob_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x110f0000)
#define gecko_rsp_sm_set_sc_remote_oob_data_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x120f0000)
#define gecko_rsp_sm_add_to_whitelist_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x130f0000)
#define gecko_rsp_sm_set_minimum_key_size_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x140f0000)
#define gecko_rsp_homekit_configure_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00130000)
#define gecko_rsp_homekit_advertise_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01130000)
#define gecko_rsp_homekit_delete_pairings_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02130000)
#define gecko_rsp_homekit_check_authcp_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03130000)
#define gecko_rsp_homekit_get_pairing_id_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04130000)
#define gecko_rsp_homekit_send_write_response_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x05130000)
#define gecko_rsp_homekit_send_read_response_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x06130000)
#define gecko_rsp_homekit_gsn_action_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x07130000)
#define gecko_rsp_homekit_event_notification_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x08130000)
#define gecko_rsp_homekit_broadcast_action_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x09130000)
#define gecko_rsp_homekit_configure_product_data_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0a130000)
#define gecko_rsp_mesh_node_init_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00140000)
#define gecko_rsp_mesh_node_start_unprov_beaconing_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01140000)
#define gecko_rsp_mesh_node_stop_unprov_beaconing_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x16140000)
#define gecko_rsp_mesh_node_rssi_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x17140000)
#define gecko_rsp_mesh_node_input_oob_request_rsp_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02140000)
#define gecko_rsp_mesh_node_get_uuid_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03140000)
#define gecko_rsp_mesh_node_set_provisioning_data_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04140000)
#define gecko_rsp_mesh_node_init_oob_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x05140000)
#define gecko_rsp_mesh_node_set_ivrecovery_mode_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x06140000)
#define gecko_rsp_mesh_node_get_ivrecovery_mode_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x07140000)
#define gecko_rsp_mesh_node_set_adv_event_filter_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x08140000)
#define gecko_rsp_mesh_node_get_statistics_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x09140000)
#define gecko_rsp_mesh_node_clear_statistics_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0a140000)
#define gecko_rsp_mesh_node_set_net_relay_delay_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0b140000)
#define gecko_rsp_mesh_node_get_net_relay_delay_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0c140000)
#define gecko_rsp_mesh_node_get_ivupdate_state_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0d140000)
#define gecko_rsp_mesh_node_request_ivupdate_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0e140000)
#define gecko_rsp_mesh_node_get_seq_remaining_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0f140000)
#define gecko_rsp_mesh_node_save_replay_protection_list_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x10140000)
#define gecko_rsp_mesh_node_set_uuid_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x11140000)
#define gecko_rsp_mesh_node_get_element_address_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x12140000)
#define gecko_rsp_mesh_node_static_oob_request_rsp_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x13140000)
#define gecko_rsp_mesh_node_reset_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x15140000)
#define gecko_rsp_mesh_node_set_beacon_reporting_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x18140000)
#define gecko_rsp_mesh_node_set_iv_update_age_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x19140000)
#define gecko_rsp_mesh_prov_init_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00150000)
#define gecko_rsp_mesh_prov_scan_unprov_beacons_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01150000)
#define gecko_rsp_mesh_prov_provision_device_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02150000)
#define gecko_rsp_mesh_prov_create_network_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03150000)
#define gecko_rsp_mesh_prov_get_dcd_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04150000)
#define gecko_rsp_mesh_prov_get_config_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x05150000)
#define gecko_rsp_mesh_prov_set_config_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x06150000)
#define gecko_rsp_mesh_prov_create_appkey_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x07150000)
#define gecko_rsp_mesh_prov_oob_pkey_rsp_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x08150000)
#define gecko_rsp_mesh_prov_oob_auth_rsp_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x09150000)
#define gecko_rsp_mesh_prov_set_oob_requirements_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0a150000)
#define gecko_rsp_mesh_prov_key_refresh_start_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0b150000)
#define gecko_rsp_mesh_prov_get_key_refresh_blacklist_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0c150000)
#define gecko_rsp_mesh_prov_set_key_refresh_blacklist_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0d150000)
#define gecko_rsp_mesh_prov_appkey_add_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0e150000)
#define gecko_rsp_mesh_prov_appkey_delete_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0f150000)
#define gecko_rsp_mesh_prov_model_app_bind_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x10150000)
#define gecko_rsp_mesh_prov_model_app_unbind_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x11150000)
#define gecko_rsp_mesh_prov_model_app_get_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x12150000)
#define gecko_rsp_mesh_prov_model_sub_add_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x13150000)
#define gecko_rsp_mesh_prov_model_pub_set_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x14150000)
#define gecko_rsp_mesh_prov_provision_gatt_device_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x15150000)
#define gecko_rsp_mesh_prov_ddb_get_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x16150000)
#define gecko_rsp_mesh_prov_ddb_delete_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x17150000)
#define gecko_rsp_mesh_prov_ddb_add_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x18150000)
#define gecko_rsp_mesh_prov_ddb_list_devices_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x19150000)
#define gecko_rsp_mesh_prov_network_add_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x1a150000)
#define gecko_rsp_mesh_prov_network_delete_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x1b150000)
#define gecko_rsp_mesh_prov_nettx_get_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x1c150000)
#define gecko_rsp_mesh_prov_nettx_set_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x1d150000)
#define gecko_rsp_mesh_prov_model_sub_del_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x1e150000)
#define gecko_rsp_mesh_prov_model_sub_add_va_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x1f150000)
#define gecko_rsp_mesh_prov_model_sub_del_va_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x20150000)
#define gecko_rsp_mesh_prov_model_sub_set_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x21150000)
#define gecko_rsp_mesh_prov_model_sub_set_va_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x22150000)
#define gecko_rsp_mesh_prov_heartbeat_publication_get_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x23150000)
#define gecko_rsp_mesh_prov_heartbeat_publication_set_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x24150000)
#define gecko_rsp_mesh_prov_heartbeat_subscription_get_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x25150000)
#define gecko_rsp_mesh_prov_heartbeat_subscription_set_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x26150000)
#define gecko_rsp_mesh_prov_relay_get_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x27150000)
#define gecko_rsp_mesh_prov_relay_set_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x28150000)
#define gecko_rsp_mesh_prov_reset_node_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x29150000)
#define gecko_rsp_mesh_prov_appkey_get_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x2a150000)
#define gecko_rsp_mesh_prov_network_get_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x2b150000)
#define gecko_rsp_mesh_prov_model_sub_clear_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x2c150000)
#define gecko_rsp_mesh_prov_model_pub_get_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x2d150000)
#define gecko_rsp_mesh_prov_model_pub_set_va_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x2e150000)
#define gecko_rsp_mesh_prov_model_pub_set_cred_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x2f150000)
#define gecko_rsp_mesh_prov_model_pub_set_va_cred_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x30150000)
#define gecko_rsp_mesh_prov_model_sub_get_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x31150000)
#define gecko_rsp_mesh_prov_friend_timeout_get_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x32150000)
#define gecko_rsp_mesh_prov_get_default_configuration_timeout_id      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x33150000)
#define gecko_rsp_mesh_prov_set_default_configuration_timeout_id      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x34150000)
#define gecko_rsp_mesh_prov_provision_device_with_address_id          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x35150000)
#define gecko_rsp_mesh_prov_provision_gatt_device_with_address_id     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x36150000)
#define gecko_rsp_mesh_prov_initialize_network_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x37150000)
#define gecko_rsp_mesh_prov_get_key_refresh_appkey_blacklist_id       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x38150000)
#define gecko_rsp_mesh_prov_set_key_refresh_appkey_blacklist_id       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x39150000)
#define gecko_rsp_mesh_prov_stop_scan_unprov_beacons_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x3a150000)
#define gecko_rsp_mesh_prov_ddb_update_netkey_index_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x3b150000)
#define gecko_rsp_mesh_prov_key_refresh_suspend_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x3c150000)
#define gecko_rsp_mesh_prov_key_refresh_resume_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x3d150000)
#define gecko_rsp_mesh_prov_get_key_refresh_phase_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x3e150000)
#define gecko_rsp_mesh_prov_key_refresh_start_from_phase_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x3f150000)
#define gecko_rsp_mesh_prov_flush_key_refresh_state_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x40150000)
#define gecko_rsp_mesh_proxy_connect_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00180000)
#define gecko_rsp_mesh_proxy_disconnect_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01180000)
#define gecko_rsp_mesh_proxy_set_filter_type_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02180000)
#define gecko_rsp_mesh_proxy_allow_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03180000)
#define gecko_rsp_mesh_proxy_deny_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04180000)
#define gecko_rsp_mesh_vendor_model_send_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00190000)
#define gecko_rsp_mesh_vendor_model_set_publication_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01190000)
#define gecko_rsp_mesh_vendor_model_clear_publication_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02190000)
#define gecko_rsp_mesh_vendor_model_publish_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03190000)
#define gecko_rsp_mesh_vendor_model_init_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04190000)
#define gecko_rsp_mesh_vendor_model_deinit_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x05190000)
#define gecko_rsp_mesh_health_client_get_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x001a0000)
#define gecko_rsp_mesh_health_client_clear_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x011a0000)
#define gecko_rsp_mesh_health_client_test_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x021a0000)
#define gecko_rsp_mesh_health_client_get_period_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x031a0000)
#define gecko_rsp_mesh_health_client_set_period_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x041a0000)
#define gecko_rsp_mesh_health_client_get_attention_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x051a0000)
#define gecko_rsp_mesh_health_client_set_attention_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x061a0000)
#define gecko_rsp_mesh_health_server_set_fault_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x001b0000)
#define gecko_rsp_mesh_health_server_clear_fault_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x011b0000)
#define gecko_rsp_mesh_health_server_test_response_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x021b0000)
#define gecko_rsp_mesh_generic_client_get_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x001e0000)
#define gecko_rsp_mesh_generic_client_set_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x011e0000)
#define gecko_rsp_mesh_generic_client_publish_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x021e0000)
#define gecko_rsp_mesh_generic_client_get_params_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x031e0000)
#define gecko_rsp_mesh_generic_client_init_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x041e0000)
#define gecko_rsp_mesh_generic_client_init_common_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x051e0000)
#define gecko_rsp_mesh_generic_client_init_on_off_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x061e0000)
#define gecko_rsp_mesh_generic_client_init_level_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x071e0000)
#define gecko_rsp_mesh_generic_client_init_default_transition_time_id  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x081e0000)
#define gecko_rsp_mesh_generic_client_init_power_on_off_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x091e0000)
#define gecko_rsp_mesh_generic_client_init_power_level_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0a1e0000)
#define gecko_rsp_mesh_generic_client_init_battery_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0b1e0000)
#define gecko_rsp_mesh_generic_client_init_location_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0c1e0000)
#define gecko_rsp_mesh_generic_client_init_property_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0d1e0000)
#define gecko_rsp_mesh_generic_client_init_lightness_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0e1e0000)
#define gecko_rsp_mesh_generic_client_init_ctl_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0f1e0000)
#define gecko_rsp_mesh_generic_server_response_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x001f0000)
#define gecko_rsp_mesh_generic_server_update_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x011f0000)
#define gecko_rsp_mesh_generic_server_publish_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x021f0000)
#define gecko_rsp_mesh_generic_server_init_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x041f0000)
#define gecko_rsp_mesh_generic_server_init_common_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x051f0000)
#define gecko_rsp_mesh_generic_server_init_on_off_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x061f0000)
#define gecko_rsp_mesh_generic_server_init_level_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x071f0000)
#define gecko_rsp_mesh_generic_server_init_default_transition_time_id  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x081f0000)
#define gecko_rsp_mesh_generic_server_init_power_on_off_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x091f0000)
#define gecko_rsp_mesh_generic_server_init_power_level_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0a1f0000)
#define gecko_rsp_mesh_generic_server_init_battery_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0b1f0000)
#define gecko_rsp_mesh_generic_server_init_location_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0c1f0000)
#define gecko_rsp_mesh_generic_server_init_property_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0d1f0000)
#define gecko_rsp_mesh_generic_server_init_lightness_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0e1f0000)
#define gecko_rsp_mesh_generic_server_init_ctl_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0f1f0000)
#define gecko_rsp_coex_set_options_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00200000)
#define gecko_rsp_coex_get_counters_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01200000)
#define gecko_rsp_coex_set_parameters_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02200000)
#define gecko_rsp_coex_set_directional_priority_pulse_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03200000)
#define gecko_rsp_mesh_test_get_nettx_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00220000)
#define gecko_rsp_mesh_test_set_nettx_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01220000)
#define gecko_rsp_mesh_test_get_relay_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02220000)
#define gecko_rsp_mesh_test_set_relay_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03220000)
#define gecko_rsp_mesh_test_set_adv_scan_params_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04220000)
#define gecko_rsp_mesh_test_set_ivupdate_test_mode_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x05220000)
#define gecko_rsp_mesh_test_get_ivupdate_test_mode_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x06220000)
#define gecko_rsp_mesh_test_set_segment_send_delay_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x07220000)
#define gecko_rsp_mesh_test_set_ivupdate_state_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x08220000)
#define gecko_rsp_mesh_test_send_beacons_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x09220000)
#define gecko_rsp_mesh_test_bind_local_model_app_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0a220000)
#define gecko_rsp_mesh_test_unbind_local_model_app_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0b220000)
#define gecko_rsp_mesh_test_add_local_model_sub_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0c220000)
#define gecko_rsp_mesh_test_del_local_model_sub_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0d220000)
#define gecko_rsp_mesh_test_add_local_model_sub_va_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0e220000)
#define gecko_rsp_mesh_test_del_local_model_sub_va_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0f220000)
#define gecko_rsp_mesh_test_get_local_model_sub_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x10220000)
#define gecko_rsp_mesh_test_set_local_model_pub_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x11220000)
#define gecko_rsp_mesh_test_set_local_model_pub_va_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x12220000)
#define gecko_rsp_mesh_test_get_local_model_pub_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x13220000)
#define gecko_rsp_mesh_test_set_local_heartbeat_subscription_id       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x14220000)
#define gecko_rsp_mesh_test_get_local_heartbeat_subscription_id       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x15220000)
#define gecko_rsp_mesh_test_get_local_heartbeat_publication_id        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x16220000)
#define gecko_rsp_mesh_test_set_local_heartbeat_publication_id        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x17220000)
#define gecko_rsp_mesh_test_set_local_config_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x18220000)
#define gecko_rsp_mesh_test_get_local_config_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x19220000)
#define gecko_rsp_mesh_test_add_local_key_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x1a220000)
#define gecko_rsp_mesh_test_del_local_key_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x1b220000)
#define gecko_rsp_mesh_test_update_local_key_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x1c220000)
#define gecko_rsp_mesh_test_set_sar_config_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x1d220000)
#define gecko_rsp_mesh_test_get_element_seqnum_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x1e220000)
#define gecko_rsp_mesh_test_set_adv_bearer_state_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x1f220000)
#define gecko_rsp_mesh_test_get_key_count_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x20220000)
#define gecko_rsp_mesh_test_get_key_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x21220000)
#define gecko_rsp_mesh_test_prov_get_device_key_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x23220000)
#define gecko_rsp_mesh_test_prov_prepare_key_refresh_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x24220000)
#define gecko_rsp_mesh_test_cancel_segmented_tx_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x25220000)
#define gecko_rsp_mesh_test_set_iv_index_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x26220000)
#define gecko_rsp_mesh_test_set_element_seqnum_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x27220000)
#define gecko_rsp_mesh_test_set_model_option_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x28220000)
#define gecko_rsp_mesh_test_get_local_model_app_bindings_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x29220000)
#define gecko_rsp_mesh_lpn_init_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00230000)
#define gecko_rsp_mesh_lpn_deinit_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01230000)
#define gecko_rsp_mesh_lpn_configure_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02230000)
#define gecko_rsp_mesh_lpn_establish_friendship_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03230000)
#define gecko_rsp_mesh_lpn_poll_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04230000)
#define gecko_rsp_mesh_lpn_terminate_friendship_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x05230000)
#define gecko_rsp_mesh_lpn_config_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x06230000)
#define gecko_rsp_mesh_friend_init_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00240000)
#define gecko_rsp_mesh_friend_deinit_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01240000)
#define gecko_rsp_mesh_config_client_cancel_request_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00270000)
#define gecko_rsp_mesh_config_client_get_request_status_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01270000)
#define gecko_rsp_mesh_config_client_get_default_timeout_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x2e270000)
#define gecko_rsp_mesh_config_client_set_default_timeout_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x2f270000)
#define gecko_rsp_mesh_config_client_add_netkey_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02270000)
#define gecko_rsp_mesh_config_client_remove_netkey_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03270000)
#define gecko_rsp_mesh_config_client_list_netkeys_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04270000)
#define gecko_rsp_mesh_config_client_add_appkey_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x05270000)
#define gecko_rsp_mesh_config_client_remove_appkey_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x06270000)
#define gecko_rsp_mesh_config_client_list_appkeys_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x07270000)
#define gecko_rsp_mesh_config_client_bind_model_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x08270000)
#define gecko_rsp_mesh_config_client_unbind_model_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x09270000)
#define gecko_rsp_mesh_config_client_list_bindings_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0a270000)
#define gecko_rsp_mesh_config_client_get_model_pub_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0b270000)
#define gecko_rsp_mesh_config_client_set_model_pub_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0c270000)
#define gecko_rsp_mesh_config_client_set_model_pub_va_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0d270000)
#define gecko_rsp_mesh_config_client_add_model_sub_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0e270000)
#define gecko_rsp_mesh_config_client_add_model_sub_va_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0f270000)
#define gecko_rsp_mesh_config_client_remove_model_sub_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x10270000)
#define gecko_rsp_mesh_config_client_remove_model_sub_va_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x11270000)
#define gecko_rsp_mesh_config_client_set_model_sub_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x12270000)
#define gecko_rsp_mesh_config_client_set_model_sub_va_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x13270000)
#define gecko_rsp_mesh_config_client_clear_model_sub_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x14270000)
#define gecko_rsp_mesh_config_client_list_subs_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x15270000)
#define gecko_rsp_mesh_config_client_get_heartbeat_pub_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x16270000)
#define gecko_rsp_mesh_config_client_set_heartbeat_pub_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x17270000)
#define gecko_rsp_mesh_config_client_get_heartbeat_sub_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x19270000)
#define gecko_rsp_mesh_config_client_set_heartbeat_sub_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x1a270000)
#define gecko_rsp_mesh_config_client_get_beacon_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x1b270000)
#define gecko_rsp_mesh_config_client_set_beacon_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x1c270000)
#define gecko_rsp_mesh_config_client_get_default_ttl_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x1d270000)
#define gecko_rsp_mesh_config_client_set_default_ttl_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x1e270000)
#define gecko_rsp_mesh_config_client_get_gatt_proxy_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x1f270000)
#define gecko_rsp_mesh_config_client_set_gatt_proxy_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x20270000)
#define gecko_rsp_mesh_config_client_get_relay_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x21270000)
#define gecko_rsp_mesh_config_client_set_relay_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x22270000)
#define gecko_rsp_mesh_config_client_get_network_transmit_id          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x23270000)
#define gecko_rsp_mesh_config_client_set_network_transmit_id          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x24270000)
#define gecko_rsp_mesh_config_client_get_identity_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x25270000)
#define gecko_rsp_mesh_config_client_set_identity_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x26270000)
#define gecko_rsp_mesh_config_client_get_friend_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x27270000)
#define gecko_rsp_mesh_config_client_set_friend_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x28270000)
#define gecko_rsp_mesh_config_client_get_lpn_polltimeout_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x2b270000)
#define gecko_rsp_mesh_config_client_get_dcd_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x2c270000)
#define gecko_rsp_mesh_config_client_reset_node_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x2d270000)
#define gecko_rsp_l2cap_coc_send_connection_request_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01430000)
#define gecko_rsp_l2cap_coc_send_connection_response_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02430000)
#define gecko_rsp_l2cap_coc_send_le_flow_control_credit_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03430000)
#define gecko_rsp_l2cap_coc_send_disconnection_request_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04430000)
#define gecko_rsp_l2cap_coc_send_data_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x05430000)
#define gecko_rsp_cte_transmitter_enable_connection_cte_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00440000)
#define gecko_rsp_cte_transmitter_disable_connection_cte_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01440000)
#define gecko_rsp_cte_transmitter_enable_connectionless_cte_id        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02440000)
#define gecko_rsp_cte_transmitter_disable_connectionless_cte_id       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03440000)
#define gecko_rsp_cte_transmitter_set_dtm_parameters_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04440000)
#define gecko_rsp_cte_transmitter_clear_dtm_parameters_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x05440000)
#define gecko_rsp_cte_transmitter_enable_silabs_cte_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x06440000)
#define gecko_rsp_cte_transmitter_disable_silabs_cte_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x07440000)
#define gecko_rsp_cte_receiver_configure_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00450000)
#define gecko_rsp_cte_receiver_enable_connection_cte_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01450000)
#define gecko_rsp_cte_receiver_disable_connection_cte_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02450000)
#define gecko_rsp_cte_receiver_enable_connectionless_cte_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03450000)
#define gecko_rsp_cte_receiver_disable_connectionless_cte_id          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04450000)
#define gecko_rsp_cte_receiver_set_dtm_parameters_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x05450000)
#define gecko_rsp_cte_receiver_clear_dtm_parameters_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x06450000)
#define gecko_rsp_cte_receiver_enable_silabs_cte_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x07450000)
#define gecko_rsp_cte_receiver_disable_silabs_cte_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x08450000)
#define gecko_rsp_mesh_sensor_server_init_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00470000)
#define gecko_rsp_mesh_sensor_server_deinit_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01470000)
#define gecko_rsp_mesh_sensor_server_send_descriptor_status_id        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02470000)
#define gecko_rsp_mesh_sensor_server_send_status_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03470000)
#define gecko_rsp_mesh_sensor_server_send_column_status_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04470000)
#define gecko_rsp_mesh_sensor_server_send_series_status_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x05470000)
#define gecko_rsp_mesh_sensor_setup_server_send_cadence_status_id     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00480000)
#define gecko_rsp_mesh_sensor_setup_server_send_settings_status_id    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01480000)
#define gecko_rsp_mesh_sensor_setup_server_send_setting_status_id     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02480000)
#define gecko_rsp_mesh_sensor_client_init_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00490000)
#define gecko_rsp_mesh_sensor_client_deinit_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01490000)
#define gecko_rsp_mesh_sensor_client_get_descriptor_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02490000)
#define gecko_rsp_mesh_sensor_client_get_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03490000)
#define gecko_rsp_mesh_sensor_client_get_column_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04490000)
#define gecko_rsp_mesh_sensor_client_get_series_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x05490000)
#define gecko_rsp_mesh_sensor_client_get_cadence_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x06490000)
#define gecko_rsp_mesh_sensor_client_set_cadence_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x07490000)
#define gecko_rsp_mesh_sensor_client_get_settings_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x08490000)
#define gecko_rsp_mesh_sensor_client_get_setting_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x09490000)
#define gecko_rsp_mesh_sensor_client_set_setting_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0a490000)
#define gecko_rsp_mesh_lc_client_init_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x004c0000)
#define gecko_rsp_mesh_lc_client_get_mode_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x014c0000)
#define gecko_rsp_mesh_lc_client_set_mode_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x024c0000)
#define gecko_rsp_mesh_lc_client_get_om_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x044c0000)
#define gecko_rsp_mesh_lc_client_set_om_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x054c0000)
#define gecko_rsp_mesh_lc_client_get_light_onoff_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x074c0000)
#define gecko_rsp_mesh_lc_client_set_light_onoff_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x084c0000)
#define gecko_rsp_mesh_lc_client_get_property_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x094c0000)
#define gecko_rsp_mesh_lc_client_set_property_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0a4c0000)
#define gecko_rsp_mesh_lc_server_init_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x004d0000)
#define gecko_rsp_mesh_lc_server_deinit_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x014d0000)
#define gecko_rsp_mesh_lc_server_update_mode_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x024d0000)
#define gecko_rsp_mesh_lc_server_update_om_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x034d0000)
#define gecko_rsp_mesh_lc_server_update_light_onoff_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x044d0000)
#define gecko_rsp_mesh_lc_server_init_all_properties_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x054d0000)
#define gecko_rsp_mesh_lc_server_set_publish_mask_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x064d0000)
#define gecko_rsp_mesh_lc_server_set_regulator_interval_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x074d0000)
#define gecko_rsp_mesh_lc_server_set_event_mask_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x084d0000)
#define gecko_rsp_mesh_lc_server_get_lc_state_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x094d0000)
#define gecko_rsp_mesh_lc_setup_server_update_property_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x004e0000)
#define gecko_rsp_mesh_scene_client_init_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x004f0000)
#define gecko_rsp_mesh_scene_client_get_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x014f0000)
#define gecko_rsp_mesh_scene_client_get_register_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x024f0000)
#define gecko_rsp_mesh_scene_client_recall_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x034f0000)
#define gecko_rsp_mesh_scene_client_store_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x044f0000)
#define gecko_rsp_mesh_scene_client_delete_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x054f0000)
#define gecko_rsp_mesh_scene_server_init_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00500000)
#define gecko_rsp_mesh_scene_server_deinit_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01500000)
#define gecko_rsp_mesh_scene_server_reset_register_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02500000)
#define gecko_rsp_mesh_scene_setup_server_init_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00510000)
#define gecko_rsp_mesh_scheduler_client_init_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00540000)
#define gecko_rsp_mesh_scheduler_client_deinit_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01540000)
#define gecko_rsp_mesh_scheduler_client_get_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02540000)
#define gecko_rsp_mesh_scheduler_client_get_action_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03540000)
#define gecko_rsp_mesh_scheduler_client_set_action_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04540000)
#define gecko_rsp_mesh_scheduler_server_init_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00550000)
#define gecko_rsp_mesh_scheduler_server_deinit_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01550000)
#define gecko_rsp_mesh_scheduler_server_get_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02550000)
#define gecko_rsp_mesh_scheduler_server_get_action_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03550000)
#define gecko_rsp_mesh_scheduler_server_set_action_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04550000)
#define gecko_rsp_mesh_time_server_init_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00520000)
#define gecko_rsp_mesh_time_server_deinit_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01520000)
#define gecko_rsp_mesh_time_server_get_time_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02520000)
#define gecko_rsp_mesh_time_server_set_time_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03520000)
#define gecko_rsp_mesh_time_server_get_time_zone_offset_new_id        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04520000)
#define gecko_rsp_mesh_time_server_set_time_zone_offset_new_id        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x05520000)
#define gecko_rsp_mesh_time_server_get_tai_utc_delta_new_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x06520000)
#define gecko_rsp_mesh_time_server_set_tai_utc_delta_new_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x07520000)
#define gecko_rsp_mesh_time_server_get_time_role_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x08520000)
#define gecko_rsp_mesh_time_server_set_time_role_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x09520000)
#define gecko_rsp_mesh_time_server_get_datetime_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0a520000)
#define gecko_rsp_mesh_time_client_init_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00530000)
#define gecko_rsp_mesh_time_client_deinit_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01530000)
#define gecko_rsp_mesh_time_client_get_time_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02530000)
#define gecko_rsp_mesh_time_client_set_time_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03530000)
#define gecko_rsp_mesh_time_client_get_time_zone_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04530000)
#define gecko_rsp_mesh_time_client_set_time_zone_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x05530000)
#define gecko_rsp_mesh_time_client_get_tai_utc_delta_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x06530000)
#define gecko_rsp_mesh_time_client_set_tai_utc_delta_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x07530000)
#define gecko_rsp_mesh_time_client_get_time_role_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x08530000)
#define gecko_rsp_mesh_time_client_set_time_role_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x09530000)
#define gecko_rsp_user_message_to_target_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00ff0000)

#define gecko_evt_dfu_boot_id                                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00000000)
#define gecko_evt_dfu_boot_failure_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01000000)
#define gecko_evt_system_boot_id                                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00010000)
#define gecko_evt_system_external_signal_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x03010000)
#define gecko_evt_system_awake_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x04010000)
#define gecko_evt_system_hardware_error_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x05010000)
#define gecko_evt_system_error_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x06010000)
#define gecko_evt_le_gap_scan_response_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00030000)
#define gecko_evt_le_gap_adv_timeout_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01030000)
#define gecko_evt_le_gap_scan_request_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02030000)
#define gecko_evt_le_gap_extended_scan_response_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x04030000)
#define gecko_evt_le_gap_periodic_advertising_status_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x05030000)
#define gecko_evt_sync_opened_id                                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00420000)
#define gecko_evt_sync_closed_id                                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01420000)
#define gecko_evt_sync_data_id                                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02420000)
#define gecko_evt_le_connection_opened_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00080000)
#define gecko_evt_le_connection_closed_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01080000)
#define gecko_evt_le_connection_parameters_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02080000)
#define gecko_evt_le_connection_rssi_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x03080000)
#define gecko_evt_le_connection_phy_status_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x04080000)
#define gecko_evt_gatt_mtu_exchanged_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00090000)
#define gecko_evt_gatt_service_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01090000)
#define gecko_evt_gatt_characteristic_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02090000)
#define gecko_evt_gatt_descriptor_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x03090000)
#define gecko_evt_gatt_characteristic_value_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x04090000)
#define gecko_evt_gatt_descriptor_value_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x05090000)
#define gecko_evt_gatt_procedure_completed_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x06090000)
#define gecko_evt_gatt_server_attribute_value_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x000a0000)
#define gecko_evt_gatt_server_user_read_request_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x010a0000)
#define gecko_evt_gatt_server_user_write_request_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x020a0000)
#define gecko_evt_gatt_server_characteristic_status_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x030a0000)
#define gecko_evt_gatt_server_execute_write_completed_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x040a0000)
#define gecko_evt_hardware_soft_timer_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x000c0000)
#define gecko_evt_test_dtm_completed_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x000e0000)
#define gecko_evt_sm_passkey_display_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x000f0000)
#define gecko_evt_sm_passkey_request_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x010f0000)
#define gecko_evt_sm_confirm_passkey_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x020f0000)
#define gecko_evt_sm_bonded_id                                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x030f0000)
#define gecko_evt_sm_bonding_failed_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x040f0000)
#define gecko_evt_sm_list_bonding_entry_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x050f0000)
#define gecko_evt_sm_list_all_bondings_complete_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x060f0000)
#define gecko_evt_sm_confirm_bonding_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x090f0000)
#define gecko_evt_homekit_setupcode_display_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00130000)
#define gecko_evt_homekit_paired_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01130000)
#define gecko_evt_homekit_pair_verified_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02130000)
#define gecko_evt_homekit_connection_opened_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x03130000)
#define gecko_evt_homekit_connection_closed_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x04130000)
#define gecko_evt_homekit_identify_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x05130000)
#define gecko_evt_homekit_write_request_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x06130000)
#define gecko_evt_homekit_read_request_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x07130000)
#define gecko_evt_homekit_disconnection_required_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x08130000)
#define gecko_evt_homekit_pairing_removed_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x09130000)
#define gecko_evt_homekit_setuppayload_display_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x0a130000)
#define gecko_evt_mesh_node_initialized_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00140000)
#define gecko_evt_mesh_node_provisioned_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01140000)
#define gecko_evt_mesh_node_config_get_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02140000)
#define gecko_evt_mesh_node_config_set_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x03140000)
#define gecko_evt_mesh_node_display_output_oob_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x04140000)
#define gecko_evt_mesh_node_input_oob_request_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x05140000)
#define gecko_evt_mesh_node_provisioning_started_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x06140000)
#define gecko_evt_mesh_node_provisioning_failed_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x07140000)
#define gecko_evt_mesh_node_key_added_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x08140000)
#define gecko_evt_mesh_node_model_config_changed_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x09140000)
#define gecko_evt_mesh_node_reset_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x0a140000)
#define gecko_evt_mesh_node_ivrecovery_needed_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x0b140000)
#define gecko_evt_mesh_node_changed_ivupdate_state_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x0c140000)
#define gecko_evt_mesh_node_static_oob_request_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x0d140000)
#define gecko_evt_mesh_node_key_removed_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x0e140000)
#define gecko_evt_mesh_node_key_updated_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x0f140000)
#define gecko_evt_mesh_node_heartbeat_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x10140000)
#define gecko_evt_mesh_node_heartbeat_start_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x11140000)
#define gecko_evt_mesh_node_heartbeat_stop_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x12140000)
#define gecko_evt_mesh_node_beacon_received_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x13140000)
#define gecko_evt_mesh_prov_initialized_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00150000)
#define gecko_evt_mesh_prov_provisioning_failed_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01150000)
#define gecko_evt_mesh_prov_device_provisioned_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02150000)
#define gecko_evt_mesh_prov_unprov_beacon_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x03150000)
#define gecko_evt_mesh_prov_dcd_status_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x04150000)
#define gecko_evt_mesh_prov_config_status_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x05150000)
#define gecko_evt_mesh_prov_oob_pkey_request_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x06150000)
#define gecko_evt_mesh_prov_oob_auth_request_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x07150000)
#define gecko_evt_mesh_prov_oob_display_input_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x08150000)
#define gecko_evt_mesh_prov_ddb_list_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x09150000)
#define gecko_evt_mesh_prov_heartbeat_publication_status_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x0a150000)
#define gecko_evt_mesh_prov_heartbeat_subscription_status_id          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x0b150000)
#define gecko_evt_mesh_prov_relay_status_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x0c150000)
#define gecko_evt_mesh_prov_uri_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x0d150000)
#define gecko_evt_mesh_prov_node_reset_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x0e150000)
#define gecko_evt_mesh_prov_appkey_list_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x0f150000)
#define gecko_evt_mesh_prov_appkey_list_end_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x10150000)
#define gecko_evt_mesh_prov_network_list_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x11150000)
#define gecko_evt_mesh_prov_network_list_end_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x12150000)
#define gecko_evt_mesh_prov_model_pub_status_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x13150000)
#define gecko_evt_mesh_prov_key_refresh_phase_update_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x14150000)
#define gecko_evt_mesh_prov_key_refresh_node_update_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x15150000)
#define gecko_evt_mesh_prov_key_refresh_complete_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x16150000)
#define gecko_evt_mesh_prov_model_sub_addr_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x17150000)
#define gecko_evt_mesh_prov_model_sub_addr_end_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x18150000)
#define gecko_evt_mesh_prov_friend_timeout_status_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x19150000)
#define gecko_evt_mesh_proxy_connected_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00180000)
#define gecko_evt_mesh_proxy_disconnected_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01180000)
#define gecko_evt_mesh_proxy_filter_status_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02180000)
#define gecko_evt_mesh_vendor_model_receive_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00190000)
#define gecko_evt_mesh_health_client_server_status_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x001a0000)
#define gecko_evt_mesh_health_client_server_status_period_id          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x011a0000)
#define gecko_evt_mesh_health_client_server_status_attention_id       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x021a0000)
#define gecko_evt_mesh_health_server_attention_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x001b0000)
#define gecko_evt_mesh_health_server_test_request_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x011b0000)
#define gecko_evt_mesh_generic_client_server_status_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x001e0000)
#define gecko_evt_mesh_generic_server_client_request_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x001f0000)
#define gecko_evt_mesh_generic_server_state_changed_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x011f0000)
#define gecko_evt_mesh_generic_server_state_recall_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x021f0000)
#define gecko_evt_mesh_test_local_heartbeat_subscription_complete_id  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00220000)
#define gecko_evt_mesh_lpn_friendship_established_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00230000)
#define gecko_evt_mesh_lpn_friendship_failed_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01230000)
#define gecko_evt_mesh_lpn_friendship_terminated_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02230000)
#define gecko_evt_mesh_friend_friendship_established_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00240000)
#define gecko_evt_mesh_friend_friendship_terminated_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01240000)
#define gecko_evt_mesh_config_client_request_modified_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00270000)
#define gecko_evt_mesh_config_client_netkey_status_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01270000)
#define gecko_evt_mesh_config_client_netkey_list_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02270000)
#define gecko_evt_mesh_config_client_netkey_list_end_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x03270000)
#define gecko_evt_mesh_config_client_appkey_status_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x04270000)
#define gecko_evt_mesh_config_client_appkey_list_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x05270000)
#define gecko_evt_mesh_config_client_appkey_list_end_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x06270000)
#define gecko_evt_mesh_config_client_binding_status_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x07270000)
#define gecko_evt_mesh_config_client_bindings_list_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x08270000)
#define gecko_evt_mesh_config_client_bindings_list_end_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x09270000)
#define gecko_evt_mesh_config_client_model_pub_status_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x0a270000)
#define gecko_evt_mesh_config_client_model_sub_status_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x0b270000)
#define gecko_evt_mesh_config_client_subs_list_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x0c270000)
#define gecko_evt_mesh_config_client_subs_list_end_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x0d270000)
#define gecko_evt_mesh_config_client_heartbeat_pub_status_id          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x0e270000)
#define gecko_evt_mesh_config_client_heartbeat_sub_status_id          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x0f270000)
#define gecko_evt_mesh_config_client_beacon_status_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x10270000)
#define gecko_evt_mesh_config_client_default_ttl_status_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x11270000)
#define gecko_evt_mesh_config_client_gatt_proxy_status_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x12270000)
#define gecko_evt_mesh_config_client_relay_status_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x13270000)
#define gecko_evt_mesh_config_client_network_transmit_status_id       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x14270000)
#define gecko_evt_mesh_config_client_identity_status_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x15270000)
#define gecko_evt_mesh_config_client_friend_status_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x16270000)
#define gecko_evt_mesh_config_client_lpn_polltimeout_status_id        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x18270000)
#define gecko_evt_mesh_config_client_dcd_data_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x19270000)
#define gecko_evt_mesh_config_client_dcd_data_end_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x1a270000)
#define gecko_evt_mesh_config_client_reset_status_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x1b270000)
#define gecko_evt_l2cap_coc_connection_request_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01430000)
#define gecko_evt_l2cap_coc_connection_response_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02430000)
#define gecko_evt_l2cap_coc_le_flow_control_credit_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x03430000)
#define gecko_evt_l2cap_coc_channel_disconnected_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x04430000)
#define gecko_evt_l2cap_coc_data_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x05430000)
#define gecko_evt_l2cap_command_rejected_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x06430000)
#define gecko_evt_cte_receiver_connection_iq_report_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00450000)
#define gecko_evt_cte_receiver_connectionless_iq_report_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01450000)
#define gecko_evt_cte_receiver_dtm_iq_report_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02450000)
#define gecko_evt_cte_receiver_silabs_iq_report_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x03450000)
#define gecko_evt_mesh_sensor_server_get_request_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01470000)
#define gecko_evt_mesh_sensor_server_get_column_request_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02470000)
#define gecko_evt_mesh_sensor_server_get_series_request_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x03470000)
#define gecko_evt_mesh_sensor_server_publish_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x04470000)
#define gecko_evt_mesh_sensor_setup_server_get_cadence_request_id     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00480000)
#define gecko_evt_mesh_sensor_setup_server_set_cadence_request_id     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01480000)
#define gecko_evt_mesh_sensor_setup_server_get_settings_request_id    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02480000)
#define gecko_evt_mesh_sensor_setup_server_get_setting_request_id     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x03480000)
#define gecko_evt_mesh_sensor_setup_server_set_setting_request_id     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x04480000)
#define gecko_evt_mesh_sensor_setup_server_publish_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x05480000)
#define gecko_evt_mesh_sensor_client_descriptor_status_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00490000)
#define gecko_evt_mesh_sensor_client_cadence_status_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01490000)
#define gecko_evt_mesh_sensor_client_settings_status_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02490000)
#define gecko_evt_mesh_sensor_client_setting_status_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x03490000)
#define gecko_evt_mesh_sensor_client_status_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x04490000)
#define gecko_evt_mesh_sensor_client_column_status_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x05490000)
#define gecko_evt_mesh_sensor_client_series_status_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x06490000)
#define gecko_evt_mesh_sensor_client_publish_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x07490000)
#define gecko_evt_mesh_lc_client_mode_status_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x004c0000)
#define gecko_evt_mesh_lc_client_om_status_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x014c0000)
#define gecko_evt_mesh_lc_client_light_onoff_status_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x024c0000)
#define gecko_evt_mesh_lc_client_property_status_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x034c0000)
#define gecko_evt_mesh_lc_server_mode_updated_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x004d0000)
#define gecko_evt_mesh_lc_server_om_updated_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x014d0000)
#define gecko_evt_mesh_lc_server_light_onoff_updated_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x024d0000)
#define gecko_evt_mesh_lc_server_occupancy_updated_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x034d0000)
#define gecko_evt_mesh_lc_server_ambient_lux_level_updated_id         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x044d0000)
#define gecko_evt_mesh_lc_server_linear_output_updated_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x054d0000)
#define gecko_evt_mesh_lc_server_state_updated_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x064d0000)
#define gecko_evt_mesh_lc_server_regulator_debug_info_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x074d0000)
#define gecko_evt_mesh_lc_setup_server_set_property_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x004e0000)
#define gecko_evt_mesh_scene_client_status_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x004f0000)
#define gecko_evt_mesh_scene_client_register_status_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x014f0000)
#define gecko_evt_mesh_scene_server_get_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01500000)
#define gecko_evt_mesh_scene_server_register_get_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02500000)
#define gecko_evt_mesh_scene_server_recall_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x03500000)
#define gecko_evt_mesh_scene_server_publish_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x04500000)
#define gecko_evt_mesh_scene_setup_server_store_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00510000)
#define gecko_evt_mesh_scene_setup_server_delete_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01510000)
#define gecko_evt_mesh_scene_setup_server_publish_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02510000)
#define gecko_evt_mesh_scheduler_client_status_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00540000)
#define gecko_evt_mesh_scheduler_client_action_status_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01540000)
#define gecko_evt_mesh_scheduler_server_action_changed_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01550000)
#define gecko_evt_mesh_time_server_time_updated_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00520000)
#define gecko_evt_mesh_time_server_time_zone_offset_updated_id        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01520000)
#define gecko_evt_mesh_time_server_tai_utc_delta_updated_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02520000)
#define gecko_evt_mesh_time_server_time_role_updated_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x03520000)
#define gecko_evt_mesh_time_client_time_status_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00530000)
#define gecko_evt_mesh_time_client_time_zone_status_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01530000)
#define gecko_evt_mesh_time_client_tai_utc_delta_status_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02530000)
#define gecko_evt_mesh_time_client_time_role_status_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x03530000)
#define gecko_evt_user_message_to_host_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00ff0000)


PACKSTRUCT( struct gecko_msg_dfu_reset_cmd_t
{
    uint8               dfu;
});
PACKSTRUCT( struct gecko_msg_dfu_flash_set_address_cmd_t
{
    uint32              address;
});
PACKSTRUCT( struct gecko_msg_dfu_flash_set_address_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_dfu_flash_upload_cmd_t
{
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_dfu_flash_upload_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_dfu_flash_upload_finish_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_dfu_boot_evt_t
{
    uint32              version;
});
PACKSTRUCT( struct gecko_msg_dfu_boot_failure_evt_t
{
    uint16              reason;
});
PACKSTRUCT( struct gecko_msg_system_hello_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_system_reset_cmd_t
{
    uint8               dfu;
});
PACKSTRUCT( struct gecko_msg_system_get_bt_address_rsp_t
{
    bd_addr             address;
});
PACKSTRUCT( struct gecko_msg_system_set_bt_address_cmd_t
{
    bd_addr             address;
});
PACKSTRUCT( struct gecko_msg_system_set_bt_address_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_system_set_tx_power_cmd_t
{
    int16               power;
});
PACKSTRUCT( struct gecko_msg_system_set_tx_power_rsp_t
{
    int16               set_power;
});
PACKSTRUCT( struct gecko_msg_system_get_random_data_cmd_t
{
    uint8               length;
});
PACKSTRUCT( struct gecko_msg_system_get_random_data_rsp_t
{
    uint16              result;
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_system_halt_cmd_t
{
    uint8               halt;
});
PACKSTRUCT( struct gecko_msg_system_halt_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_system_set_device_name_cmd_t
{
    uint8               type;
    uint8array          name;
});
PACKSTRUCT( struct gecko_msg_system_set_device_name_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_system_linklayer_configure_cmd_t
{
    uint8               key;
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_system_linklayer_configure_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_system_get_counters_cmd_t
{
    uint8               reset;
});
PACKSTRUCT( struct gecko_msg_system_get_counters_rsp_t
{
    uint16              result;
    uint16              tx_packets;
    uint16              rx_packets;
    uint16              crc_errors;
    uint16              failures;
});
PACKSTRUCT( struct gecko_msg_system_data_buffer_write_cmd_t
{
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_system_data_buffer_write_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_system_set_identity_address_cmd_t
{
    bd_addr             address;
    uint8               type;
});
PACKSTRUCT( struct gecko_msg_system_set_identity_address_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_system_data_buffer_clear_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_system_boot_evt_t
{
    uint16              major;
    uint16              minor;
    uint16              patch;
    uint16              build;
    uint32              bootloader;
    uint16              hw;
    uint32              hash;
});
PACKSTRUCT( struct gecko_msg_system_external_signal_evt_t
{
    uint32              extsignals;
});
PACKSTRUCT( struct gecko_msg_system_hardware_error_evt_t
{
    uint16              status;
});
PACKSTRUCT( struct gecko_msg_system_error_evt_t
{
    uint16              reason;
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_le_gap_open_cmd_t
{
    bd_addr             address;
    uint8               address_type;
});
PACKSTRUCT( struct gecko_msg_le_gap_open_rsp_t
{
    uint16              result;
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_mode_cmd_t
{
    uint8               discover;
    uint8               connect;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_mode_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_discover_cmd_t
{
    uint8               mode;
});
PACKSTRUCT( struct gecko_msg_le_gap_discover_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_end_procedure_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_adv_parameters_cmd_t
{
    uint16              interval_min;
    uint16              interval_max;
    uint8               channel_map;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_adv_parameters_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_conn_parameters_cmd_t
{
    uint16              min_interval;
    uint16              max_interval;
    uint16              latency;
    uint16              timeout;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_conn_parameters_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_scan_parameters_cmd_t
{
    uint16              scan_interval;
    uint16              scan_window;
    uint8               active;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_scan_parameters_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_adv_data_cmd_t
{
    uint8               scan_rsp;
    uint8array          adv_data;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_adv_data_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_adv_timeout_cmd_t
{
    uint8               maxevents;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_adv_timeout_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_conn_phy_cmd_t
{
    uint8               preferred_phy;
    uint8               accepted_phy;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_conn_phy_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_bt5_set_mode_cmd_t
{
    uint8               handle;
    uint8               discover;
    uint8               connect;
    uint16              maxevents;
    uint8               address_type;
});
PACKSTRUCT( struct gecko_msg_le_gap_bt5_set_mode_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_bt5_set_adv_parameters_cmd_t
{
    uint8               handle;
    uint16              interval_min;
    uint16              interval_max;
    uint8               channel_map;
    uint8               report_scan;
});
PACKSTRUCT( struct gecko_msg_le_gap_bt5_set_adv_parameters_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_bt5_set_adv_data_cmd_t
{
    uint8               handle;
    uint8               scan_rsp;
    uint8array          adv_data;
});
PACKSTRUCT( struct gecko_msg_le_gap_bt5_set_adv_data_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_privacy_mode_cmd_t
{
    uint8               privacy;
    uint8               interval;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_privacy_mode_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_advertise_timing_cmd_t
{
    uint8               handle;
    uint32              interval_min;
    uint32              interval_max;
    uint16              duration;
    uint8               maxevents;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_advertise_timing_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_advertise_channel_map_cmd_t
{
    uint8               handle;
    uint8               channel_map;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_advertise_channel_map_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_advertise_report_scan_request_cmd_t
{
    uint8               handle;
    uint8               report_scan_req;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_advertise_report_scan_request_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_advertise_phy_cmd_t
{
    uint8               handle;
    uint8               primary_phy;
    uint8               secondary_phy;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_advertise_phy_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_advertise_configuration_cmd_t
{
    uint8               handle;
    uint32              configurations;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_advertise_configuration_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_clear_advertise_configuration_cmd_t
{
    uint8               handle;
    uint32              configurations;
});
PACKSTRUCT( struct gecko_msg_le_gap_clear_advertise_configuration_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_start_advertising_cmd_t
{
    uint8               handle;
    uint8               discover;
    uint8               connect;
});
PACKSTRUCT( struct gecko_msg_le_gap_start_advertising_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_stop_advertising_cmd_t
{
    uint8               handle;
});
PACKSTRUCT( struct gecko_msg_le_gap_stop_advertising_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_discovery_timing_cmd_t
{
    uint8               phys;
    uint16              scan_interval;
    uint16              scan_window;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_discovery_timing_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_discovery_type_cmd_t
{
    uint8               phys;
    uint8               scan_type;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_discovery_type_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_start_discovery_cmd_t
{
    uint8               scanning_phy;
    uint8               mode;
});
PACKSTRUCT( struct gecko_msg_le_gap_start_discovery_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_data_channel_classification_cmd_t
{
    uint8array          channel_map;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_data_channel_classification_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_connect_cmd_t
{
    bd_addr             address;
    uint8               address_type;
    uint8               initiating_phy;
});
PACKSTRUCT( struct gecko_msg_le_gap_connect_rsp_t
{
    uint16              result;
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_advertise_tx_power_cmd_t
{
    uint8               handle;
    int16               power;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_advertise_tx_power_rsp_t
{
    uint16              result;
    int16               set_power;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_discovery_extended_scan_response_cmd_t
{
    uint8               enable;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_discovery_extended_scan_response_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_start_periodic_advertising_cmd_t
{
    uint8               handle;
    uint16              interval_min;
    uint16              interval_max;
    uint32              flags;
});
PACKSTRUCT( struct gecko_msg_le_gap_start_periodic_advertising_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_stop_periodic_advertising_cmd_t
{
    uint8               handle;
});
PACKSTRUCT( struct gecko_msg_le_gap_stop_periodic_advertising_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_long_advertising_data_cmd_t
{
    uint8               handle;
    uint8               packet_type;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_long_advertising_data_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_enable_whitelisting_cmd_t
{
    uint8               enable;
});
PACKSTRUCT( struct gecko_msg_le_gap_enable_whitelisting_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_conn_timing_parameters_cmd_t
{
    uint16              min_interval;
    uint16              max_interval;
    uint16              latency;
    uint16              timeout;
    uint16              min_ce_length;
    uint16              max_ce_length;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_conn_timing_parameters_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_advertise_random_address_cmd_t
{
    uint8               handle;
    uint8               addr_type;
    bd_addr             address;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_advertise_random_address_rsp_t
{
    uint16              result;
    bd_addr             address_out;
});
PACKSTRUCT( struct gecko_msg_le_gap_clear_advertise_random_address_cmd_t
{
    uint8               handle;
});
PACKSTRUCT( struct gecko_msg_le_gap_clear_advertise_random_address_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_scan_response_evt_t
{
    int8                rssi;
    uint8               packet_type;
    bd_addr             address;
    uint8               address_type;
    uint8               bonding;
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_le_gap_adv_timeout_evt_t
{
    uint8               handle;
});
PACKSTRUCT( struct gecko_msg_le_gap_scan_request_evt_t
{
    uint8               handle;
    bd_addr             address;
    uint8               address_type;
    uint8               bonding;
});
PACKSTRUCT( struct gecko_msg_le_gap_extended_scan_response_evt_t
{
    uint8               packet_type;
    bd_addr             address;
    uint8               address_type;
    uint8               bonding;
    uint8               primary_phy;
    uint8               secondary_phy;
    uint8               adv_sid;
    int8                tx_power;
    int8                rssi;
    uint8               channel;
    uint16              periodic_interval;
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_le_gap_periodic_advertising_status_evt_t
{
    uint8               sid;
    uint32              status;
});
PACKSTRUCT( struct gecko_msg_sync_open_cmd_t
{
    uint8               adv_sid;
    uint16              skip;
    uint16              timeout;
    bd_addr             address;
    uint8               address_type;
});
PACKSTRUCT( struct gecko_msg_sync_open_rsp_t
{
    uint16              result;
    uint8               sync;
});
PACKSTRUCT( struct gecko_msg_sync_close_cmd_t
{
    uint8               sync;
});
PACKSTRUCT( struct gecko_msg_sync_close_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sync_opened_evt_t
{
    uint8               sync;
    uint8               adv_sid;
    bd_addr             address;
    uint8               address_type;
    uint8               adv_phy;
    uint16              adv_interval;
    uint16              clock_accuracy;
});
PACKSTRUCT( struct gecko_msg_sync_closed_evt_t
{
    uint16              reason;
    uint8               sync;
});
PACKSTRUCT( struct gecko_msg_sync_data_evt_t
{
    uint8               sync;
    int8                tx_power;
    int8                rssi;
    uint8               data_status;
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_le_connection_set_parameters_cmd_t
{
    uint8               connection;
    uint16              min_interval;
    uint16              max_interval;
    uint16              latency;
    uint16              timeout;
});
PACKSTRUCT( struct gecko_msg_le_connection_set_parameters_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_connection_get_rssi_cmd_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_le_connection_get_rssi_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_connection_disable_slave_latency_cmd_t
{
    uint8               connection;
    uint8               disable;
});
PACKSTRUCT( struct gecko_msg_le_connection_disable_slave_latency_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_connection_set_phy_cmd_t
{
    uint8               connection;
    uint8               phy;
});
PACKSTRUCT( struct gecko_msg_le_connection_set_phy_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_connection_close_cmd_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_le_connection_close_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_connection_set_timing_parameters_cmd_t
{
    uint8               connection;
    uint16              min_interval;
    uint16              max_interval;
    uint16              latency;
    uint16              timeout;
    uint16              min_ce_length;
    uint16              max_ce_length;
});
PACKSTRUCT( struct gecko_msg_le_connection_set_timing_parameters_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_connection_read_channel_map_cmd_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_le_connection_read_channel_map_rsp_t
{
    uint16              result;
    uint8array          channel_map;
});
PACKSTRUCT( struct gecko_msg_le_connection_set_preferred_phy_cmd_t
{
    uint8               connection;
    uint8               preferred_phy;
    uint8               accepted_phy;
});
PACKSTRUCT( struct gecko_msg_le_connection_set_preferred_phy_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_connection_opened_evt_t
{
    bd_addr             address;
    uint8               address_type;
    uint8               master;
    uint8               connection;
    uint8               bonding;
    uint8               advertiser;
});
PACKSTRUCT( struct gecko_msg_le_connection_closed_evt_t
{
    uint16              reason;
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_le_connection_parameters_evt_t
{
    uint8               connection;
    uint16              interval;
    uint16              latency;
    uint16              timeout;
    uint8               security_mode;
    uint16              txsize;
});
PACKSTRUCT( struct gecko_msg_le_connection_rssi_evt_t
{
    uint8               connection;
    uint8               status;
    int8                rssi;
});
PACKSTRUCT( struct gecko_msg_le_connection_phy_status_evt_t
{
    uint8               connection;
    uint8               phy;
});
PACKSTRUCT( struct gecko_msg_gatt_set_max_mtu_cmd_t
{
    uint16              max_mtu;
});
PACKSTRUCT( struct gecko_msg_gatt_set_max_mtu_rsp_t
{
    uint16              result;
    uint16              max_mtu;
});
PACKSTRUCT( struct gecko_msg_gatt_discover_primary_services_cmd_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_gatt_discover_primary_services_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_discover_primary_services_by_uuid_cmd_t
{
    uint8               connection;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_gatt_discover_primary_services_by_uuid_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_discover_characteristics_cmd_t
{
    uint8               connection;
    uint32              service;
});
PACKSTRUCT( struct gecko_msg_gatt_discover_characteristics_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_discover_characteristics_by_uuid_cmd_t
{
    uint8               connection;
    uint32              service;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_gatt_discover_characteristics_by_uuid_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_set_characteristic_notification_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               flags;
});
PACKSTRUCT( struct gecko_msg_gatt_set_characteristic_notification_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_discover_descriptors_cmd_t
{
    uint8               connection;
    uint16              characteristic;
});
PACKSTRUCT( struct gecko_msg_gatt_discover_descriptors_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_read_characteristic_value_cmd_t
{
    uint8               connection;
    uint16              characteristic;
});
PACKSTRUCT( struct gecko_msg_gatt_read_characteristic_value_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_read_characteristic_value_by_uuid_cmd_t
{
    uint8               connection;
    uint32              service;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_gatt_read_characteristic_value_by_uuid_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_write_characteristic_value_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_write_characteristic_value_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_write_characteristic_value_without_response_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_write_characteristic_value_without_response_rsp_t
{
    uint16              result;
    uint16              sent_len;
});
PACKSTRUCT( struct gecko_msg_gatt_prepare_characteristic_value_write_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint16              offset;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_prepare_characteristic_value_write_rsp_t
{
    uint16              result;
    uint16              sent_len;
});
PACKSTRUCT( struct gecko_msg_gatt_execute_characteristic_value_write_cmd_t
{
    uint8               connection;
    uint8               flags;
});
PACKSTRUCT( struct gecko_msg_gatt_execute_characteristic_value_write_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_send_characteristic_confirmation_cmd_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_gatt_send_characteristic_confirmation_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_read_descriptor_value_cmd_t
{
    uint8               connection;
    uint16              descriptor;
});
PACKSTRUCT( struct gecko_msg_gatt_read_descriptor_value_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_write_descriptor_value_cmd_t
{
    uint8               connection;
    uint16              descriptor;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_write_descriptor_value_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_find_included_services_cmd_t
{
    uint8               connection;
    uint32              service;
});
PACKSTRUCT( struct gecko_msg_gatt_find_included_services_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_read_multiple_characteristic_values_cmd_t
{
    uint8               connection;
    uint8array          characteristic_list;
});
PACKSTRUCT( struct gecko_msg_gatt_read_multiple_characteristic_values_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_read_characteristic_value_from_offset_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint16              offset;
    uint16              maxlen;
});
PACKSTRUCT( struct gecko_msg_gatt_read_characteristic_value_from_offset_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_prepare_characteristic_value_reliable_write_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint16              offset;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_prepare_characteristic_value_reliable_write_rsp_t
{
    uint16              result;
    uint16              sent_len;
});
PACKSTRUCT( struct gecko_msg_gatt_mtu_exchanged_evt_t
{
    uint8               connection;
    uint16              mtu;
});
PACKSTRUCT( struct gecko_msg_gatt_service_evt_t
{
    uint8               connection;
    uint32              service;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_gatt_characteristic_evt_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               properties;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_gatt_descriptor_evt_t
{
    uint8               connection;
    uint16              descriptor;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_gatt_characteristic_value_evt_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               att_opcode;
    uint16              offset;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_descriptor_value_evt_t
{
    uint8               connection;
    uint16              descriptor;
    uint16              offset;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_procedure_completed_evt_t
{
    uint8               connection;
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_server_read_attribute_value_cmd_t
{
    uint16              attribute;
    uint16              offset;
});
PACKSTRUCT( struct gecko_msg_gatt_server_read_attribute_value_rsp_t
{
    uint16              result;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_server_read_attribute_type_cmd_t
{
    uint16              attribute;
});
PACKSTRUCT( struct gecko_msg_gatt_server_read_attribute_type_rsp_t
{
    uint16              result;
    uint8array          type;
});
PACKSTRUCT( struct gecko_msg_gatt_server_write_attribute_value_cmd_t
{
    uint16              attribute;
    uint16              offset;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_server_write_attribute_value_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_server_send_user_read_response_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               att_errorcode;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_server_send_user_read_response_rsp_t
{
    uint16              result;
    uint16              sent_len;
});
PACKSTRUCT( struct gecko_msg_gatt_server_send_user_write_response_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               att_errorcode;
});
PACKSTRUCT( struct gecko_msg_gatt_server_send_user_write_response_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_server_send_characteristic_notification_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_server_send_characteristic_notification_rsp_t
{
    uint16              result;
    uint16              sent_len;
});
PACKSTRUCT( struct gecko_msg_gatt_server_find_attribute_cmd_t
{
    uint16              start;
    uint8array          type;
});
PACKSTRUCT( struct gecko_msg_gatt_server_find_attribute_rsp_t
{
    uint16              result;
    uint16              attribute;
});
PACKSTRUCT( struct gecko_msg_gatt_server_set_capabilities_cmd_t
{
    uint32              caps;
    uint32              reserved;
});
PACKSTRUCT( struct gecko_msg_gatt_server_set_capabilities_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_server_set_max_mtu_cmd_t
{
    uint16              max_mtu;
});
PACKSTRUCT( struct gecko_msg_gatt_server_set_max_mtu_rsp_t
{
    uint16              result;
    uint16              max_mtu;
});
PACKSTRUCT( struct gecko_msg_gatt_server_get_mtu_cmd_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_gatt_server_get_mtu_rsp_t
{
    uint16              result;
    uint16              mtu;
});
PACKSTRUCT( struct gecko_msg_gatt_server_enable_capabilities_cmd_t
{
    uint32              caps;
});
PACKSTRUCT( struct gecko_msg_gatt_server_enable_capabilities_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_server_disable_capabilities_cmd_t
{
    uint32              caps;
});
PACKSTRUCT( struct gecko_msg_gatt_server_disable_capabilities_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_server_get_enabled_capabilities_rsp_t
{
    uint16              result;
    uint32              caps;
});
PACKSTRUCT( struct gecko_msg_gatt_server_attribute_value_evt_t
{
    uint8               connection;
    uint16              attribute;
    uint8               att_opcode;
    uint16              offset;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_server_user_read_request_evt_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               att_opcode;
    uint16              offset;
});
PACKSTRUCT( struct gecko_msg_gatt_server_user_write_request_evt_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               att_opcode;
    uint16              offset;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_server_characteristic_status_evt_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               status_flags;
    uint16              client_config_flags;
});
PACKSTRUCT( struct gecko_msg_gatt_server_execute_write_completed_evt_t
{
    uint8               connection;
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_hardware_set_soft_timer_cmd_t
{
    uint32              time;
    uint8               handle;
    uint8               single_shot;
});
PACKSTRUCT( struct gecko_msg_hardware_set_soft_timer_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_hardware_get_time_rsp_t
{
    uint32              seconds;
    uint16              ticks;
});
PACKSTRUCT( struct gecko_msg_hardware_set_lazy_soft_timer_cmd_t
{
    uint32              time;
    uint32              slack;
    uint8               handle;
    uint8               single_shot;
});
PACKSTRUCT( struct gecko_msg_hardware_set_lazy_soft_timer_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_hardware_soft_timer_evt_t
{
    uint8               handle;
});
PACKSTRUCT( struct gecko_msg_flash_ps_erase_all_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_flash_ps_save_cmd_t
{
    uint16              key;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_flash_ps_save_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_flash_ps_load_cmd_t
{
    uint16              key;
});
PACKSTRUCT( struct gecko_msg_flash_ps_load_rsp_t
{
    uint16              result;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_flash_ps_erase_cmd_t
{
    uint16              key;
});
PACKSTRUCT( struct gecko_msg_flash_ps_erase_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_test_dtm_tx_cmd_t
{
    uint8               packet_type;
    uint8               length;
    uint8               channel;
    uint8               phy;
});
PACKSTRUCT( struct gecko_msg_test_dtm_tx_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_test_dtm_rx_cmd_t
{
    uint8               channel;
    uint8               phy;
});
PACKSTRUCT( struct gecko_msg_test_dtm_rx_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_test_dtm_end_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_test_dtm_completed_evt_t
{
    uint16              result;
    uint16              number_of_packets;
});
PACKSTRUCT( struct gecko_msg_sm_set_bondable_mode_cmd_t
{
    uint8               bondable;
});
PACKSTRUCT( struct gecko_msg_sm_set_bondable_mode_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_configure_cmd_t
{
    uint8               flags;
    uint8               io_capabilities;
});
PACKSTRUCT( struct gecko_msg_sm_configure_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_store_bonding_configuration_cmd_t
{
    uint8               max_bonding_count;
    uint8               policy_flags;
});
PACKSTRUCT( struct gecko_msg_sm_store_bonding_configuration_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_increase_security_cmd_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_sm_increase_security_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_delete_bonding_cmd_t
{
    uint8               bonding;
});
PACKSTRUCT( struct gecko_msg_sm_delete_bonding_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_delete_bondings_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_enter_passkey_cmd_t
{
    uint8               connection;
    int32               passkey;
});
PACKSTRUCT( struct gecko_msg_sm_enter_passkey_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_passkey_confirm_cmd_t
{
    uint8               connection;
    uint8               confirm;
});
PACKSTRUCT( struct gecko_msg_sm_passkey_confirm_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_set_oob_data_cmd_t
{
    uint8array          oob_data;
});
PACKSTRUCT( struct gecko_msg_sm_set_oob_data_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_list_all_bondings_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_bonding_confirm_cmd_t
{
    uint8               connection;
    uint8               confirm;
});
PACKSTRUCT( struct gecko_msg_sm_bonding_confirm_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_set_debug_mode_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_set_passkey_cmd_t
{
    int32               passkey;
});
PACKSTRUCT( struct gecko_msg_sm_set_passkey_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_use_sc_oob_cmd_t
{
    uint8               enable;
});
PACKSTRUCT( struct gecko_msg_sm_use_sc_oob_rsp_t
{
    uint16              result;
    uint8array          oob_data;
});
PACKSTRUCT( struct gecko_msg_sm_set_sc_remote_oob_data_cmd_t
{
    uint8array          oob_data;
});
PACKSTRUCT( struct gecko_msg_sm_set_sc_remote_oob_data_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_add_to_whitelist_cmd_t
{
    bd_addr             address;
    uint8               address_type;
});
PACKSTRUCT( struct gecko_msg_sm_add_to_whitelist_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_set_minimum_key_size_cmd_t
{
    uint8               minimum_key_size;
});
PACKSTRUCT( struct gecko_msg_sm_set_minimum_key_size_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_passkey_display_evt_t
{
    uint8               connection;
    uint32              passkey;
});
PACKSTRUCT( struct gecko_msg_sm_passkey_request_evt_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_sm_confirm_passkey_evt_t
{
    uint8               connection;
    uint32              passkey;
});
PACKSTRUCT( struct gecko_msg_sm_bonded_evt_t
{
    uint8               connection;
    uint8               bonding;
});
PACKSTRUCT( struct gecko_msg_sm_bonding_failed_evt_t
{
    uint8               connection;
    uint16              reason;
});
PACKSTRUCT( struct gecko_msg_sm_list_bonding_entry_evt_t
{
    uint8               bonding;
    bd_addr             address;
    uint8               address_type;
});
PACKSTRUCT( struct gecko_msg_sm_confirm_bonding_evt_t
{
    uint8               connection;
    int8                bonding_handle;
});
PACKSTRUCT( struct gecko_msg_homekit_configure_cmd_t
{
    uint8               i2c_address;
    uint8               support_display;
    uint8               hap_attribute_features;
    uint16              category;
    uint8               configuration_number;
    uint16              fast_advert_interval;
    uint16              fast_advert_timeout;
    uint32              flag;
    uint16              broadcast_advert_timeout;
    uint8array          model_name;
});
PACKSTRUCT( struct gecko_msg_homekit_configure_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_homekit_advertise_cmd_t
{
    uint8               enable;
    uint16              interval_min;
    uint16              interval_max;
    uint8               channel_map;
});
PACKSTRUCT( struct gecko_msg_homekit_advertise_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_homekit_delete_pairings_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_homekit_check_authcp_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_homekit_get_pairing_id_cmd_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_homekit_get_pairing_id_rsp_t
{
    uint16              result;
    uint8array          pairing_id;
});
PACKSTRUCT( struct gecko_msg_homekit_send_write_response_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               status_code;
});
PACKSTRUCT( struct gecko_msg_homekit_send_write_response_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_homekit_send_read_response_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               status_code;
    uint16              attribute_size;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_homekit_send_read_response_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_homekit_gsn_action_cmd_t
{
    uint8               action;
});
PACKSTRUCT( struct gecko_msg_homekit_gsn_action_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_homekit_event_notification_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               change_originator;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_homekit_event_notification_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_homekit_broadcast_action_cmd_t
{
    uint8               action;
    uint8array          params;
});
PACKSTRUCT( struct gecko_msg_homekit_broadcast_action_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_homekit_configure_product_data_cmd_t
{
    uint8array          product_data;
});
PACKSTRUCT( struct gecko_msg_homekit_configure_product_data_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_homekit_setupcode_display_evt_t
{
    uint8               connection;
    uint8array          setupcode;
});
PACKSTRUCT( struct gecko_msg_homekit_paired_evt_t
{
    uint8               connection;
    uint16              reason;
});
PACKSTRUCT( struct gecko_msg_homekit_pair_verified_evt_t
{
    uint8               connection;
    uint16              reason;
});
PACKSTRUCT( struct gecko_msg_homekit_connection_opened_evt_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_homekit_connection_closed_evt_t
{
    uint8               connection;
    uint16              reason;
});
PACKSTRUCT( struct gecko_msg_homekit_identify_evt_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_homekit_write_request_evt_t
{
    uint8               connection;
    uint16              characteristic;
    uint16              chr_value_size;
    uint16              authorization_size;
    uint16              value_offset;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_homekit_read_request_evt_t
{
    uint8               connection;
    uint16              characteristic;
    uint16              offset;
});
PACKSTRUCT( struct gecko_msg_homekit_disconnection_required_evt_t
{
    uint8               connection;
    uint16              reason;
});
PACKSTRUCT( struct gecko_msg_homekit_pairing_removed_evt_t
{
    uint8               connection;
    uint16              remaining_pairings;
    uint8array          pairing_id;
});
PACKSTRUCT( struct gecko_msg_homekit_setuppayload_display_evt_t
{
    uint8               connection;
    uint8array          setuppayload;
});
PACKSTRUCT( struct gecko_msg_mesh_node_init_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_node_start_unprov_beaconing_cmd_t
{
    uint8               bearer;
});
PACKSTRUCT( struct gecko_msg_mesh_node_start_unprov_beaconing_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_node_stop_unprov_beaconing_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_node_rssi_rsp_t
{
    uint16              result;
    int8                rssi;
});
PACKSTRUCT( struct gecko_msg_mesh_node_input_oob_request_rsp_cmd_t
{
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_mesh_node_input_oob_request_rsp_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_node_get_uuid_rsp_t
{
    uint16              result;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_mesh_node_set_provisioning_data_cmd_t
{
    aes_key_128         device_key;
    aes_key_128         network_key;
    uint16              netkey_index;
    uint32              iv_index;
    uint16              address;
    uint8               kr_in_progress;
});
PACKSTRUCT( struct gecko_msg_mesh_node_set_provisioning_data_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_node_init_oob_cmd_t
{
    uint8               public_key;
    uint8               auth_methods;
    uint16              output_actions;
    uint8               output_size;
    uint16              input_actions;
    uint8               input_size;
    uint16              oob_location;
});
PACKSTRUCT( struct gecko_msg_mesh_node_init_oob_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_node_set_ivrecovery_mode_cmd_t
{
    uint8               mode;
});
PACKSTRUCT( struct gecko_msg_mesh_node_set_ivrecovery_mode_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_node_get_ivrecovery_mode_rsp_t
{
    uint16              result;
    uint8               mode;
});
PACKSTRUCT( struct gecko_msg_mesh_node_set_adv_event_filter_cmd_t
{
    uint16              mask;
    uint8array          gap_data_type;
});
PACKSTRUCT( struct gecko_msg_mesh_node_set_adv_event_filter_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_node_get_statistics_rsp_t
{
    uint16              result;
    uint8array          statistics;
});
PACKSTRUCT( struct gecko_msg_mesh_node_clear_statistics_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_node_set_net_relay_delay_cmd_t
{
    uint8               min;
    uint8               max;
});
PACKSTRUCT( struct gecko_msg_mesh_node_set_net_relay_delay_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_node_get_net_relay_delay_rsp_t
{
    uint16              result;
    uint8               min;
    uint8               max;
});
PACKSTRUCT( struct gecko_msg_mesh_node_get_ivupdate_state_rsp_t
{
    uint16              result;
    uint32              ivindex;
    uint8               state;
});
PACKSTRUCT( struct gecko_msg_mesh_node_request_ivupdate_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_node_get_seq_remaining_cmd_t
{
    uint16              elem_index;
});
PACKSTRUCT( struct gecko_msg_mesh_node_get_seq_remaining_rsp_t
{
    uint16              result;
    uint32              count;
});
PACKSTRUCT( struct gecko_msg_mesh_node_save_replay_protection_list_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_node_set_uuid_cmd_t
{
    uuid_128            uuid;
});
PACKSTRUCT( struct gecko_msg_mesh_node_set_uuid_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_node_get_element_address_cmd_t
{
    uint16              elem_index;
});
PACKSTRUCT( struct gecko_msg_mesh_node_get_element_address_rsp_t
{
    uint16              result;
    uint16              address;
});
PACKSTRUCT( struct gecko_msg_mesh_node_static_oob_request_rsp_cmd_t
{
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_mesh_node_static_oob_request_rsp_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_node_reset_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_node_set_beacon_reporting_cmd_t
{
    uint8               report;
});
PACKSTRUCT( struct gecko_msg_mesh_node_set_beacon_reporting_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_node_set_iv_update_age_cmd_t
{
    uint32              age_s;
});
PACKSTRUCT( struct gecko_msg_mesh_node_set_iv_update_age_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_node_initialized_evt_t
{
    uint8               provisioned;
    uint16              address;
    uint32              ivi;
});
PACKSTRUCT( struct gecko_msg_mesh_node_provisioned_evt_t
{
    uint32              iv_index;
    uint16              address;
});
PACKSTRUCT( struct gecko_msg_mesh_node_config_get_evt_t
{
    uint16              id;
    uint16              netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_node_config_set_evt_t
{
    uint16              id;
    uint16              netkey_index;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_mesh_node_display_output_oob_evt_t
{
    uint8               output_action;
    uint8               output_size;
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_mesh_node_input_oob_request_evt_t
{
    uint8               input_action;
    uint8               input_size;
});
PACKSTRUCT( struct gecko_msg_mesh_node_provisioning_started_evt_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_node_provisioning_failed_evt_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_node_key_added_evt_t
{
    uint8               type;
    uint16              index;
    uint16              netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_node_model_config_changed_evt_t
{
    uint8               mesh_node_config_state;
    uint16              element_address;
    uint16              vendor_id;
    uint16              model_id;
});
PACKSTRUCT( struct gecko_msg_mesh_node_ivrecovery_needed_evt_t
{
    uint32              node_ivindex;
    uint32              network_ivindex;
});
PACKSTRUCT( struct gecko_msg_mesh_node_changed_ivupdate_state_evt_t
{
    uint32              ivindex;
    uint8               state;
});
PACKSTRUCT( struct gecko_msg_mesh_node_key_removed_evt_t
{
    uint8               type;
    uint16              index;
    uint16              netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_node_key_updated_evt_t
{
    uint8               type;
    uint16              index;
    uint16              netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_node_heartbeat_evt_t
{
    uint16              src_addr;
    uint16              dst_addr;
    uint8               hops;
});
PACKSTRUCT( struct gecko_msg_mesh_node_heartbeat_start_evt_t
{
    uint16              src_addr;
    uint16              dst_addr;
    uint32              period;
});
PACKSTRUCT( struct gecko_msg_mesh_node_heartbeat_stop_evt_t
{
    uint16              src_addr;
    uint16              dst_addr;
});
PACKSTRUCT( struct gecko_msg_mesh_node_beacon_received_evt_t
{
    uint16              netkey_index;
    uint8               key_refresh;
    uint8               iv_update;
    uint32              ivindex;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_init_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_scan_unprov_beacons_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_provision_device_cmd_t
{
    uint8               network_id;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_provision_device_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_create_network_cmd_t
{
    uint8array          key;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_create_network_rsp_t
{
    uint16              result;
    uint8               network_id;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_get_dcd_cmd_t
{
    uint16              address;
    uint8               page;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_get_dcd_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_get_config_cmd_t
{
    uint16              address;
    uint16              id;
    uint16              netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_get_config_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_set_config_cmd_t
{
    uint16              address;
    uint16              id;
    uint16              netkey_index;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_set_config_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_create_appkey_cmd_t
{
    uint16              netkey_index;
    uint8array          key;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_create_appkey_rsp_t
{
    uint16              result;
    uint16              appkey_index;
    uint8array          key;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_oob_pkey_rsp_cmd_t
{
    uint8array          pkey;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_oob_pkey_rsp_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_oob_auth_rsp_cmd_t
{
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_oob_auth_rsp_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_set_oob_requirements_cmd_t
{
    uint8               public_key;
    uint8               auth_methods;
    uint16              output_actions;
    uint16              input_actions;
    uint8               min_size;
    uint8               max_size;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_set_oob_requirements_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_key_refresh_start_cmd_t
{
    uint16              netkey_index;
    uint8               num_appkeys;
    uint8array          appkey_indices;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_key_refresh_start_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_get_key_refresh_blacklist_cmd_t
{
    uint16              key;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_get_key_refresh_blacklist_rsp_t
{
    uint16              result;
    uint8               status;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_set_key_refresh_blacklist_cmd_t
{
    uint16              key;
    uint8               status;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_set_key_refresh_blacklist_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_appkey_add_cmd_t
{
    uint16              address;
    uint16              netkey_index;
    uint16              appkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_appkey_add_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_appkey_delete_cmd_t
{
    uint16              address;
    uint16              netkey_index;
    uint16              appkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_appkey_delete_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_app_bind_cmd_t
{
    uint16              address;
    uint16              elem_address;
    uint16              netkey_index;
    uint16              appkey_index;
    uint16              vendor_id;
    uint16              model_id;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_app_bind_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_app_unbind_cmd_t
{
    uint16              address;
    uint16              elem_address;
    uint16              netkey_index;
    uint16              appkey_index;
    uint16              vendor_id;
    uint16              model_id;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_app_unbind_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_app_get_cmd_t
{
    uint16              address;
    uint16              elem_address;
    uint16              netkey_index;
    uint16              vendor_id;
    uint16              model_id;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_app_get_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_sub_add_cmd_t
{
    uint16              address;
    uint16              elem_address;
    uint16              netkey_index;
    uint16              vendor_id;
    uint16              model_id;
    uint16              sub_address;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_sub_add_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_pub_set_cmd_t
{
    uint16              address;
    uint16              elem_address;
    uint16              netkey_index;
    uint16              appkey_index;
    uint16              vendor_id;
    uint16              model_id;
    uint16              pub_address;
    uint8               ttl;
    uint8               period;
    uint8               retrans;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_pub_set_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_provision_gatt_device_cmd_t
{
    uint8               network_id;
    uint8               connection;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_provision_gatt_device_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_ddb_get_cmd_t
{
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_ddb_get_rsp_t
{
    uint16              result;
    aes_key_128         device_key;
    uint16              netkey_index;
    uint16              address;
    uint8               elements;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_ddb_delete_cmd_t
{
    uuid_128            uuid;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_ddb_delete_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_ddb_add_cmd_t
{
    uuid_128            uuid;
    aes_key_128         device_key;
    uint16              netkey_index;
    uint16              address;
    uint8               elements;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_ddb_add_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_ddb_list_devices_rsp_t
{
    uint16              result;
    uint16              count;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_network_add_cmd_t
{
    uint16              address;
    uint16              netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_network_add_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_network_delete_cmd_t
{
    uint16              address;
    uint16              netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_network_delete_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_nettx_get_cmd_t
{
    uint16              address;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_nettx_get_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_nettx_set_cmd_t
{
    uint16              address;
    uint8               count;
    uint8               interval;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_nettx_set_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_sub_del_cmd_t
{
    uint16              address;
    uint16              elem_address;
    uint16              netkey_index;
    uint16              vendor_id;
    uint16              model_id;
    uint16              sub_address;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_sub_del_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_sub_add_va_cmd_t
{
    uint16              address;
    uint16              elem_address;
    uint16              netkey_index;
    uint16              vendor_id;
    uint16              model_id;
    uint8array          sub_address;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_sub_add_va_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_sub_del_va_cmd_t
{
    uint16              address;
    uint16              elem_address;
    uint16              netkey_index;
    uint16              vendor_id;
    uint16              model_id;
    uint8array          sub_address;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_sub_del_va_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_sub_set_cmd_t
{
    uint16              address;
    uint16              elem_address;
    uint16              netkey_index;
    uint16              vendor_id;
    uint16              model_id;
    uint16              sub_address;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_sub_set_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_sub_set_va_cmd_t
{
    uint16              address;
    uint16              elem_address;
    uint16              netkey_index;
    uint16              vendor_id;
    uint16              model_id;
    uint8array          sub_address;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_sub_set_va_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_heartbeat_publication_get_cmd_t
{
    uint16              address;
    uint16              netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_heartbeat_publication_get_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_heartbeat_publication_set_cmd_t
{
    uint16              address;
    uint16              netkey_index;
    uint16              publication_address;
    uint8               count_log;
    uint8               period_log;
    uint8               ttl;
    uint16              features;
    uint16              publication_netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_heartbeat_publication_set_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_heartbeat_subscription_get_cmd_t
{
    uint16              address;
    uint16              netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_heartbeat_subscription_get_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_heartbeat_subscription_set_cmd_t
{
    uint16              address;
    uint16              netkey_index;
    uint16              subscription_source;
    uint16              subscription_destination;
    uint8               period_log;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_heartbeat_subscription_set_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_relay_get_cmd_t
{
    uint16              address;
    uint16              netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_relay_get_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_relay_set_cmd_t
{
    uint16              address;
    uint16              netkey_index;
    uint8               relay;
    uint8               count;
    uint8               interval;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_relay_set_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_reset_node_cmd_t
{
    uint16              address;
    uint16              netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_reset_node_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_appkey_get_cmd_t
{
    uint16              address;
    uint16              netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_appkey_get_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_network_get_cmd_t
{
    uint16              address;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_network_get_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_sub_clear_cmd_t
{
    uint16              address;
    uint16              elem_address;
    uint16              netkey_index;
    uint16              vendor_id;
    uint16              model_id;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_sub_clear_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_pub_get_cmd_t
{
    uint16              address;
    uint16              elem_address;
    uint16              vendor_id;
    uint16              model_id;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_pub_get_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_pub_set_va_cmd_t
{
    uint16              address;
    uint16              elem_address;
    uint16              netkey_index;
    uint16              appkey_index;
    uint16              vendor_id;
    uint16              model_id;
    uint8               ttl;
    uint8               period;
    uint8               retrans;
    uint8array          pub_address;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_pub_set_va_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_pub_set_cred_cmd_t
{
    uint16              address;
    uint16              elem_address;
    uint16              netkey_index;
    uint16              appkey_index;
    uint16              vendor_id;
    uint16              model_id;
    uint16              pub_address;
    uint8               ttl;
    uint8               period;
    uint8               retrans;
    uint8               credentials;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_pub_set_cred_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_pub_set_va_cred_cmd_t
{
    uint16              address;
    uint16              elem_address;
    uint16              netkey_index;
    uint16              appkey_index;
    uint16              vendor_id;
    uint16              model_id;
    uint8               ttl;
    uint8               period;
    uint8               retrans;
    uint8               credentials;
    uint8array          pub_address;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_pub_set_va_cred_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_sub_get_cmd_t
{
    uint16              address;
    uint16              elem_address;
    uint16              netkey_index;
    uint16              vendor_id;
    uint16              model_id;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_sub_get_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_friend_timeout_get_cmd_t
{
    uint16              address;
    uint16              netkey_index;
    uint16              lpn_address;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_friend_timeout_get_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_get_default_configuration_timeout_rsp_t
{
    uint16              result;
    uint32              timeout;
    uint32              lpn_timeout;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_set_default_configuration_timeout_cmd_t
{
    uint32              timeout;
    uint32              lpn_timeout;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_set_default_configuration_timeout_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_provision_device_with_address_cmd_t
{
    uint8               network_id;
    uint16              address;
    uint8               elements;
    uint8               attention_timer;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_provision_device_with_address_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_provision_gatt_device_with_address_cmd_t
{
    uint8               network_id;
    uint8               connection;
    uint16              address;
    uint8               elements;
    uint8               attention_timer;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_provision_gatt_device_with_address_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_initialize_network_cmd_t
{
    uint16              address;
    uint32              ivi;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_initialize_network_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_get_key_refresh_appkey_blacklist_cmd_t
{
    uint16              netkey_index;
    uint16              appkey_index;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_get_key_refresh_appkey_blacklist_rsp_t
{
    uint16              result;
    uint8               status;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_set_key_refresh_appkey_blacklist_cmd_t
{
    uint16              netkey_index;
    uint16              appkey_index;
    uint8               status;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_set_key_refresh_appkey_blacklist_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_stop_scan_unprov_beacons_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_ddb_update_netkey_index_cmd_t
{
    uuid_128            uuid;
    uint16              netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_ddb_update_netkey_index_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_key_refresh_suspend_cmd_t
{
    uint16              netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_key_refresh_suspend_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_key_refresh_resume_cmd_t
{
    uint16              netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_key_refresh_resume_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_get_key_refresh_phase_cmd_t
{
    uint16              netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_get_key_refresh_phase_rsp_t
{
    uint16              result;
    uint8               phase;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_key_refresh_start_from_phase_cmd_t
{
    uint8               phase;
    uint16              netkey_index;
    uint8               num_appkeys;
    uint8array          appkey_indices;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_key_refresh_start_from_phase_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_flush_key_refresh_state_cmd_t
{
    uint16              netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_flush_key_refresh_state_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_initialized_evt_t
{
    uint8               networks;
    uint16              address;
    uint32              ivi;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_provisioning_failed_evt_t
{
    uint8               reason;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_device_provisioned_evt_t
{
    uint16              address;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_unprov_beacon_evt_t
{
    uint16              oob_capabilities;
    uint32              uri_hash;
    uint8               bearer;
    bd_addr             address;
    uint8               address_type;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_dcd_status_evt_t
{
    uint16              result;
    uint16              address;
    uint16              cid;
    uint16              pid;
    uint16              vid;
    uint16              crpl;
    uint16              features;
    uint8               elements;
    uint8               models;
    uint8array          element_data;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_config_status_evt_t
{
    uint16              address;
    uint16              id;
    uint8               status;
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_oob_pkey_request_evt_t
{
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_oob_auth_request_evt_t
{
    uint8               output;
    uint8               output_action;
    uint8               output_size;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_oob_display_input_evt_t
{
    uint8               input_action;
    uint8               input_size;
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_ddb_list_evt_t
{
    uuid_128            uuid;
    uint16              address;
    uint8               elements;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_heartbeat_publication_status_evt_t
{
    uint16              address;
    uint16              netkey_index;
    uint16              publication_address;
    uint8               count_log;
    uint8               period_log;
    uint8               ttl;
    uint16              features;
    uint16              publication_netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_heartbeat_subscription_status_evt_t
{
    uint16              address;
    uint16              netkey_index;
    uint16              subscription_source;
    uint16              subscription_destination;
    uint8               period_log;
    uint8               count_log;
    uint8               min_hops;
    uint8               max_hops;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_relay_status_evt_t
{
    uint16              address;
    uint16              netkey_index;
    uint8               value;
    uint8               count;
    uint8               interval;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_uri_evt_t
{
    uint32              hash;
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_node_reset_evt_t
{
    uint16              address;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_appkey_list_evt_t
{
    uint16              address;
    uint16              netkey_index;
    uint16              appkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_appkey_list_end_evt_t
{
    uint16              result;
    uint16              address;
    uint16              netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_network_list_evt_t
{
    uint16              address;
    uint16              netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_network_list_end_evt_t
{
    uint16              result;
    uint16              address;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_pub_status_evt_t
{
    uint16              result;
    uint16              elem_address;
    uint16              vendor_id;
    uint16              model_id;
    uint16              appkey_index;
    uint16              pub_address;
    uint8               ttl;
    uint8               period;
    uint8               retrans;
    uint8               credentials;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_key_refresh_phase_update_evt_t
{
    uint16              key;
    uint8               phase;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_key_refresh_node_update_evt_t
{
    uint16              key;
    uint8               phase;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_key_refresh_complete_evt_t
{
    uint16              key;
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_sub_addr_evt_t
{
    uint16              elem_address;
    uint16              vendor_id;
    uint16              model_id;
    uint16              sub_addr;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_model_sub_addr_end_evt_t
{
    uint16              result;
    uint16              elem_address;
    uint16              vendor_id;
    uint16              model_id;
});
PACKSTRUCT( struct gecko_msg_mesh_prov_friend_timeout_status_evt_t
{
    uint16              address;
    uint16              netkey_index;
    uint32              timeout;
});
PACKSTRUCT( struct gecko_msg_mesh_proxy_connect_cmd_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_mesh_proxy_connect_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_proxy_disconnect_cmd_t
{
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_proxy_disconnect_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_proxy_set_filter_type_cmd_t
{
    uint32              handle;
    uint8               type;
    uint16              key;
});
PACKSTRUCT( struct gecko_msg_mesh_proxy_set_filter_type_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_proxy_allow_cmd_t
{
    uint32              handle;
    uint16              address;
    uint16              key;
});
PACKSTRUCT( struct gecko_msg_mesh_proxy_allow_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_proxy_deny_cmd_t
{
    uint32              handle;
    uint16              address;
    uint16              key;
});
PACKSTRUCT( struct gecko_msg_mesh_proxy_deny_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_proxy_connected_evt_t
{
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_proxy_disconnected_evt_t
{
    uint32              handle;
    uint16              reason;
});
PACKSTRUCT( struct gecko_msg_mesh_proxy_filter_status_evt_t
{
    uint32              handle;
    uint8               type;
    uint16              count;
});
PACKSTRUCT( struct gecko_msg_mesh_vendor_model_send_cmd_t
{
    uint16              elem_index;
    uint16              vendor_id;
    uint16              model_id;
    uint16              destination_address;
    int8                va_index;
    uint16              appkey_index;
    uint8               nonrelayed;
    uint8               opcode;
    uint8               final;
    uint8array          payload;
});
PACKSTRUCT( struct gecko_msg_mesh_vendor_model_send_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_vendor_model_set_publication_cmd_t
{
    uint16              elem_index;
    uint16              vendor_id;
    uint16              model_id;
    uint8               opcode;
    uint8               final;
    uint8array          payload;
});
PACKSTRUCT( struct gecko_msg_mesh_vendor_model_set_publication_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_vendor_model_clear_publication_cmd_t
{
    uint16              elem_index;
    uint16              vendor_id;
    uint16              model_id;
});
PACKSTRUCT( struct gecko_msg_mesh_vendor_model_clear_publication_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_vendor_model_publish_cmd_t
{
    uint16              elem_index;
    uint16              vendor_id;
    uint16              model_id;
});
PACKSTRUCT( struct gecko_msg_mesh_vendor_model_publish_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_vendor_model_init_cmd_t
{
    uint16              elem_index;
    uint16              vendor_id;
    uint16              model_id;
    uint8               publish;
    uint8array          opcodes;
});
PACKSTRUCT( struct gecko_msg_mesh_vendor_model_init_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_vendor_model_deinit_cmd_t
{
    uint16              elem_index;
    uint16              vendor_id;
    uint16              model_id;
});
PACKSTRUCT( struct gecko_msg_mesh_vendor_model_deinit_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_vendor_model_receive_evt_t
{
    uint16              elem_index;
    uint16              vendor_id;
    uint16              model_id;
    uint16              source_address;
    uint16              destination_address;
    int8                va_index;
    uint16              appkey_index;
    uint8               nonrelayed;
    uint8               opcode;
    uint8               final;
    uint8array          payload;
});
PACKSTRUCT( struct gecko_msg_mesh_health_client_get_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    uint16              vendor_id;
});
PACKSTRUCT( struct gecko_msg_mesh_health_client_get_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_health_client_clear_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    uint16              vendor_id;
    uint8               reliable;
});
PACKSTRUCT( struct gecko_msg_mesh_health_client_clear_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_health_client_test_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    uint8               test_id;
    uint16              vendor_id;
    uint8               reliable;
});
PACKSTRUCT( struct gecko_msg_mesh_health_client_test_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_health_client_get_period_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_health_client_get_period_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_health_client_set_period_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    uint8               period;
    uint8               reliable;
});
PACKSTRUCT( struct gecko_msg_mesh_health_client_set_period_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_health_client_get_attention_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_health_client_get_attention_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_health_client_set_attention_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    uint8               attention;
    uint8               reliable;
});
PACKSTRUCT( struct gecko_msg_mesh_health_client_set_attention_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_health_client_server_status_evt_t
{
    uint16              result;
    uint16              elem_index;
    uint16              client_address;
    uint16              server_address;
    uint8               current;
    uint8               test_id;
    uint16              vendor_id;
    uint8array          faults;
});
PACKSTRUCT( struct gecko_msg_mesh_health_client_server_status_period_evt_t
{
    uint16              result;
    uint16              elem_index;
    uint16              client_address;
    uint16              server_address;
    uint8               period;
});
PACKSTRUCT( struct gecko_msg_mesh_health_client_server_status_attention_evt_t
{
    uint16              result;
    uint16              elem_index;
    uint16              client_address;
    uint16              server_address;
    uint8               attention;
});
PACKSTRUCT( struct gecko_msg_mesh_health_server_set_fault_cmd_t
{
    uint16              elem_index;
    uint8               id;
});
PACKSTRUCT( struct gecko_msg_mesh_health_server_set_fault_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_health_server_clear_fault_cmd_t
{
    uint16              elem_index;
    uint8               id;
});
PACKSTRUCT( struct gecko_msg_mesh_health_server_clear_fault_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_health_server_test_response_cmd_t
{
    uint16              elem_index;
    uint16              client_address;
    uint16              appkey_index;
    uint16              vendor_id;
});
PACKSTRUCT( struct gecko_msg_mesh_health_server_test_response_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_health_server_attention_evt_t
{
    uint16              elem_index;
    uint8               timer;
});
PACKSTRUCT( struct gecko_msg_mesh_health_server_test_request_evt_t
{
    uint16              elem_index;
    uint16              client_address;
    uint16              server_address;
    uint16              appkey_index;
    uint8               test_id;
    uint16              vendor_id;
    uint8               response_required;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_client_get_cmd_t
{
    uint16              model_id;
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    uint8               type;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_client_get_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_client_set_cmd_t
{
    uint16              model_id;
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    uint8               tid;
    uint32              transition;
    uint16              delay;
    uint16              flags;
    uint8               type;
    uint8array          parameters;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_client_set_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_client_publish_cmd_t
{
    uint16              model_id;
    uint16              elem_index;
    uint8               tid;
    uint32              transition;
    uint16              delay;
    uint16              flags;
    uint8               type;
    uint8array          parameters;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_client_publish_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_client_get_params_cmd_t
{
    uint16              model_id;
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    uint8               type;
    uint8array          parameters;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_client_get_params_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_client_init_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_client_init_common_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_client_init_on_off_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_client_init_level_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_client_init_default_transition_time_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_client_init_power_on_off_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_client_init_power_level_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_client_init_battery_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_client_init_location_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_client_init_property_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_client_init_lightness_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_client_init_ctl_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_client_server_status_evt_t
{
    uint16              model_id;
    uint16              elem_index;
    uint16              client_address;
    uint16              server_address;
    uint32              remaining;
    uint16              flags;
    uint8               type;
    uint8array          parameters;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_server_response_cmd_t
{
    uint16              model_id;
    uint16              elem_index;
    uint16              client_address;
    uint16              appkey_index;
    uint32              remaining;
    uint16              flags;
    uint8               type;
    uint8array          parameters;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_server_response_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_server_update_cmd_t
{
    uint16              model_id;
    uint16              elem_index;
    uint32              remaining;
    uint8               type;
    uint8array          parameters;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_server_update_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_server_publish_cmd_t
{
    uint16              model_id;
    uint16              elem_index;
    uint8               type;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_server_publish_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_server_init_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_server_init_common_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_server_init_on_off_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_server_init_level_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_server_init_default_transition_time_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_server_init_power_on_off_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_server_init_power_level_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_server_init_battery_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_server_init_location_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_server_init_property_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_server_init_lightness_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_server_init_ctl_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_server_client_request_evt_t
{
    uint16              model_id;
    uint16              elem_index;
    uint16              client_address;
    uint16              server_address;
    uint16              appkey_index;
    uint32              transition;
    uint16              delay;
    uint16              flags;
    uint8               type;
    uint8array          parameters;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_server_state_changed_evt_t
{
    uint16              model_id;
    uint16              elem_index;
    uint32              remaining;
    uint8               type;
    uint8array          parameters;
});
PACKSTRUCT( struct gecko_msg_mesh_generic_server_state_recall_evt_t
{
    uint16              model_id;
    uint16              elem_index;
    uint32              transition_time;
    uint8               type;
    uint8array          parameters;
});
PACKSTRUCT( struct gecko_msg_coex_set_options_cmd_t
{
    uint32              mask;
    uint32              options;
});
PACKSTRUCT( struct gecko_msg_coex_set_options_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_coex_get_counters_cmd_t
{
    uint8               reset;
});
PACKSTRUCT( struct gecko_msg_coex_get_counters_rsp_t
{
    uint16              result;
    uint8array          counters;
});
PACKSTRUCT( struct gecko_msg_coex_set_parameters_cmd_t
{
    uint8               priority;
    uint8               request;
    uint8               pwm_period;
    uint8               pwm_dutycycle;
});
PACKSTRUCT( struct gecko_msg_coex_set_parameters_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_coex_set_directional_priority_pulse_cmd_t
{
    uint8               pulse;
});
PACKSTRUCT( struct gecko_msg_coex_set_directional_priority_pulse_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_test_get_nettx_rsp_t
{
    uint16              result;
    uint8               count;
    uint8               interval;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_nettx_cmd_t
{
    uint8               count;
    uint8               interval;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_nettx_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_test_get_relay_rsp_t
{
    uint16              result;
    uint8               enabled;
    uint8               count;
    uint8               interval;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_relay_cmd_t
{
    uint8               enabled;
    uint8               count;
    uint8               interval;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_relay_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_adv_scan_params_cmd_t
{
    uint16              adv_interval_min;
    uint16              adv_interval_max;
    uint8               adv_repeat_packets;
    uint8               adv_use_random_address;
    uint8               adv_channel_map;
    uint16              scan_interval;
    uint16              scan_window;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_adv_scan_params_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_ivupdate_test_mode_cmd_t
{
    uint8               mode;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_ivupdate_test_mode_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_test_get_ivupdate_test_mode_rsp_t
{
    uint16              result;
    uint8               mode;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_segment_send_delay_cmd_t
{
    uint8               delay;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_segment_send_delay_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_ivupdate_state_cmd_t
{
    uint8               state;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_ivupdate_state_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_test_send_beacons_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_test_bind_local_model_app_cmd_t
{
    uint16              elem_index;
    uint16              appkey_index;
    uint16              vendor_id;
    uint16              model_id;
});
PACKSTRUCT( struct gecko_msg_mesh_test_bind_local_model_app_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_test_unbind_local_model_app_cmd_t
{
    uint16              elem_index;
    uint16              appkey_index;
    uint16              vendor_id;
    uint16              model_id;
});
PACKSTRUCT( struct gecko_msg_mesh_test_unbind_local_model_app_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_test_add_local_model_sub_cmd_t
{
    uint16              elem_index;
    uint16              vendor_id;
    uint16              model_id;
    uint16              sub_address;
});
PACKSTRUCT( struct gecko_msg_mesh_test_add_local_model_sub_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_test_del_local_model_sub_cmd_t
{
    uint16              elem_index;
    uint16              vendor_id;
    uint16              model_id;
    uint16              sub_address;
});
PACKSTRUCT( struct gecko_msg_mesh_test_del_local_model_sub_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_test_add_local_model_sub_va_cmd_t
{
    uint16              elem_index;
    uint16              vendor_id;
    uint16              model_id;
    uint8array          sub_address;
});
PACKSTRUCT( struct gecko_msg_mesh_test_add_local_model_sub_va_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_test_del_local_model_sub_va_cmd_t
{
    uint16              elem_index;
    uint16              vendor_id;
    uint16              model_id;
    uint8array          sub_address;
});
PACKSTRUCT( struct gecko_msg_mesh_test_del_local_model_sub_va_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_test_get_local_model_sub_cmd_t
{
    uint16              elem_index;
    uint16              vendor_id;
    uint16              model_id;
});
PACKSTRUCT( struct gecko_msg_mesh_test_get_local_model_sub_rsp_t
{
    uint16              result;
    uint8array          addresses;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_local_model_pub_cmd_t
{
    uint16              elem_index;
    uint16              appkey_index;
    uint16              vendor_id;
    uint16              model_id;
    uint16              pub_address;
    uint8               ttl;
    uint8               period;
    uint8               retrans;
    uint8               credentials;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_local_model_pub_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_local_model_pub_va_cmd_t
{
    uint16              elem_index;
    uint16              appkey_index;
    uint16              vendor_id;
    uint16              model_id;
    uint8               ttl;
    uint8               period;
    uint8               retrans;
    uint8               credentials;
    uint8array          pub_address;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_local_model_pub_va_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_test_get_local_model_pub_cmd_t
{
    uint16              elem_index;
    uint16              vendor_id;
    uint16              model_id;
});
PACKSTRUCT( struct gecko_msg_mesh_test_get_local_model_pub_rsp_t
{
    uint16              result;
    uint16              appkey_index;
    uint16              pub_address;
    uint8               ttl;
    uint8               period;
    uint8               retrans;
    uint8               credentials;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_local_heartbeat_subscription_cmd_t
{
    uint16              subscription_source;
    uint16              subscription_destination;
    uint8               period_log;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_local_heartbeat_subscription_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_test_get_local_heartbeat_subscription_rsp_t
{
    uint16              result;
    uint16              count;
    uint8               hop_min;
    uint8               hop_max;
});
PACKSTRUCT( struct gecko_msg_mesh_test_get_local_heartbeat_publication_rsp_t
{
    uint16              result;
    uint16              publication_address;
    uint8               count;
    uint8               period_log;
    uint8               ttl;
    uint16              features;
    uint16              publication_netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_local_heartbeat_publication_cmd_t
{
    uint16              publication_address;
    uint8               count_log;
    uint8               period_log;
    uint8               ttl;
    uint16              features;
    uint16              publication_netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_local_heartbeat_publication_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_local_config_cmd_t
{
    uint16              id;
    uint16              netkey_index;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_local_config_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_test_get_local_config_cmd_t
{
    uint16              id;
    uint16              netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_test_get_local_config_rsp_t
{
    uint16              result;
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_mesh_test_add_local_key_cmd_t
{
    uint8               key_type;
    aes_key_128         key;
    uint16              key_index;
    uint16              netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_test_add_local_key_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_test_del_local_key_cmd_t
{
    uint8               key_type;
    uint16              key_index;
});
PACKSTRUCT( struct gecko_msg_mesh_test_del_local_key_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_test_update_local_key_cmd_t
{
    uint8               key_type;
    aes_key_128         key;
    uint16              key_index;
});
PACKSTRUCT( struct gecko_msg_mesh_test_update_local_key_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_sar_config_cmd_t
{
    uint32              incomplete_timer_ms;
    uint32              pending_ack_base_ms;
    uint32              pending_ack_mul_ms;
    uint32              wait_for_ack_base_ms;
    uint32              wait_for_ack_mul_ms;
    uint8               max_send_rounds;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_sar_config_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_test_get_element_seqnum_cmd_t
{
    uint16              elem_index;
});
PACKSTRUCT( struct gecko_msg_mesh_test_get_element_seqnum_rsp_t
{
    uint16              result;
    uint32              seqnum;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_adv_bearer_state_cmd_t
{
    uint8               state;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_adv_bearer_state_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_test_get_key_count_cmd_t
{
    uint8               type;
});
PACKSTRUCT( struct gecko_msg_mesh_test_get_key_count_rsp_t
{
    uint16              result;
    uint32              count;
});
PACKSTRUCT( struct gecko_msg_mesh_test_get_key_cmd_t
{
    uint8               type;
    uint32              index;
    uint8               current;
});
PACKSTRUCT( struct gecko_msg_mesh_test_get_key_rsp_t
{
    uint16              result;
    uint16              id;
    uint16              network;
    aes_key_128         key;
});
PACKSTRUCT( struct gecko_msg_mesh_test_prov_get_device_key_cmd_t
{
    uint16              address;
});
PACKSTRUCT( struct gecko_msg_mesh_test_prov_get_device_key_rsp_t
{
    uint16              result;
    aes_key_128         device_key;
});
PACKSTRUCT( struct gecko_msg_mesh_test_prov_prepare_key_refresh_cmd_t
{
    aes_key_128         net_key;
    uint8array          app_keys;
});
PACKSTRUCT( struct gecko_msg_mesh_test_prov_prepare_key_refresh_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_test_cancel_segmented_tx_cmd_t
{
    uint16              src_addr;
    uint16              dst_addr;
});
PACKSTRUCT( struct gecko_msg_mesh_test_cancel_segmented_tx_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_iv_index_cmd_t
{
    uint32              iv_index;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_iv_index_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_element_seqnum_cmd_t
{
    uint16              elem_index;
    uint32              seqnum;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_element_seqnum_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_model_option_cmd_t
{
    uint16              elem_index;
    uint16              vendor_id;
    uint16              model_id;
    uint8               option;
    uint32              value;
});
PACKSTRUCT( struct gecko_msg_mesh_test_set_model_option_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_test_get_local_model_app_bindings_cmd_t
{
    uint16              elem_index;
    uint16              vendor_id;
    uint16              model_id;
});
PACKSTRUCT( struct gecko_msg_mesh_test_get_local_model_app_bindings_rsp_t
{
    uint16              result;
    uint8array          appkeys;
});
PACKSTRUCT( struct gecko_msg_mesh_test_local_heartbeat_subscription_complete_evt_t
{
    uint16              count;
    uint8               hop_min;
    uint8               hop_max;
});
PACKSTRUCT( struct gecko_msg_mesh_lpn_init_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_lpn_deinit_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_lpn_configure_cmd_t
{
    uint8               queue_length;
    uint32              poll_timeout;
});
PACKSTRUCT( struct gecko_msg_mesh_lpn_configure_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_lpn_establish_friendship_cmd_t
{
    uint16              netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_lpn_establish_friendship_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_lpn_poll_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_lpn_terminate_friendship_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_lpn_config_cmd_t
{
    uint8               setting_id;
    uint32              value;
});
PACKSTRUCT( struct gecko_msg_mesh_lpn_config_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_lpn_friendship_established_evt_t
{
    uint16              friend_address;
});
PACKSTRUCT( struct gecko_msg_mesh_lpn_friendship_failed_evt_t
{
    uint16              reason;
});
PACKSTRUCT( struct gecko_msg_mesh_lpn_friendship_terminated_evt_t
{
    uint16              reason;
});
PACKSTRUCT( struct gecko_msg_mesh_friend_init_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_friend_deinit_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_friend_friendship_established_evt_t
{
    uint16              lpn_address;
    uint16              netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_friend_friendship_terminated_evt_t
{
    uint16              reason;
    uint16              lpn_address;
    uint16              netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_cancel_request_cmd_t
{
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_cancel_request_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_get_request_status_cmd_t
{
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_get_request_status_rsp_t
{
    uint16              result;
    uint16              server_address;
    uint16              opcode;
    uint32              age;
    uint32              remaining;
    uint8               friend_acked;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_get_default_timeout_rsp_t
{
    uint16              result;
    uint32              timeout_ms;
    uint32              lpn_timeout_ms;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_set_default_timeout_cmd_t
{
    uint32              timeout_ms;
    uint32              lpn_timeout_ms;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_set_default_timeout_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_add_netkey_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint16              netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_add_netkey_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_remove_netkey_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint16              netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_remove_netkey_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_list_netkeys_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_list_netkeys_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_add_appkey_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint16              appkey_index;
    uint16              netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_add_appkey_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_remove_appkey_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint16              appkey_index;
    uint16              netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_remove_appkey_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_list_appkeys_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint16              netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_list_appkeys_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_bind_model_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint8               element_index;
    uint16              appkey_index;
    uint16              vendor_id;
    uint16              model_id;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_bind_model_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_unbind_model_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint8               element_index;
    uint16              appkey_index;
    uint16              vendor_id;
    uint16              model_id;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_unbind_model_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_list_bindings_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint8               element_index;
    uint16              vendor_id;
    uint16              model_id;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_list_bindings_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_get_model_pub_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint8               element_index;
    uint16              vendor_id;
    uint16              model_id;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_get_model_pub_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_set_model_pub_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint8               element_index;
    uint16              vendor_id;
    uint16              model_id;
    uint16              address;
    uint16              appkey_index;
    uint8               credentials;
    uint8               ttl;
    uint32              period_ms;
    uint8               retransmit_count;
    uint16              retransmit_interval_ms;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_set_model_pub_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_set_model_pub_va_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint8               element_index;
    uint16              vendor_id;
    uint16              model_id;
    uuid_128            address;
    uint16              appkey_index;
    uint8               credentials;
    uint8               ttl;
    uint32              period_ms;
    uint8               retransmit_count;
    uint16              retransmit_interval_ms;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_set_model_pub_va_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_add_model_sub_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint8               element_index;
    uint16              vendor_id;
    uint16              model_id;
    uint16              sub_address;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_add_model_sub_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_add_model_sub_va_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint8               element_index;
    uint16              vendor_id;
    uint16              model_id;
    uuid_128            sub_address;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_add_model_sub_va_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_remove_model_sub_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint8               element_index;
    uint16              vendor_id;
    uint16              model_id;
    uint16              sub_address;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_remove_model_sub_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_remove_model_sub_va_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint8               element_index;
    uint16              vendor_id;
    uint16              model_id;
    uuid_128            sub_address;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_remove_model_sub_va_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_set_model_sub_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint8               element_index;
    uint16              vendor_id;
    uint16              model_id;
    uint16              sub_address;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_set_model_sub_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_set_model_sub_va_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint8               element_index;
    uint16              vendor_id;
    uint16              model_id;
    uuid_128            sub_address;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_set_model_sub_va_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_clear_model_sub_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint8               element_index;
    uint16              vendor_id;
    uint16              model_id;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_clear_model_sub_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_list_subs_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint8               element_index;
    uint16              vendor_id;
    uint16              model_id;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_list_subs_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_get_heartbeat_pub_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_get_heartbeat_pub_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_set_heartbeat_pub_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint16              destination_address;
    uint16              netkey_index;
    uint8               count_log;
    uint8               period_log;
    uint8               ttl;
    uint16              features;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_set_heartbeat_pub_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_get_heartbeat_sub_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_get_heartbeat_sub_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_set_heartbeat_sub_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint16              source_address;
    uint16              destination_address;
    uint8               period_log;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_set_heartbeat_sub_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_get_beacon_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_get_beacon_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_set_beacon_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint8               value;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_set_beacon_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_get_default_ttl_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_get_default_ttl_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_set_default_ttl_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint8               value;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_set_default_ttl_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_get_gatt_proxy_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_get_gatt_proxy_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_set_gatt_proxy_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint8               value;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_set_gatt_proxy_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_get_relay_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_get_relay_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_set_relay_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint8               value;
    uint8               retransmit_count;
    uint16              retransmit_interval_ms;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_set_relay_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_get_network_transmit_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_get_network_transmit_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_set_network_transmit_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint8               transmit_count;
    uint16              transmit_interval_ms;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_set_network_transmit_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_get_identity_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint16              netkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_get_identity_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_set_identity_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint16              netkey_index;
    uint8               value;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_set_identity_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_get_friend_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_get_friend_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_set_friend_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint8               value;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_set_friend_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_get_lpn_polltimeout_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint16              lpn_address;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_get_lpn_polltimeout_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_get_dcd_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
    uint8               page;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_get_dcd_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_reset_node_cmd_t
{
    uint16              enc_netkey_index;
    uint16              server_address;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_reset_node_rsp_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_request_modified_evt_t
{
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_netkey_status_evt_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_netkey_list_evt_t
{
    uint32              handle;
    uint8array          netkey_indices;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_netkey_list_end_evt_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_appkey_status_evt_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_appkey_list_evt_t
{
    uint32              handle;
    uint8array          appkey_indices;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_appkey_list_end_evt_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_binding_status_evt_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_bindings_list_evt_t
{
    uint32              handle;
    uint8array          appkey_indices;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_bindings_list_end_evt_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_model_pub_status_evt_t
{
    uint16              result;
    uint32              handle;
    uint16              address;
    uint16              appkey_index;
    uint8               credentials;
    uint8               ttl;
    uint32              period_ms;
    uint8               retransmit_count;
    uint16              retransmit_interval_ms;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_model_sub_status_evt_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_subs_list_evt_t
{
    uint32              handle;
    uint8array          addresses;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_subs_list_end_evt_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_heartbeat_pub_status_evt_t
{
    uint16              result;
    uint32              handle;
    uint16              destination_address;
    uint16              netkey_index;
    uint8               count_log;
    uint8               period_log;
    uint8               ttl;
    uint16              features;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_heartbeat_sub_status_evt_t
{
    uint16              result;
    uint32              handle;
    uint16              source_address;
    uint16              destination_address;
    uint8               period_log;
    uint8               count_log;
    uint8               min_hops;
    uint8               max_hops;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_beacon_status_evt_t
{
    uint16              result;
    uint32              handle;
    uint8               value;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_default_ttl_status_evt_t
{
    uint16              result;
    uint32              handle;
    uint8               value;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_gatt_proxy_status_evt_t
{
    uint16              result;
    uint32              handle;
    uint8               value;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_relay_status_evt_t
{
    uint16              result;
    uint32              handle;
    uint8               relay;
    uint8               retransmit_count;
    uint16              retransmit_interval_ms;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_network_transmit_status_evt_t
{
    uint16              result;
    uint32              handle;
    uint8               transmit_count;
    uint16              transmit_interval_ms;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_identity_status_evt_t
{
    uint16              result;
    uint32              handle;
    uint8               value;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_friend_status_evt_t
{
    uint16              result;
    uint32              handle;
    uint8               value;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_lpn_polltimeout_status_evt_t
{
    uint16              result;
    uint32              handle;
    uint32              poll_timeout_ms;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_dcd_data_evt_t
{
    uint32              handle;
    uint8               page;
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_dcd_data_end_evt_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_mesh_config_client_reset_status_evt_t
{
    uint16              result;
    uint32              handle;
});
PACKSTRUCT( struct gecko_msg_l2cap_coc_send_connection_request_cmd_t
{
    uint8               connection;
    uint16              le_psm;
    uint16              mtu;
    uint16              mps;
    uint16              initial_credit;
});
PACKSTRUCT( struct gecko_msg_l2cap_coc_send_connection_request_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_l2cap_coc_send_connection_response_cmd_t
{
    uint8               connection;
    uint16              cid;
    uint16              mtu;
    uint16              mps;
    uint16              initial_credit;
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_l2cap_coc_send_connection_response_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_l2cap_coc_send_le_flow_control_credit_cmd_t
{
    uint8               connection;
    uint16              cid;
    uint16              credits;
});
PACKSTRUCT( struct gecko_msg_l2cap_coc_send_le_flow_control_credit_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_l2cap_coc_send_disconnection_request_cmd_t
{
    uint8               connection;
    uint16              cid;
});
PACKSTRUCT( struct gecko_msg_l2cap_coc_send_disconnection_request_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_l2cap_coc_send_data_cmd_t
{
    uint8               connection;
    uint16              cid;
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_l2cap_coc_send_data_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_l2cap_coc_connection_request_evt_t
{
    uint8               connection;
    uint16              le_psm;
    uint16              source_cid;
    uint16              mtu;
    uint16              mps;
    uint16              initial_credit;
    uint8               flags;
    uint8               encryption_key_size;
});
PACKSTRUCT( struct gecko_msg_l2cap_coc_connection_response_evt_t
{
    uint8               connection;
    uint16              destination_cid;
    uint16              mtu;
    uint16              mps;
    uint16              initial_credit;
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_l2cap_coc_le_flow_control_credit_evt_t
{
    uint8               connection;
    uint16              cid;
    uint16              credits;
});
PACKSTRUCT( struct gecko_msg_l2cap_coc_channel_disconnected_evt_t
{
    uint8               connection;
    uint16              cid;
    uint16              reason;
});
PACKSTRUCT( struct gecko_msg_l2cap_coc_data_evt_t
{
    uint8               connection;
    uint16              cid;
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_l2cap_command_rejected_evt_t
{
    uint8               connection;
    uint8               code;
    uint16              reason;
});
PACKSTRUCT( struct gecko_msg_cte_transmitter_enable_connection_cte_cmd_t
{
    uint8               connection;
    uint8               cte_types;
    uint8array          switching_pattern;
});
PACKSTRUCT( struct gecko_msg_cte_transmitter_enable_connection_cte_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_cte_transmitter_disable_connection_cte_cmd_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_cte_transmitter_disable_connection_cte_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_cte_transmitter_enable_connectionless_cte_cmd_t
{
    uint8               handle;
    uint8               cte_length;
    uint8               cte_type;
    uint8               cte_count;
    uint8array          switching_pattern;
});
PACKSTRUCT( struct gecko_msg_cte_transmitter_enable_connectionless_cte_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_cte_transmitter_disable_connectionless_cte_cmd_t
{
    uint8               handle;
});
PACKSTRUCT( struct gecko_msg_cte_transmitter_disable_connectionless_cte_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_cte_transmitter_set_dtm_parameters_cmd_t
{
    uint8               cte_length;
    uint8               cte_type;
    uint8array          switching_pattern;
});
PACKSTRUCT( struct gecko_msg_cte_transmitter_set_dtm_parameters_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_cte_transmitter_clear_dtm_parameters_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_cte_transmitter_enable_silabs_cte_cmd_t
{
    uint8               handle;
    uint8               cte_length;
    uint8               cte_type;
    uint8               cte_count;
    uint8array          switching_pattern;
});
PACKSTRUCT( struct gecko_msg_cte_transmitter_enable_silabs_cte_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_cte_transmitter_disable_silabs_cte_cmd_t
{
    uint8               handle;
});
PACKSTRUCT( struct gecko_msg_cte_transmitter_disable_silabs_cte_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_cte_receiver_configure_cmd_t
{
    uint8               flags;
});
PACKSTRUCT( struct gecko_msg_cte_receiver_configure_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_cte_receiver_enable_connection_cte_cmd_t
{
    uint8               connection;
    uint16              interval;
    uint8               cte_length;
    uint8               cte_type;
    uint8               slot_durations;
    uint8array          switching_pattern;
});
PACKSTRUCT( struct gecko_msg_cte_receiver_enable_connection_cte_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_cte_receiver_disable_connection_cte_cmd_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_cte_receiver_disable_connection_cte_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_cte_receiver_enable_connectionless_cte_cmd_t
{
    uint8               sync;
    uint8               slot_durations;
    uint8               cte_count;
    uint8array          switching_pattern;
});
PACKSTRUCT( struct gecko_msg_cte_receiver_enable_connectionless_cte_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_cte_receiver_disable_connectionless_cte_cmd_t
{
    uint8               sync;
});
PACKSTRUCT( struct gecko_msg_cte_receiver_disable_connectionless_cte_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_cte_receiver_set_dtm_parameters_cmd_t
{
    uint8               cte_length;
    uint8               cte_type;
    uint8               slot_durations;
    uint8array          switching_pattern;
});
PACKSTRUCT( struct gecko_msg_cte_receiver_set_dtm_parameters_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_cte_receiver_clear_dtm_parameters_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_cte_receiver_enable_silabs_cte_cmd_t
{
    uint8               slot_durations;
    uint8               cte_count;
    uint8array          switching_pattern;
});
PACKSTRUCT( struct gecko_msg_cte_receiver_enable_silabs_cte_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_cte_receiver_disable_silabs_cte_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_cte_receiver_connection_iq_report_evt_t
{
    uint16              status;
    uint8               connection;
    uint8               phy;
    uint8               channel;
    int8                rssi;
    uint8               rssi_antenna_id;
    uint8               cte_type;
    uint8               slot_durations;
    uint16              event_counter;
    uint8array          samples;
});
PACKSTRUCT( struct gecko_msg_cte_receiver_connectionless_iq_report_evt_t
{
    uint16              status;
    uint8               sync;
    uint8               channel;
    int8                rssi;
    uint8               rssi_antenna_id;
    uint8               cte_type;
    uint8               slot_durations;
    uint16              event_counter;
    uint8array          samples;
});
PACKSTRUCT( struct gecko_msg_cte_receiver_dtm_iq_report_evt_t
{
    uint16              status;
    uint8               channel;
    int8                rssi;
    uint8               rssi_antenna_id;
    uint8               cte_type;
    uint8               slot_durations;
    uint16              event_counter;
    uint8array          samples;
});
PACKSTRUCT( struct gecko_msg_cte_receiver_silabs_iq_report_evt_t
{
    uint16              status;
    bd_addr             address;
    uint8               address_type;
    uint8               phy;
    uint8               channel;
    int8                rssi;
    uint8               rssi_antenna_id;
    uint8               cte_type;
    uint8               slot_durations;
    uint16              packet_counter;
    uint8array          samples;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_server_init_cmd_t
{
    uint16              elem_index;
    uint8array          descriptors;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_server_init_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_server_deinit_cmd_t
{
    uint16              elem_index;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_server_deinit_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_server_send_descriptor_status_cmd_t
{
    uint16              elem_index;
    uint16              client_address;
    uint16              appkey_index;
    uint8               flags;
    uint8array          descriptors;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_server_send_descriptor_status_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_server_send_status_cmd_t
{
    uint16              elem_index;
    uint16              client_address;
    uint16              appkey_index;
    uint8               flags;
    uint8array          sensor_data;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_server_send_status_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_server_send_column_status_cmd_t
{
    uint16              elem_index;
    uint16              client_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              property_id;
    uint8array          sensor_data;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_server_send_column_status_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_server_send_series_status_cmd_t
{
    uint16              elem_index;
    uint16              client_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              property_id;
    uint8array          sensor_data;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_server_send_series_status_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_server_get_request_evt_t
{
    uint16              elem_index;
    uint16              client_address;
    uint16              server_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              property_id;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_server_get_column_request_evt_t
{
    uint16              elem_index;
    uint16              client_address;
    uint16              server_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              property_id;
    uint8array          column_ids;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_server_get_series_request_evt_t
{
    uint16              elem_index;
    uint16              client_address;
    uint16              server_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              property_id;
    uint8array          column_ids;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_server_publish_evt_t
{
    uint16              elem_index;
    uint32              period_ms;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_setup_server_send_cadence_status_cmd_t
{
    uint16              elem_index;
    uint16              client_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              property_id;
    uint8array          params;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_setup_server_send_cadence_status_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_setup_server_send_settings_status_cmd_t
{
    uint16              elem_index;
    uint16              client_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              property_id;
    uint8array          setting_ids;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_setup_server_send_settings_status_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_setup_server_send_setting_status_cmd_t
{
    uint16              elem_index;
    uint16              client_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              property_id;
    uint16              setting_id;
    uint8array          raw_value;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_setup_server_send_setting_status_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_setup_server_get_cadence_request_evt_t
{
    uint16              elem_index;
    uint16              client_address;
    uint16              server_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              property_id;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_setup_server_set_cadence_request_evt_t
{
    uint16              elem_index;
    uint16              client_address;
    uint16              server_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              property_id;
    uint8               period_divisor;
    uint8               trigger_type;
    uint8array          params;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_setup_server_get_settings_request_evt_t
{
    uint16              elem_index;
    uint16              client_address;
    uint16              server_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              property_id;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_setup_server_get_setting_request_evt_t
{
    uint16              elem_index;
    uint16              client_address;
    uint16              server_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              property_id;
    uint16              setting_id;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_setup_server_set_setting_request_evt_t
{
    uint16              elem_index;
    uint16              client_address;
    uint16              server_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              property_id;
    uint16              setting_id;
    uint8array          raw_value;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_setup_server_publish_evt_t
{
    uint16              elem_index;
    uint32              period_ms;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_client_init_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_client_deinit_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_client_get_descriptor_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              property_id;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_client_get_descriptor_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_client_get_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              property_id;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_client_get_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_client_get_column_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              property_id;
    uint8array          column_id;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_client_get_column_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_client_get_series_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              property_id;
    uint8array          column_ids;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_client_get_series_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_client_get_cadence_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              property_id;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_client_get_cadence_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_client_set_cadence_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              property_id;
    uint8array          params;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_client_set_cadence_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_client_get_settings_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              property_id;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_client_get_settings_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_client_get_setting_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              property_id;
    uint16              setting_id;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_client_get_setting_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_client_set_setting_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              property_id;
    uint16              setting_id;
    uint8array          raw_value;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_client_set_setting_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_client_descriptor_status_evt_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              client_address;
    uint16              appkey_index;
    uint8               flags;
    uint8array          descriptors;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_client_cadence_status_evt_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              client_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              property_id;
    uint8array          params;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_client_settings_status_evt_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              client_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              property_id;
    uint8array          setting_ids;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_client_setting_status_evt_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              client_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              property_id;
    uint16              setting_id;
    uint8array          raw_value;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_client_status_evt_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              client_address;
    uint16              appkey_index;
    uint8               flags;
    uint8array          sensor_data;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_client_column_status_evt_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              client_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              property_id;
    uint8array          sensor_data;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_client_series_status_evt_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              client_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              property_id;
    uint8array          sensor_data;
});
PACKSTRUCT( struct gecko_msg_mesh_sensor_client_publish_evt_t
{
    uint16              elem_index;
    uint32              period_ms;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_client_init_cmd_t
{
    uint16              elem_index;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_client_init_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_client_get_mode_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_client_get_mode_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_client_set_mode_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    uint8               flags;
    uint8               mode;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_client_set_mode_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_client_get_om_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_client_get_om_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_client_set_om_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    uint8               flags;
    uint8               mode;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_client_set_om_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_client_get_light_onoff_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_client_get_light_onoff_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_client_set_light_onoff_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    uint8               flags;
    uint8               target_state;
    uint8               tid;
    uint32              transition_time;
    uint16              message_delay;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_client_set_light_onoff_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_client_get_property_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    uint16              property_id;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_client_get_property_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_client_set_property_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              property_id;
    uint8array          params;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_client_set_property_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_client_mode_status_evt_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              destination_address;
    uint16              appkey_index;
    uint8               mode_status_value;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_client_om_status_evt_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              destination_address;
    uint16              appkey_index;
    uint8               om_status_value;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_client_light_onoff_status_evt_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              destination_address;
    uint16              appkey_index;
    uint8               present_light_onoff;
    uint8               target_light_onoff;
    uint32              remaining_time;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_client_property_status_evt_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              destination_address;
    uint16              appkey_index;
    uint16              property_id;
    uint8array          property_value;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_server_init_cmd_t
{
    uint16              elem_index;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_server_init_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_server_deinit_cmd_t
{
    uint16              elem_index;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_server_deinit_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_server_update_mode_cmd_t
{
    uint16              elem_index;
    uint8               mode;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_server_update_mode_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_server_update_om_cmd_t
{
    uint16              elem_index;
    uint8               om;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_server_update_om_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_server_update_light_onoff_cmd_t
{
    uint16              elem_index;
    uint8               light_onoff;
    uint32              transition_time_ms;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_server_update_light_onoff_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_server_init_all_properties_cmd_t
{
    uint16              elem_index;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_server_init_all_properties_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_server_set_publish_mask_cmd_t
{
    uint16              elem_index;
    uint16              status_type;
    uint8               value;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_server_set_publish_mask_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_server_set_regulator_interval_cmd_t
{
    uint16              elem_index;
    uint8               value;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_server_set_regulator_interval_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_server_set_event_mask_cmd_t
{
    uint16              elem_index;
    uint16              event_type;
    uint8               value;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_server_set_event_mask_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_server_get_lc_state_cmd_t
{
    uint16              elem_index;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_server_get_lc_state_rsp_t
{
    uint16              result;
    uint8               state;
    uint32              transition_time;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_server_mode_updated_evt_t
{
    uint16              elem_index;
    uint16              client_address;
    uint16              destination_address;
    uint16              appkey_index;
    uint8               mode_value;
    uint8               manual_override;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_server_om_updated_evt_t
{
    uint16              elem_index;
    uint16              client_address;
    uint16              destination_address;
    uint16              appkey_index;
    uint8               om_value;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_server_light_onoff_updated_evt_t
{
    uint16              elem_index;
    uint16              source_address;
    uint16              destination_address;
    uint16              appkey_index;
    uint8               onoff_state;
    uint32              onoff_trans_time;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_server_occupancy_updated_evt_t
{
    uint16              elem_index;
    uint16              source_address;
    uint16              destination_address;
    uint16              appkey_index;
    uint8               occupancy_value;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_server_ambient_lux_level_updated_evt_t
{
    uint16              elem_index;
    uint16              source_address;
    uint16              destination_address;
    uint16              appkey_index;
    uint32              ambient_lux_level_value;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_server_linear_output_updated_evt_t
{
    uint16              elem_index;
    uint16              linear_output_value;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_server_state_updated_evt_t
{
    uint16              elem_index;
    uint8               state;
    uint32              transition_time;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_server_regulator_debug_info_evt_t
{
    uint16              elem_index;
    uint16              i;
    uint16              l;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_setup_server_update_property_cmd_t
{
    uint16              elem_index;
    uint16              property_id;
    uint8array          params;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_setup_server_update_property_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_lc_setup_server_set_property_evt_t
{
    uint16              elem_index;
    uint16              client_address;
    uint16              destination_address;
    uint16              appkey_index;
    uint16              property_id;
    uint8array          property_value;
});
PACKSTRUCT( struct gecko_msg_mesh_scene_client_init_cmd_t
{
    uint16              elem_index;
});
PACKSTRUCT( struct gecko_msg_mesh_scene_client_init_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_scene_client_get_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_scene_client_get_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_scene_client_get_register_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_scene_client_get_register_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_scene_client_recall_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              selected_scene;
    uint8               tid;
    uint32              transition_time;
    uint32              delay;
});
PACKSTRUCT( struct gecko_msg_mesh_scene_client_recall_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_scene_client_store_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              selected_scene;
});
PACKSTRUCT( struct gecko_msg_mesh_scene_client_store_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_scene_client_delete_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    uint8               flags;
    uint16              selected_scene;
});
PACKSTRUCT( struct gecko_msg_mesh_scene_client_delete_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_scene_client_status_evt_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              destination_address;
    uint16              appkey_index;
    uint8               status;
    uint16              current_scene;
    uint16              target_scene;
    uint32              remaining_time;
});
PACKSTRUCT( struct gecko_msg_mesh_scene_client_register_status_evt_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              destination_address;
    uint16              appkey_index;
    uint8               status;
    uint16              current_scene;
    uint16array         scenes;
});
PACKSTRUCT( struct gecko_msg_mesh_scene_server_init_cmd_t
{
    uint16              elem_index;
});
PACKSTRUCT( struct gecko_msg_mesh_scene_server_init_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_scene_server_deinit_cmd_t
{
    uint16              elem_index;
});
PACKSTRUCT( struct gecko_msg_mesh_scene_server_deinit_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_scene_server_reset_register_cmd_t
{
    uint16              elem_index;
});
PACKSTRUCT( struct gecko_msg_mesh_scene_server_reset_register_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_scene_server_get_evt_t
{
    uint16              elem_index;
    uint16              client_address;
    uint16              destination_address;
    uint16              appkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_scene_server_register_get_evt_t
{
    uint16              elem_index;
    uint16              client_address;
    uint16              destination_address;
    uint16              appkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_scene_server_recall_evt_t
{
    uint16              elem_index;
    uint16              client_address;
    uint16              destination_address;
    uint16              appkey_index;
    uint16              selected_scene;
    uint32              transition_time;
});
PACKSTRUCT( struct gecko_msg_mesh_scene_server_publish_evt_t
{
    uint16              elem_index;
    uint32              period_ms;
});
PACKSTRUCT( struct gecko_msg_mesh_scene_setup_server_init_cmd_t
{
    uint16              elem_index;
});
PACKSTRUCT( struct gecko_msg_mesh_scene_setup_server_init_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_scene_setup_server_store_evt_t
{
    uint16              elem_index;
    uint16              client_address;
    uint16              destination_address;
    uint16              appkey_index;
    uint16              scene_id;
});
PACKSTRUCT( struct gecko_msg_mesh_scene_setup_server_delete_evt_t
{
    uint16              elem_index;
    uint16              client_address;
    uint16              destination_address;
    uint16              appkey_index;
    uint16              scene_id;
});
PACKSTRUCT( struct gecko_msg_mesh_scene_setup_server_publish_evt_t
{
    uint16              elem_index;
    uint32              period_ms;
});
PACKSTRUCT( struct gecko_msg_mesh_scheduler_client_init_cmd_t
{
    uint16              elem_index;
});
PACKSTRUCT( struct gecko_msg_mesh_scheduler_client_init_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_scheduler_client_deinit_cmd_t
{
    uint16              elem_index;
});
PACKSTRUCT( struct gecko_msg_mesh_scheduler_client_deinit_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_scheduler_client_get_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_scheduler_client_get_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_scheduler_client_get_action_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    uint8               index;
});
PACKSTRUCT( struct gecko_msg_mesh_scheduler_client_get_action_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_scheduler_client_set_action_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    uint8               flags;
    uint8               index;
    uint8               year;
    uint16              month;
    uint8               day;
    uint8               hour;
    uint8               minute;
    uint8               second;
    uint8               day_of_week;
    uint8               action;
    uint8               transition_time;
    uint16              scene_number;
});
PACKSTRUCT( struct gecko_msg_mesh_scheduler_client_set_action_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_scheduler_client_status_evt_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              client_address;
    uint16              appkey_index;
    uint16              scheduler;
});
PACKSTRUCT( struct gecko_msg_mesh_scheduler_client_action_status_evt_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              client_address;
    uint16              appkey_index;
    uint8               index;
    uint8               year;
    uint16              month;
    uint8               day;
    uint8               hour;
    uint8               minute;
    uint8               second;
    uint8               day_of_week;
    uint8               action;
    uint8               transition_time;
    uint16              scene_number;
});
PACKSTRUCT( struct gecko_msg_mesh_scheduler_server_init_cmd_t
{
    uint16              elem_index;
});
PACKSTRUCT( struct gecko_msg_mesh_scheduler_server_init_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_scheduler_server_deinit_cmd_t
{
    uint16              elem_index;
});
PACKSTRUCT( struct gecko_msg_mesh_scheduler_server_deinit_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_scheduler_server_get_cmd_t
{
    uint16              elem_index;
});
PACKSTRUCT( struct gecko_msg_mesh_scheduler_server_get_rsp_t
{
    uint16              result;
    uint16              status;
});
PACKSTRUCT( struct gecko_msg_mesh_scheduler_server_get_action_cmd_t
{
    uint16              elem_index;
    uint8               index;
});
PACKSTRUCT( struct gecko_msg_mesh_scheduler_server_get_action_rsp_t
{
    uint16              result;
    uint8               index;
    uint8               year;
    uint16              month;
    uint8               day;
    uint8               hour;
    uint8               minute;
    uint8               second;
    uint8               day_of_week;
    uint8               action;
    uint8               transition_time;
    uint16              scene_number;
});
PACKSTRUCT( struct gecko_msg_mesh_scheduler_server_set_action_cmd_t
{
    uint16              elem_index;
    uint8               index;
    uint8               year;
    uint16              month;
    uint8               day;
    uint8               hour;
    uint8               minute;
    uint8               second;
    uint8               day_of_week;
    uint8               action;
    uint8               transition_time;
    uint16              scene_number;
});
PACKSTRUCT( struct gecko_msg_mesh_scheduler_server_set_action_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_scheduler_server_action_changed_evt_t
{
    uint16              elem_index;
    uint8               index;
    uint8               year;
    uint16              month;
    uint8               day;
    uint8               hour;
    uint8               minute;
    uint8               second;
    uint8               day_of_week;
    uint8               action;
    uint8               transition_time;
    uint16              scene_number;
});
PACKSTRUCT( struct gecko_msg_mesh_time_server_init_cmd_t
{
    uint16              elem_index;
});
PACKSTRUCT( struct gecko_msg_mesh_time_server_init_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_time_server_deinit_cmd_t
{
    uint16              elem_index;
});
PACKSTRUCT( struct gecko_msg_mesh_time_server_deinit_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_time_server_get_time_cmd_t
{
    uint16              elem_index;
});
PACKSTRUCT( struct gecko_msg_mesh_time_server_get_time_rsp_t
{
    uint16              result;
    uint64              tai_seconds;
    uint8               subsecond;
    uint8               uncertainty;
    uint8               time_authority;
    int16               time_zone_offset;
    int32               tai_utc_delta;
});
PACKSTRUCT( struct gecko_msg_mesh_time_server_set_time_cmd_t
{
    uint16              elem_index;
    uint64              tai_seconds;
    uint8               subsecond;
    uint8               uncertainty;
    uint8               time_authority;
    int16               time_zone_offset;
    int32               tai_utc_delta;
});
PACKSTRUCT( struct gecko_msg_mesh_time_server_set_time_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_time_server_get_time_zone_offset_new_cmd_t
{
    uint16              elem_index;
});
PACKSTRUCT( struct gecko_msg_mesh_time_server_get_time_zone_offset_new_rsp_t
{
    uint16              result;
    int16               new_offset;
    uint64              tai_of_zone_change;
});
PACKSTRUCT( struct gecko_msg_mesh_time_server_set_time_zone_offset_new_cmd_t
{
    uint16              elem_index;
    int16               new_offset;
    uint64              tai_of_zone_change;
});
PACKSTRUCT( struct gecko_msg_mesh_time_server_set_time_zone_offset_new_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_time_server_get_tai_utc_delta_new_cmd_t
{
    uint16              elem_index;
});
PACKSTRUCT( struct gecko_msg_mesh_time_server_get_tai_utc_delta_new_rsp_t
{
    uint16              result;
    int32               new_delta;
    uint64              tai_of_delta_change;
});
PACKSTRUCT( struct gecko_msg_mesh_time_server_set_tai_utc_delta_new_cmd_t
{
    uint16              elem_index;
    int32               new_delta;
    uint64              tai_of_delta_change;
});
PACKSTRUCT( struct gecko_msg_mesh_time_server_set_tai_utc_delta_new_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_time_server_get_time_role_cmd_t
{
    uint16              elem_index;
});
PACKSTRUCT( struct gecko_msg_mesh_time_server_get_time_role_rsp_t
{
    uint16              result;
    uint8               time_role;
});
PACKSTRUCT( struct gecko_msg_mesh_time_server_set_time_role_cmd_t
{
    uint16              elem_index;
    uint8               time_role;
});
PACKSTRUCT( struct gecko_msg_mesh_time_server_set_time_role_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_time_server_get_datetime_cmd_t
{
    uint16              elem_index;
});
PACKSTRUCT( struct gecko_msg_mesh_time_server_get_datetime_rsp_t
{
    uint16              result;
    uint16              year;
    uint8               month;
    uint8               day;
    uint8               hour;
    uint8               min;
    uint8               sec;
    uint16              msec;
    uint16              timezone;
    uint8               day_of_week;
});
PACKSTRUCT( struct gecko_msg_mesh_time_server_time_updated_evt_t
{
    uint16              elem_index;
    uint64              tai_seconds;
    uint8               subsecond;
    uint8               uncertainty;
    uint8               time_authority;
    int32               tai_utc_delta;
    int16               time_zone_offset;
});
PACKSTRUCT( struct gecko_msg_mesh_time_server_time_zone_offset_updated_evt_t
{
    uint16              elem_index;
    int16               time_zone_offset_current;
    int16               time_zone_offset_new;
    uint64              tai_of_zone_change;
});
PACKSTRUCT( struct gecko_msg_mesh_time_server_tai_utc_delta_updated_evt_t
{
    uint16              elem_index;
    int32               tai_utc_delta_current;
    int32               tai_utc_delta_new;
    uint64              tai_of_delta_change;
});
PACKSTRUCT( struct gecko_msg_mesh_time_server_time_role_updated_evt_t
{
    uint16              elem_index;
    uint8               time_role;
});
PACKSTRUCT( struct gecko_msg_mesh_time_client_init_cmd_t
{
    uint16              elem_index;
});
PACKSTRUCT( struct gecko_msg_mesh_time_client_init_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_time_client_deinit_cmd_t
{
    uint16              elem_index;
});
PACKSTRUCT( struct gecko_msg_mesh_time_client_deinit_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_time_client_get_time_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_time_client_get_time_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_time_client_set_time_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    uint64              tai_seconds;
    uint8               subsecond;
    uint8               uncertainty;
    uint8               time_authority;
    int32               tai_utc_delta;
    int16               time_zone_offset;
});
PACKSTRUCT( struct gecko_msg_mesh_time_client_set_time_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_time_client_get_time_zone_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_time_client_get_time_zone_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_time_client_set_time_zone_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    int16               time_zone_offset_new;
    uint64              tai_of_zone_change;
});
PACKSTRUCT( struct gecko_msg_mesh_time_client_set_time_zone_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_time_client_get_tai_utc_delta_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_time_client_get_tai_utc_delta_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_time_client_set_tai_utc_delta_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    int32               tai_utc_delta_new;
    uint64              tai_of_delta_change;
});
PACKSTRUCT( struct gecko_msg_mesh_time_client_set_tai_utc_delta_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_time_client_get_time_role_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
});
PACKSTRUCT( struct gecko_msg_mesh_time_client_get_time_role_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_time_client_set_time_role_cmd_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              appkey_index;
    uint8               time_role;
});
PACKSTRUCT( struct gecko_msg_mesh_time_client_set_time_role_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_mesh_time_client_time_status_evt_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              client_address;
    uint16              appkey_index;
    uint64              tai_seconds;
    uint8               subsecond;
    uint8               uncertainty;
    uint8               time_authority;
    int32               tai_utc_delta;
    int16               time_zone_offset;
});
PACKSTRUCT( struct gecko_msg_mesh_time_client_time_zone_status_evt_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              client_address;
    uint16              appkey_index;
    int16               time_zone_offset_current;
    int16               time_zone_offset_new;
    uint64              tai_of_zone_change;
});
PACKSTRUCT( struct gecko_msg_mesh_time_client_tai_utc_delta_status_evt_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              client_address;
    uint16              appkey_index;
    int32               tai_utc_delta_current;
    int32               tai_utc_delta_new;
    uint64              tai_of_delta_change;
});
PACKSTRUCT( struct gecko_msg_mesh_time_client_time_role_status_evt_t
{
    uint16              elem_index;
    uint16              server_address;
    uint16              client_address;
    uint16              appkey_index;
    uint8               time_role;
});
PACKSTRUCT( struct gecko_msg_user_message_to_target_cmd_t
{
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_user_message_to_target_rsp_t
{
    uint16              result;
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_user_message_to_host_evt_t
{
    uint8array          data;
});


/**
 * The command packet type. This does not include the actual size of the byte array for user data in the end of the message.
 * The full size of a command packet is 4 + max bgapi payload size.
 */
PACKSTRUCT( struct gecko_cmd_packet
{
    uint32   header;

union{
    uint8 handle;
    struct gecko_msg_dfu_reset_cmd_t                             cmd_dfu_reset;
    struct gecko_msg_dfu_flash_set_address_cmd_t                 cmd_dfu_flash_set_address;
    struct gecko_msg_dfu_flash_set_address_rsp_t                 rsp_dfu_flash_set_address;
    struct gecko_msg_dfu_flash_upload_cmd_t                      cmd_dfu_flash_upload;
    struct gecko_msg_dfu_flash_upload_rsp_t                      rsp_dfu_flash_upload;
    struct gecko_msg_dfu_flash_upload_finish_rsp_t               rsp_dfu_flash_upload_finish;
    struct gecko_msg_dfu_boot_evt_t                              evt_dfu_boot;
    struct gecko_msg_dfu_boot_failure_evt_t                      evt_dfu_boot_failure;
    struct gecko_msg_system_hello_rsp_t                          rsp_system_hello;
    struct gecko_msg_system_reset_cmd_t                          cmd_system_reset;
    struct gecko_msg_system_get_bt_address_rsp_t                 rsp_system_get_bt_address;
    struct gecko_msg_system_set_bt_address_cmd_t                 cmd_system_set_bt_address;
    struct gecko_msg_system_set_bt_address_rsp_t                 rsp_system_set_bt_address;
    struct gecko_msg_system_set_tx_power_cmd_t                   cmd_system_set_tx_power;
    struct gecko_msg_system_set_tx_power_rsp_t                   rsp_system_set_tx_power;
    struct gecko_msg_system_get_random_data_cmd_t                cmd_system_get_random_data;
    struct gecko_msg_system_get_random_data_rsp_t                rsp_system_get_random_data;
    struct gecko_msg_system_halt_cmd_t                           cmd_system_halt;
    struct gecko_msg_system_halt_rsp_t                           rsp_system_halt;
    struct gecko_msg_system_set_device_name_cmd_t                cmd_system_set_device_name;
    struct gecko_msg_system_set_device_name_rsp_t                rsp_system_set_device_name;
    struct gecko_msg_system_linklayer_configure_cmd_t            cmd_system_linklayer_configure;
    struct gecko_msg_system_linklayer_configure_rsp_t            rsp_system_linklayer_configure;
    struct gecko_msg_system_get_counters_cmd_t                   cmd_system_get_counters;
    struct gecko_msg_system_get_counters_rsp_t                   rsp_system_get_counters;
    struct gecko_msg_system_data_buffer_write_cmd_t              cmd_system_data_buffer_write;
    struct gecko_msg_system_data_buffer_write_rsp_t              rsp_system_data_buffer_write;
    struct gecko_msg_system_set_identity_address_cmd_t           cmd_system_set_identity_address;
    struct gecko_msg_system_set_identity_address_rsp_t           rsp_system_set_identity_address;
    struct gecko_msg_system_data_buffer_clear_rsp_t              rsp_system_data_buffer_clear;
    struct gecko_msg_system_boot_evt_t                           evt_system_boot;
    struct gecko_msg_system_external_signal_evt_t                evt_system_external_signal;
    struct gecko_msg_system_hardware_error_evt_t                 evt_system_hardware_error;
    struct gecko_msg_system_error_evt_t                          evt_system_error;
    struct gecko_msg_le_gap_open_cmd_t                           cmd_le_gap_open;
    struct gecko_msg_le_gap_open_rsp_t                           rsp_le_gap_open;
    struct gecko_msg_le_gap_set_mode_cmd_t                       cmd_le_gap_set_mode;
    struct gecko_msg_le_gap_set_mode_rsp_t                       rsp_le_gap_set_mode;
    struct gecko_msg_le_gap_discover_cmd_t                       cmd_le_gap_discover;
    struct gecko_msg_le_gap_discover_rsp_t                       rsp_le_gap_discover;
    struct gecko_msg_le_gap_end_procedure_rsp_t                  rsp_le_gap_end_procedure;
    struct gecko_msg_le_gap_set_adv_parameters_cmd_t             cmd_le_gap_set_adv_parameters;
    struct gecko_msg_le_gap_set_adv_parameters_rsp_t             rsp_le_gap_set_adv_parameters;
    struct gecko_msg_le_gap_set_conn_parameters_cmd_t            cmd_le_gap_set_conn_parameters;
    struct gecko_msg_le_gap_set_conn_parameters_rsp_t            rsp_le_gap_set_conn_parameters;
    struct gecko_msg_le_gap_set_scan_parameters_cmd_t            cmd_le_gap_set_scan_parameters;
    struct gecko_msg_le_gap_set_scan_parameters_rsp_t            rsp_le_gap_set_scan_parameters;
    struct gecko_msg_le_gap_set_adv_data_cmd_t                   cmd_le_gap_set_adv_data;
    struct gecko_msg_le_gap_set_adv_data_rsp_t                   rsp_le_gap_set_adv_data;
    struct gecko_msg_le_gap_set_adv_timeout_cmd_t                cmd_le_gap_set_adv_timeout;
    struct gecko_msg_le_gap_set_adv_timeout_rsp_t                rsp_le_gap_set_adv_timeout;
    struct gecko_msg_le_gap_set_conn_phy_cmd_t                   cmd_le_gap_set_conn_phy;
    struct gecko_msg_le_gap_set_conn_phy_rsp_t                   rsp_le_gap_set_conn_phy;
    struct gecko_msg_le_gap_bt5_set_mode_cmd_t                   cmd_le_gap_bt5_set_mode;
    struct gecko_msg_le_gap_bt5_set_mode_rsp_t                   rsp_le_gap_bt5_set_mode;
    struct gecko_msg_le_gap_bt5_set_adv_parameters_cmd_t         cmd_le_gap_bt5_set_adv_parameters;
    struct gecko_msg_le_gap_bt5_set_adv_parameters_rsp_t         rsp_le_gap_bt5_set_adv_parameters;
    struct gecko_msg_le_gap_bt5_set_adv_data_cmd_t               cmd_le_gap_bt5_set_adv_data;
    struct gecko_msg_le_gap_bt5_set_adv_data_rsp_t               rsp_le_gap_bt5_set_adv_data;
    struct gecko_msg_le_gap_set_privacy_mode_cmd_t               cmd_le_gap_set_privacy_mode;
    struct gecko_msg_le_gap_set_privacy_mode_rsp_t               rsp_le_gap_set_privacy_mode;
    struct gecko_msg_le_gap_set_advertise_timing_cmd_t           cmd_le_gap_set_advertise_timing;
    struct gecko_msg_le_gap_set_advertise_timing_rsp_t           rsp_le_gap_set_advertise_timing;
    struct gecko_msg_le_gap_set_advertise_channel_map_cmd_t      cmd_le_gap_set_advertise_channel_map;
    struct gecko_msg_le_gap_set_advertise_channel_map_rsp_t      rsp_le_gap_set_advertise_channel_map;
    struct gecko_msg_le_gap_set_advertise_report_scan_request_cmd_t cmd_le_gap_set_advertise_report_scan_request;
    struct gecko_msg_le_gap_set_advertise_report_scan_request_rsp_t rsp_le_gap_set_advertise_report_scan_request;
    struct gecko_msg_le_gap_set_advertise_phy_cmd_t              cmd_le_gap_set_advertise_phy;
    struct gecko_msg_le_gap_set_advertise_phy_rsp_t              rsp_le_gap_set_advertise_phy;
    struct gecko_msg_le_gap_set_advertise_configuration_cmd_t    cmd_le_gap_set_advertise_configuration;
    struct gecko_msg_le_gap_set_advertise_configuration_rsp_t    rsp_le_gap_set_advertise_configuration;
    struct gecko_msg_le_gap_clear_advertise_configuration_cmd_t  cmd_le_gap_clear_advertise_configuration;
    struct gecko_msg_le_gap_clear_advertise_configuration_rsp_t  rsp_le_gap_clear_advertise_configuration;
    struct gecko_msg_le_gap_start_advertising_cmd_t              cmd_le_gap_start_advertising;
    struct gecko_msg_le_gap_start_advertising_rsp_t              rsp_le_gap_start_advertising;
    struct gecko_msg_le_gap_stop_advertising_cmd_t               cmd_le_gap_stop_advertising;
    struct gecko_msg_le_gap_stop_advertising_rsp_t               rsp_le_gap_stop_advertising;
    struct gecko_msg_le_gap_set_discovery_timing_cmd_t           cmd_le_gap_set_discovery_timing;
    struct gecko_msg_le_gap_set_discovery_timing_rsp_t           rsp_le_gap_set_discovery_timing;
    struct gecko_msg_le_gap_set_discovery_type_cmd_t             cmd_le_gap_set_discovery_type;
    struct gecko_msg_le_gap_set_discovery_type_rsp_t             rsp_le_gap_set_discovery_type;
    struct gecko_msg_le_gap_start_discovery_cmd_t                cmd_le_gap_start_discovery;
    struct gecko_msg_le_gap_start_discovery_rsp_t                rsp_le_gap_start_discovery;
    struct gecko_msg_le_gap_set_data_channel_classification_cmd_t cmd_le_gap_set_data_channel_classification;
    struct gecko_msg_le_gap_set_data_channel_classification_rsp_t rsp_le_gap_set_data_channel_classification;
    struct gecko_msg_le_gap_connect_cmd_t                        cmd_le_gap_connect;
    struct gecko_msg_le_gap_connect_rsp_t                        rsp_le_gap_connect;
    struct gecko_msg_le_gap_set_advertise_tx_power_cmd_t         cmd_le_gap_set_advertise_tx_power;
    struct gecko_msg_le_gap_set_advertise_tx_power_rsp_t         rsp_le_gap_set_advertise_tx_power;
    struct gecko_msg_le_gap_set_discovery_extended_scan_response_cmd_t cmd_le_gap_set_discovery_extended_scan_response;
    struct gecko_msg_le_gap_set_discovery_extended_scan_response_rsp_t rsp_le_gap_set_discovery_extended_scan_response;
    struct gecko_msg_le_gap_start_periodic_advertising_cmd_t     cmd_le_gap_start_periodic_advertising;
    struct gecko_msg_le_gap_start_periodic_advertising_rsp_t     rsp_le_gap_start_periodic_advertising;
    struct gecko_msg_le_gap_stop_periodic_advertising_cmd_t      cmd_le_gap_stop_periodic_advertising;
    struct gecko_msg_le_gap_stop_periodic_advertising_rsp_t      rsp_le_gap_stop_periodic_advertising;
    struct gecko_msg_le_gap_set_long_advertising_data_cmd_t      cmd_le_gap_set_long_advertising_data;
    struct gecko_msg_le_gap_set_long_advertising_data_rsp_t      rsp_le_gap_set_long_advertising_data;
    struct gecko_msg_le_gap_enable_whitelisting_cmd_t            cmd_le_gap_enable_whitelisting;
    struct gecko_msg_le_gap_enable_whitelisting_rsp_t            rsp_le_gap_enable_whitelisting;
    struct gecko_msg_le_gap_set_conn_timing_parameters_cmd_t     cmd_le_gap_set_conn_timing_parameters;
    struct gecko_msg_le_gap_set_conn_timing_parameters_rsp_t     rsp_le_gap_set_conn_timing_parameters;
    struct gecko_msg_le_gap_set_advertise_random_address_cmd_t   cmd_le_gap_set_advertise_random_address;
    struct gecko_msg_le_gap_set_advertise_random_address_rsp_t   rsp_le_gap_set_advertise_random_address;
    struct gecko_msg_le_gap_clear_advertise_random_address_cmd_t cmd_le_gap_clear_advertise_random_address;
    struct gecko_msg_le_gap_clear_advertise_random_address_rsp_t rsp_le_gap_clear_advertise_random_address;
    struct gecko_msg_le_gap_scan_response_evt_t                  evt_le_gap_scan_response;
    struct gecko_msg_le_gap_adv_timeout_evt_t                    evt_le_gap_adv_timeout;
    struct gecko_msg_le_gap_scan_request_evt_t                   evt_le_gap_scan_request;
    struct gecko_msg_le_gap_extended_scan_response_evt_t         evt_le_gap_extended_scan_response;
    struct gecko_msg_le_gap_periodic_advertising_status_evt_t    evt_le_gap_periodic_advertising_status;
    struct gecko_msg_sync_open_cmd_t                             cmd_sync_open;
    struct gecko_msg_sync_open_rsp_t                             rsp_sync_open;
    struct gecko_msg_sync_close_cmd_t                            cmd_sync_close;
    struct gecko_msg_sync_close_rsp_t                            rsp_sync_close;
    struct gecko_msg_sync_opened_evt_t                           evt_sync_opened;
    struct gecko_msg_sync_closed_evt_t                           evt_sync_closed;
    struct gecko_msg_sync_data_evt_t                             evt_sync_data;
    struct gecko_msg_le_connection_set_parameters_cmd_t          cmd_le_connection_set_parameters;
    struct gecko_msg_le_connection_set_parameters_rsp_t          rsp_le_connection_set_parameters;
    struct gecko_msg_le_connection_get_rssi_cmd_t                cmd_le_connection_get_rssi;
    struct gecko_msg_le_connection_get_rssi_rsp_t                rsp_le_connection_get_rssi;
    struct gecko_msg_le_connection_disable_slave_latency_cmd_t   cmd_le_connection_disable_slave_latency;
    struct gecko_msg_le_connection_disable_slave_latency_rsp_t   rsp_le_connection_disable_slave_latency;
    struct gecko_msg_le_connection_set_phy_cmd_t                 cmd_le_connection_set_phy;
    struct gecko_msg_le_connection_set_phy_rsp_t                 rsp_le_connection_set_phy;
    struct gecko_msg_le_connection_close_cmd_t                   cmd_le_connection_close;
    struct gecko_msg_le_connection_close_rsp_t                   rsp_le_connection_close;
    struct gecko_msg_le_connection_set_timing_parameters_cmd_t   cmd_le_connection_set_timing_parameters;
    struct gecko_msg_le_connection_set_timing_parameters_rsp_t   rsp_le_connection_set_timing_parameters;
    struct gecko_msg_le_connection_read_channel_map_cmd_t        cmd_le_connection_read_channel_map;
    struct gecko_msg_le_connection_read_channel_map_rsp_t        rsp_le_connection_read_channel_map;
    struct gecko_msg_le_connection_set_preferred_phy_cmd_t       cmd_le_connection_set_preferred_phy;
    struct gecko_msg_le_connection_set_preferred_phy_rsp_t       rsp_le_connection_set_preferred_phy;
    struct gecko_msg_le_connection_opened_evt_t                  evt_le_connection_opened;
    struct gecko_msg_le_connection_closed_evt_t                  evt_le_connection_closed;
    struct gecko_msg_le_connection_parameters_evt_t              evt_le_connection_parameters;
    struct gecko_msg_le_connection_rssi_evt_t                    evt_le_connection_rssi;
    struct gecko_msg_le_connection_phy_status_evt_t              evt_le_connection_phy_status;
    struct gecko_msg_gatt_set_max_mtu_cmd_t                      cmd_gatt_set_max_mtu;
    struct gecko_msg_gatt_set_max_mtu_rsp_t                      rsp_gatt_set_max_mtu;
    struct gecko_msg_gatt_discover_primary_services_cmd_t        cmd_gatt_discover_primary_services;
    struct gecko_msg_gatt_discover_primary_services_rsp_t        rsp_gatt_discover_primary_services;
    struct gecko_msg_gatt_discover_primary_services_by_uuid_cmd_t cmd_gatt_discover_primary_services_by_uuid;
    struct gecko_msg_gatt_discover_primary_services_by_uuid_rsp_t rsp_gatt_discover_primary_services_by_uuid;
    struct gecko_msg_gatt_discover_characteristics_cmd_t         cmd_gatt_discover_characteristics;
    struct gecko_msg_gatt_discover_characteristics_rsp_t         rsp_gatt_discover_characteristics;
    struct gecko_msg_gatt_discover_characteristics_by_uuid_cmd_t cmd_gatt_discover_characteristics_by_uuid;
    struct gecko_msg_gatt_discover_characteristics_by_uuid_rsp_t rsp_gatt_discover_characteristics_by_uuid;
    struct gecko_msg_gatt_set_characteristic_notification_cmd_t  cmd_gatt_set_characteristic_notification;
    struct gecko_msg_gatt_set_characteristic_notification_rsp_t  rsp_gatt_set_characteristic_notification;
    struct gecko_msg_gatt_discover_descriptors_cmd_t             cmd_gatt_discover_descriptors;
    struct gecko_msg_gatt_discover_descriptors_rsp_t             rsp_gatt_discover_descriptors;
    struct gecko_msg_gatt_read_characteristic_value_cmd_t        cmd_gatt_read_characteristic_value;
    struct gecko_msg_gatt_read_characteristic_value_rsp_t        rsp_gatt_read_characteristic_value;
    struct gecko_msg_gatt_read_characteristic_value_by_uuid_cmd_t cmd_gatt_read_characteristic_value_by_uuid;
    struct gecko_msg_gatt_read_characteristic_value_by_uuid_rsp_t rsp_gatt_read_characteristic_value_by_uuid;
    struct gecko_msg_gatt_write_characteristic_value_cmd_t       cmd_gatt_write_characteristic_value;
    struct gecko_msg_gatt_write_characteristic_value_rsp_t       rsp_gatt_write_characteristic_value;
    struct gecko_msg_gatt_write_characteristic_value_without_response_cmd_t cmd_gatt_write_characteristic_value_without_response;
    struct gecko_msg_gatt_write_characteristic_value_without_response_rsp_t rsp_gatt_write_characteristic_value_without_response;
    struct gecko_msg_gatt_prepare_characteristic_value_write_cmd_t cmd_gatt_prepare_characteristic_value_write;
    struct gecko_msg_gatt_prepare_characteristic_value_write_rsp_t rsp_gatt_prepare_characteristic_value_write;
    struct gecko_msg_gatt_execute_characteristic_value_write_cmd_t cmd_gatt_execute_characteristic_value_write;
    struct gecko_msg_gatt_execute_characteristic_value_write_rsp_t rsp_gatt_execute_characteristic_value_write;
    struct gecko_msg_gatt_send_characteristic_confirmation_cmd_t cmd_gatt_send_characteristic_confirmation;
    struct gecko_msg_gatt_send_characteristic_confirmation_rsp_t rsp_gatt_send_characteristic_confirmation;
    struct gecko_msg_gatt_read_descriptor_value_cmd_t            cmd_gatt_read_descriptor_value;
    struct gecko_msg_gatt_read_descriptor_value_rsp_t            rsp_gatt_read_descriptor_value;
    struct gecko_msg_gatt_write_descriptor_value_cmd_t           cmd_gatt_write_descriptor_value;
    struct gecko_msg_gatt_write_descriptor_value_rsp_t           rsp_gatt_write_descriptor_value;
    struct gecko_msg_gatt_find_included_services_cmd_t           cmd_gatt_find_included_services;
    struct gecko_msg_gatt_find_included_services_rsp_t           rsp_gatt_find_included_services;
    struct gecko_msg_gatt_read_multiple_characteristic_values_cmd_t cmd_gatt_read_multiple_characteristic_values;
    struct gecko_msg_gatt_read_multiple_characteristic_values_rsp_t rsp_gatt_read_multiple_characteristic_values;
    struct gecko_msg_gatt_read_characteristic_value_from_offset_cmd_t cmd_gatt_read_characteristic_value_from_offset;
    struct gecko_msg_gatt_read_characteristic_value_from_offset_rsp_t rsp_gatt_read_characteristic_value_from_offset;
    struct gecko_msg_gatt_prepare_characteristic_value_reliable_write_cmd_t cmd_gatt_prepare_characteristic_value_reliable_write;
    struct gecko_msg_gatt_prepare_characteristic_value_reliable_write_rsp_t rsp_gatt_prepare_characteristic_value_reliable_write;
    struct gecko_msg_gatt_mtu_exchanged_evt_t                    evt_gatt_mtu_exchanged;
    struct gecko_msg_gatt_service_evt_t                          evt_gatt_service;
    struct gecko_msg_gatt_characteristic_evt_t                   evt_gatt_characteristic;
    struct gecko_msg_gatt_descriptor_evt_t                       evt_gatt_descriptor;
    struct gecko_msg_gatt_characteristic_value_evt_t             evt_gatt_characteristic_value;
    struct gecko_msg_gatt_descriptor_value_evt_t                 evt_gatt_descriptor_value;
    struct gecko_msg_gatt_procedure_completed_evt_t              evt_gatt_procedure_completed;
    struct gecko_msg_gatt_server_read_attribute_value_cmd_t      cmd_gatt_server_read_attribute_value;
    struct gecko_msg_gatt_server_read_attribute_value_rsp_t      rsp_gatt_server_read_attribute_value;
    struct gecko_msg_gatt_server_read_attribute_type_cmd_t       cmd_gatt_server_read_attribute_type;
    struct gecko_msg_gatt_server_read_attribute_type_rsp_t       rsp_gatt_server_read_attribute_type;
    struct gecko_msg_gatt_server_write_attribute_value_cmd_t     cmd_gatt_server_write_attribute_value;
    struct gecko_msg_gatt_server_write_attribute_value_rsp_t     rsp_gatt_server_write_attribute_value;
    struct gecko_msg_gatt_server_send_user_read_response_cmd_t   cmd_gatt_server_send_user_read_response;
    struct gecko_msg_gatt_server_send_user_read_response_rsp_t   rsp_gatt_server_send_user_read_response;
    struct gecko_msg_gatt_server_send_user_write_response_cmd_t  cmd_gatt_server_send_user_write_response;
    struct gecko_msg_gatt_server_send_user_write_response_rsp_t  rsp_gatt_server_send_user_write_response;
    struct gecko_msg_gatt_server_send_characteristic_notification_cmd_t cmd_gatt_server_send_characteristic_notification;
    struct gecko_msg_gatt_server_send_characteristic_notification_rsp_t rsp_gatt_server_send_characteristic_notification;
    struct gecko_msg_gatt_server_find_attribute_cmd_t            cmd_gatt_server_find_attribute;
    struct gecko_msg_gatt_server_find_attribute_rsp_t            rsp_gatt_server_find_attribute;
    struct gecko_msg_gatt_server_set_capabilities_cmd_t          cmd_gatt_server_set_capabilities;
    struct gecko_msg_gatt_server_set_capabilities_rsp_t          rsp_gatt_server_set_capabilities;
    struct gecko_msg_gatt_server_set_max_mtu_cmd_t               cmd_gatt_server_set_max_mtu;
    struct gecko_msg_gatt_server_set_max_mtu_rsp_t               rsp_gatt_server_set_max_mtu;
    struct gecko_msg_gatt_server_get_mtu_cmd_t                   cmd_gatt_server_get_mtu;
    struct gecko_msg_gatt_server_get_mtu_rsp_t                   rsp_gatt_server_get_mtu;
    struct gecko_msg_gatt_server_enable_capabilities_cmd_t       cmd_gatt_server_enable_capabilities;
    struct gecko_msg_gatt_server_enable_capabilities_rsp_t       rsp_gatt_server_enable_capabilities;
    struct gecko_msg_gatt_server_disable_capabilities_cmd_t      cmd_gatt_server_disable_capabilities;
    struct gecko_msg_gatt_server_disable_capabilities_rsp_t      rsp_gatt_server_disable_capabilities;
    struct gecko_msg_gatt_server_get_enabled_capabilities_rsp_t  rsp_gatt_server_get_enabled_capabilities;
    struct gecko_msg_gatt_server_attribute_value_evt_t           evt_gatt_server_attribute_value;
    struct gecko_msg_gatt_server_user_read_request_evt_t         evt_gatt_server_user_read_request;
    struct gecko_msg_gatt_server_user_write_request_evt_t        evt_gatt_server_user_write_request;
    struct gecko_msg_gatt_server_characteristic_status_evt_t     evt_gatt_server_characteristic_status;
    struct gecko_msg_gatt_server_execute_write_completed_evt_t   evt_gatt_server_execute_write_completed;
    struct gecko_msg_hardware_set_soft_timer_cmd_t               cmd_hardware_set_soft_timer;
    struct gecko_msg_hardware_set_soft_timer_rsp_t               rsp_hardware_set_soft_timer;
    struct gecko_msg_hardware_get_time_rsp_t                     rsp_hardware_get_time;
    struct gecko_msg_hardware_set_lazy_soft_timer_cmd_t          cmd_hardware_set_lazy_soft_timer;
    struct gecko_msg_hardware_set_lazy_soft_timer_rsp_t          rsp_hardware_set_lazy_soft_timer;
    struct gecko_msg_hardware_soft_timer_evt_t                   evt_hardware_soft_timer;
    struct gecko_msg_flash_ps_erase_all_rsp_t                    rsp_flash_ps_erase_all;
    struct gecko_msg_flash_ps_save_cmd_t                         cmd_flash_ps_save;
    struct gecko_msg_flash_ps_save_rsp_t                         rsp_flash_ps_save;
    struct gecko_msg_flash_ps_load_cmd_t                         cmd_flash_ps_load;
    struct gecko_msg_flash_ps_load_rsp_t                         rsp_flash_ps_load;
    struct gecko_msg_flash_ps_erase_cmd_t                        cmd_flash_ps_erase;
    struct gecko_msg_flash_ps_erase_rsp_t                        rsp_flash_ps_erase;
    struct gecko_msg_test_dtm_tx_cmd_t                           cmd_test_dtm_tx;
    struct gecko_msg_test_dtm_tx_rsp_t                           rsp_test_dtm_tx;
    struct gecko_msg_test_dtm_rx_cmd_t                           cmd_test_dtm_rx;
    struct gecko_msg_test_dtm_rx_rsp_t                           rsp_test_dtm_rx;
    struct gecko_msg_test_dtm_end_rsp_t                          rsp_test_dtm_end;
    struct gecko_msg_test_dtm_completed_evt_t                    evt_test_dtm_completed;
    struct gecko_msg_sm_set_bondable_mode_cmd_t                  cmd_sm_set_bondable_mode;
    struct gecko_msg_sm_set_bondable_mode_rsp_t                  rsp_sm_set_bondable_mode;
    struct gecko_msg_sm_configure_cmd_t                          cmd_sm_configure;
    struct gecko_msg_sm_configure_rsp_t                          rsp_sm_configure;
    struct gecko_msg_sm_store_bonding_configuration_cmd_t        cmd_sm_store_bonding_configuration;
    struct gecko_msg_sm_store_bonding_configuration_rsp_t        rsp_sm_store_bonding_configuration;
    struct gecko_msg_sm_increase_security_cmd_t                  cmd_sm_increase_security;
    struct gecko_msg_sm_increase_security_rsp_t                  rsp_sm_increase_security;
    struct gecko_msg_sm_delete_bonding_cmd_t                     cmd_sm_delete_bonding;
    struct gecko_msg_sm_delete_bonding_rsp_t                     rsp_sm_delete_bonding;
    struct gecko_msg_sm_delete_bondings_rsp_t                    rsp_sm_delete_bondings;
    struct gecko_msg_sm_enter_passkey_cmd_t                      cmd_sm_enter_passkey;
    struct gecko_msg_sm_enter_passkey_rsp_t                      rsp_sm_enter_passkey;
    struct gecko_msg_sm_passkey_confirm_cmd_t                    cmd_sm_passkey_confirm;
    struct gecko_msg_sm_passkey_confirm_rsp_t                    rsp_sm_passkey_confirm;
    struct gecko_msg_sm_set_oob_data_cmd_t                       cmd_sm_set_oob_data;
    struct gecko_msg_sm_set_oob_data_rsp_t                       rsp_sm_set_oob_data;
    struct gecko_msg_sm_list_all_bondings_rsp_t                  rsp_sm_list_all_bondings;
    struct gecko_msg_sm_bonding_confirm_cmd_t                    cmd_sm_bonding_confirm;
    struct gecko_msg_sm_bonding_confirm_rsp_t                    rsp_sm_bonding_confirm;
    struct gecko_msg_sm_set_debug_mode_rsp_t                     rsp_sm_set_debug_mode;
    struct gecko_msg_sm_set_passkey_cmd_t                        cmd_sm_set_passkey;
    struct gecko_msg_sm_set_passkey_rsp_t                        rsp_sm_set_passkey;
    struct gecko_msg_sm_use_sc_oob_cmd_t                         cmd_sm_use_sc_oob;
    struct gecko_msg_sm_use_sc_oob_rsp_t                         rsp_sm_use_sc_oob;
    struct gecko_msg_sm_set_sc_remote_oob_data_cmd_t             cmd_sm_set_sc_remote_oob_data;
    struct gecko_msg_sm_set_sc_remote_oob_data_rsp_t             rsp_sm_set_sc_remote_oob_data;
    struct gecko_msg_sm_add_to_whitelist_cmd_t                   cmd_sm_add_to_whitelist;
    struct gecko_msg_sm_add_to_whitelist_rsp_t                   rsp_sm_add_to_whitelist;
    struct gecko_msg_sm_set_minimum_key_size_cmd_t               cmd_sm_set_minimum_key_size;
    struct gecko_msg_sm_set_minimum_key_size_rsp_t               rsp_sm_set_minimum_key_size;
    struct gecko_msg_sm_passkey_display_evt_t                    evt_sm_passkey_display;
    struct gecko_msg_sm_passkey_request_evt_t                    evt_sm_passkey_request;
    struct gecko_msg_sm_confirm_passkey_evt_t                    evt_sm_confirm_passkey;
    struct gecko_msg_sm_bonded_evt_t                             evt_sm_bonded;
    struct gecko_msg_sm_bonding_failed_evt_t                     evt_sm_bonding_failed;
    struct gecko_msg_sm_list_bonding_entry_evt_t                 evt_sm_list_bonding_entry;
    struct gecko_msg_sm_confirm_bonding_evt_t                    evt_sm_confirm_bonding;
    struct gecko_msg_homekit_configure_cmd_t                     cmd_homekit_configure;
    struct gecko_msg_homekit_configure_rsp_t                     rsp_homekit_configure;
    struct gecko_msg_homekit_advertise_cmd_t                     cmd_homekit_advertise;
    struct gecko_msg_homekit_advertise_rsp_t                     rsp_homekit_advertise;
    struct gecko_msg_homekit_delete_pairings_rsp_t               rsp_homekit_delete_pairings;
    struct gecko_msg_homekit_check_authcp_rsp_t                  rsp_homekit_check_authcp;
    struct gecko_msg_homekit_get_pairing_id_cmd_t                cmd_homekit_get_pairing_id;
    struct gecko_msg_homekit_get_pairing_id_rsp_t                rsp_homekit_get_pairing_id;
    struct gecko_msg_homekit_send_write_response_cmd_t           cmd_homekit_send_write_response;
    struct gecko_msg_homekit_send_write_response_rsp_t           rsp_homekit_send_write_response;
    struct gecko_msg_homekit_send_read_response_cmd_t            cmd_homekit_send_read_response;
    struct gecko_msg_homekit_send_read_response_rsp_t            rsp_homekit_send_read_response;
    struct gecko_msg_homekit_gsn_action_cmd_t                    cmd_homekit_gsn_action;
    struct gecko_msg_homekit_gsn_action_rsp_t                    rsp_homekit_gsn_action;
    struct gecko_msg_homekit_event_notification_cmd_t            cmd_homekit_event_notification;
    struct gecko_msg_homekit_event_notification_rsp_t            rsp_homekit_event_notification;
    struct gecko_msg_homekit_broadcast_action_cmd_t              cmd_homekit_broadcast_action;
    struct gecko_msg_homekit_broadcast_action_rsp_t              rsp_homekit_broadcast_action;
    struct gecko_msg_homekit_configure_product_data_cmd_t        cmd_homekit_configure_product_data;
    struct gecko_msg_homekit_configure_product_data_rsp_t        rsp_homekit_configure_product_data;
    struct gecko_msg_homekit_setupcode_display_evt_t             evt_homekit_setupcode_display;
    struct gecko_msg_homekit_paired_evt_t                        evt_homekit_paired;
    struct gecko_msg_homekit_pair_verified_evt_t                 evt_homekit_pair_verified;
    struct gecko_msg_homekit_connection_opened_evt_t             evt_homekit_connection_opened;
    struct gecko_msg_homekit_connection_closed_evt_t             evt_homekit_connection_closed;
    struct gecko_msg_homekit_identify_evt_t                      evt_homekit_identify;
    struct gecko_msg_homekit_write_request_evt_t                 evt_homekit_write_request;
    struct gecko_msg_homekit_read_request_evt_t                  evt_homekit_read_request;
    struct gecko_msg_homekit_disconnection_required_evt_t        evt_homekit_disconnection_required;
    struct gecko_msg_homekit_pairing_removed_evt_t               evt_homekit_pairing_removed;
    struct gecko_msg_homekit_setuppayload_display_evt_t          evt_homekit_setuppayload_display;
    struct gecko_msg_mesh_node_init_rsp_t                        rsp_mesh_node_init;
    struct gecko_msg_mesh_node_start_unprov_beaconing_cmd_t      cmd_mesh_node_start_unprov_beaconing;
    struct gecko_msg_mesh_node_start_unprov_beaconing_rsp_t      rsp_mesh_node_start_unprov_beaconing;
    struct gecko_msg_mesh_node_stop_unprov_beaconing_rsp_t       rsp_mesh_node_stop_unprov_beaconing;
    struct gecko_msg_mesh_node_rssi_rsp_t                        rsp_mesh_node_rssi;
    struct gecko_msg_mesh_node_input_oob_request_rsp_cmd_t       cmd_mesh_node_input_oob_request_rsp;
    struct gecko_msg_mesh_node_input_oob_request_rsp_rsp_t       rsp_mesh_node_input_oob_request_rsp;
    struct gecko_msg_mesh_node_get_uuid_rsp_t                    rsp_mesh_node_get_uuid;
    struct gecko_msg_mesh_node_set_provisioning_data_cmd_t       cmd_mesh_node_set_provisioning_data;
    struct gecko_msg_mesh_node_set_provisioning_data_rsp_t       rsp_mesh_node_set_provisioning_data;
    struct gecko_msg_mesh_node_init_oob_cmd_t                    cmd_mesh_node_init_oob;
    struct gecko_msg_mesh_node_init_oob_rsp_t                    rsp_mesh_node_init_oob;
    struct gecko_msg_mesh_node_set_ivrecovery_mode_cmd_t         cmd_mesh_node_set_ivrecovery_mode;
    struct gecko_msg_mesh_node_set_ivrecovery_mode_rsp_t         rsp_mesh_node_set_ivrecovery_mode;
    struct gecko_msg_mesh_node_get_ivrecovery_mode_rsp_t         rsp_mesh_node_get_ivrecovery_mode;
    struct gecko_msg_mesh_node_set_adv_event_filter_cmd_t        cmd_mesh_node_set_adv_event_filter;
    struct gecko_msg_mesh_node_set_adv_event_filter_rsp_t        rsp_mesh_node_set_adv_event_filter;
    struct gecko_msg_mesh_node_get_statistics_rsp_t              rsp_mesh_node_get_statistics;
    struct gecko_msg_mesh_node_clear_statistics_rsp_t            rsp_mesh_node_clear_statistics;
    struct gecko_msg_mesh_node_set_net_relay_delay_cmd_t         cmd_mesh_node_set_net_relay_delay;
    struct gecko_msg_mesh_node_set_net_relay_delay_rsp_t         rsp_mesh_node_set_net_relay_delay;
    struct gecko_msg_mesh_node_get_net_relay_delay_rsp_t         rsp_mesh_node_get_net_relay_delay;
    struct gecko_msg_mesh_node_get_ivupdate_state_rsp_t          rsp_mesh_node_get_ivupdate_state;
    struct gecko_msg_mesh_node_request_ivupdate_rsp_t            rsp_mesh_node_request_ivupdate;
    struct gecko_msg_mesh_node_get_seq_remaining_cmd_t           cmd_mesh_node_get_seq_remaining;
    struct gecko_msg_mesh_node_get_seq_remaining_rsp_t           rsp_mesh_node_get_seq_remaining;
    struct gecko_msg_mesh_node_save_replay_protection_list_rsp_t rsp_mesh_node_save_replay_protection_list;
    struct gecko_msg_mesh_node_set_uuid_cmd_t                    cmd_mesh_node_set_uuid;
    struct gecko_msg_mesh_node_set_uuid_rsp_t                    rsp_mesh_node_set_uuid;
    struct gecko_msg_mesh_node_get_element_address_cmd_t         cmd_mesh_node_get_element_address;
    struct gecko_msg_mesh_node_get_element_address_rsp_t         rsp_mesh_node_get_element_address;
    struct gecko_msg_mesh_node_static_oob_request_rsp_cmd_t      cmd_mesh_node_static_oob_request_rsp;
    struct gecko_msg_mesh_node_static_oob_request_rsp_rsp_t      rsp_mesh_node_static_oob_request_rsp;
    struct gecko_msg_mesh_node_reset_rsp_t                       rsp_mesh_node_reset;
    struct gecko_msg_mesh_node_set_beacon_reporting_cmd_t        cmd_mesh_node_set_beacon_reporting;
    struct gecko_msg_mesh_node_set_beacon_reporting_rsp_t        rsp_mesh_node_set_beacon_reporting;
    struct gecko_msg_mesh_node_set_iv_update_age_cmd_t           cmd_mesh_node_set_iv_update_age;
    struct gecko_msg_mesh_node_set_iv_update_age_rsp_t           rsp_mesh_node_set_iv_update_age;
    struct gecko_msg_mesh_node_initialized_evt_t                 evt_mesh_node_initialized;
    struct gecko_msg_mesh_node_provisioned_evt_t                 evt_mesh_node_provisioned;
    struct gecko_msg_mesh_node_config_get_evt_t                  evt_mesh_node_config_get;
    struct gecko_msg_mesh_node_config_set_evt_t                  evt_mesh_node_config_set;
    struct gecko_msg_mesh_node_display_output_oob_evt_t          evt_mesh_node_display_output_oob;
    struct gecko_msg_mesh_node_input_oob_request_evt_t           evt_mesh_node_input_oob_request;
    struct gecko_msg_mesh_node_provisioning_started_evt_t        evt_mesh_node_provisioning_started;
    struct gecko_msg_mesh_node_provisioning_failed_evt_t         evt_mesh_node_provisioning_failed;
    struct gecko_msg_mesh_node_key_added_evt_t                   evt_mesh_node_key_added;
    struct gecko_msg_mesh_node_model_config_changed_evt_t        evt_mesh_node_model_config_changed;
    struct gecko_msg_mesh_node_ivrecovery_needed_evt_t           evt_mesh_node_ivrecovery_needed;
    struct gecko_msg_mesh_node_changed_ivupdate_state_evt_t      evt_mesh_node_changed_ivupdate_state;
    struct gecko_msg_mesh_node_key_removed_evt_t                 evt_mesh_node_key_removed;
    struct gecko_msg_mesh_node_key_updated_evt_t                 evt_mesh_node_key_updated;
    struct gecko_msg_mesh_node_heartbeat_evt_t                   evt_mesh_node_heartbeat;
    struct gecko_msg_mesh_node_heartbeat_start_evt_t             evt_mesh_node_heartbeat_start;
    struct gecko_msg_mesh_node_heartbeat_stop_evt_t              evt_mesh_node_heartbeat_stop;
    struct gecko_msg_mesh_node_beacon_received_evt_t             evt_mesh_node_beacon_received;
    struct gecko_msg_mesh_prov_init_rsp_t                        rsp_mesh_prov_init;
    struct gecko_msg_mesh_prov_scan_unprov_beacons_rsp_t         rsp_mesh_prov_scan_unprov_beacons;
    struct gecko_msg_mesh_prov_provision_device_cmd_t            cmd_mesh_prov_provision_device;
    struct gecko_msg_mesh_prov_provision_device_rsp_t            rsp_mesh_prov_provision_device;
    struct gecko_msg_mesh_prov_create_network_cmd_t              cmd_mesh_prov_create_network;
    struct gecko_msg_mesh_prov_create_network_rsp_t              rsp_mesh_prov_create_network;
    struct gecko_msg_mesh_prov_get_dcd_cmd_t                     cmd_mesh_prov_get_dcd;
    struct gecko_msg_mesh_prov_get_dcd_rsp_t                     rsp_mesh_prov_get_dcd;
    struct gecko_msg_mesh_prov_get_config_cmd_t                  cmd_mesh_prov_get_config;
    struct gecko_msg_mesh_prov_get_config_rsp_t                  rsp_mesh_prov_get_config;
    struct gecko_msg_mesh_prov_set_config_cmd_t                  cmd_mesh_prov_set_config;
    struct gecko_msg_mesh_prov_set_config_rsp_t                  rsp_mesh_prov_set_config;
    struct gecko_msg_mesh_prov_create_appkey_cmd_t               cmd_mesh_prov_create_appkey;
    struct gecko_msg_mesh_prov_create_appkey_rsp_t               rsp_mesh_prov_create_appkey;
    struct gecko_msg_mesh_prov_oob_pkey_rsp_cmd_t                cmd_mesh_prov_oob_pkey_rsp;
    struct gecko_msg_mesh_prov_oob_pkey_rsp_rsp_t                rsp_mesh_prov_oob_pkey_rsp;
    struct gecko_msg_mesh_prov_oob_auth_rsp_cmd_t                cmd_mesh_prov_oob_auth_rsp;
    struct gecko_msg_mesh_prov_oob_auth_rsp_rsp_t                rsp_mesh_prov_oob_auth_rsp;
    struct gecko_msg_mesh_prov_set_oob_requirements_cmd_t        cmd_mesh_prov_set_oob_requirements;
    struct gecko_msg_mesh_prov_set_oob_requirements_rsp_t        rsp_mesh_prov_set_oob_requirements;
    struct gecko_msg_mesh_prov_key_refresh_start_cmd_t           cmd_mesh_prov_key_refresh_start;
    struct gecko_msg_mesh_prov_key_refresh_start_rsp_t           rsp_mesh_prov_key_refresh_start;
    struct gecko_msg_mesh_prov_get_key_refresh_blacklist_cmd_t   cmd_mesh_prov_get_key_refresh_blacklist;
    struct gecko_msg_mesh_prov_get_key_refresh_blacklist_rsp_t   rsp_mesh_prov_get_key_refresh_blacklist;
    struct gecko_msg_mesh_prov_set_key_refresh_blacklist_cmd_t   cmd_mesh_prov_set_key_refresh_blacklist;
    struct gecko_msg_mesh_prov_set_key_refresh_blacklist_rsp_t   rsp_mesh_prov_set_key_refresh_blacklist;
    struct gecko_msg_mesh_prov_appkey_add_cmd_t                  cmd_mesh_prov_appkey_add;
    struct gecko_msg_mesh_prov_appkey_add_rsp_t                  rsp_mesh_prov_appkey_add;
    struct gecko_msg_mesh_prov_appkey_delete_cmd_t               cmd_mesh_prov_appkey_delete;
    struct gecko_msg_mesh_prov_appkey_delete_rsp_t               rsp_mesh_prov_appkey_delete;
    struct gecko_msg_mesh_prov_model_app_bind_cmd_t              cmd_mesh_prov_model_app_bind;
    struct gecko_msg_mesh_prov_model_app_bind_rsp_t              rsp_mesh_prov_model_app_bind;
    struct gecko_msg_mesh_prov_model_app_unbind_cmd_t            cmd_mesh_prov_model_app_unbind;
    struct gecko_msg_mesh_prov_model_app_unbind_rsp_t            rsp_mesh_prov_model_app_unbind;
    struct gecko_msg_mesh_prov_model_app_get_cmd_t               cmd_mesh_prov_model_app_get;
    struct gecko_msg_mesh_prov_model_app_get_rsp_t               rsp_mesh_prov_model_app_get;
    struct gecko_msg_mesh_prov_model_sub_add_cmd_t               cmd_mesh_prov_model_sub_add;
    struct gecko_msg_mesh_prov_model_sub_add_rsp_t               rsp_mesh_prov_model_sub_add;
    struct gecko_msg_mesh_prov_model_pub_set_cmd_t               cmd_mesh_prov_model_pub_set;
    struct gecko_msg_mesh_prov_model_pub_set_rsp_t               rsp_mesh_prov_model_pub_set;
    struct gecko_msg_mesh_prov_provision_gatt_device_cmd_t       cmd_mesh_prov_provision_gatt_device;
    struct gecko_msg_mesh_prov_provision_gatt_device_rsp_t       rsp_mesh_prov_provision_gatt_device;
    struct gecko_msg_mesh_prov_ddb_get_cmd_t                     cmd_mesh_prov_ddb_get;
    struct gecko_msg_mesh_prov_ddb_get_rsp_t                     rsp_mesh_prov_ddb_get;
    struct gecko_msg_mesh_prov_ddb_delete_cmd_t                  cmd_mesh_prov_ddb_delete;
    struct gecko_msg_mesh_prov_ddb_delete_rsp_t                  rsp_mesh_prov_ddb_delete;
    struct gecko_msg_mesh_prov_ddb_add_cmd_t                     cmd_mesh_prov_ddb_add;
    struct gecko_msg_mesh_prov_ddb_add_rsp_t                     rsp_mesh_prov_ddb_add;
    struct gecko_msg_mesh_prov_ddb_list_devices_rsp_t            rsp_mesh_prov_ddb_list_devices;
    struct gecko_msg_mesh_prov_network_add_cmd_t                 cmd_mesh_prov_network_add;
    struct gecko_msg_mesh_prov_network_add_rsp_t                 rsp_mesh_prov_network_add;
    struct gecko_msg_mesh_prov_network_delete_cmd_t              cmd_mesh_prov_network_delete;
    struct gecko_msg_mesh_prov_network_delete_rsp_t              rsp_mesh_prov_network_delete;
    struct gecko_msg_mesh_prov_nettx_get_cmd_t                   cmd_mesh_prov_nettx_get;
    struct gecko_msg_mesh_prov_nettx_get_rsp_t                   rsp_mesh_prov_nettx_get;
    struct gecko_msg_mesh_prov_nettx_set_cmd_t                   cmd_mesh_prov_nettx_set;
    struct gecko_msg_mesh_prov_nettx_set_rsp_t                   rsp_mesh_prov_nettx_set;
    struct gecko_msg_mesh_prov_model_sub_del_cmd_t               cmd_mesh_prov_model_sub_del;
    struct gecko_msg_mesh_prov_model_sub_del_rsp_t               rsp_mesh_prov_model_sub_del;
    struct gecko_msg_mesh_prov_model_sub_add_va_cmd_t            cmd_mesh_prov_model_sub_add_va;
    struct gecko_msg_mesh_prov_model_sub_add_va_rsp_t            rsp_mesh_prov_model_sub_add_va;
    struct gecko_msg_mesh_prov_model_sub_del_va_cmd_t            cmd_mesh_prov_model_sub_del_va;
    struct gecko_msg_mesh_prov_model_sub_del_va_rsp_t            rsp_mesh_prov_model_sub_del_va;
    struct gecko_msg_mesh_prov_model_sub_set_cmd_t               cmd_mesh_prov_model_sub_set;
    struct gecko_msg_mesh_prov_model_sub_set_rsp_t               rsp_mesh_prov_model_sub_set;
    struct gecko_msg_mesh_prov_model_sub_set_va_cmd_t            cmd_mesh_prov_model_sub_set_va;
    struct gecko_msg_mesh_prov_model_sub_set_va_rsp_t            rsp_mesh_prov_model_sub_set_va;
    struct gecko_msg_mesh_prov_heartbeat_publication_get_cmd_t   cmd_mesh_prov_heartbeat_publication_get;
    struct gecko_msg_mesh_prov_heartbeat_publication_get_rsp_t   rsp_mesh_prov_heartbeat_publication_get;
    struct gecko_msg_mesh_prov_heartbeat_publication_set_cmd_t   cmd_mesh_prov_heartbeat_publication_set;
    struct gecko_msg_mesh_prov_heartbeat_publication_set_rsp_t   rsp_mesh_prov_heartbeat_publication_set;
    struct gecko_msg_mesh_prov_heartbeat_subscription_get_cmd_t  cmd_mesh_prov_heartbeat_subscription_get;
    struct gecko_msg_mesh_prov_heartbeat_subscription_get_rsp_t  rsp_mesh_prov_heartbeat_subscription_get;
    struct gecko_msg_mesh_prov_heartbeat_subscription_set_cmd_t  cmd_mesh_prov_heartbeat_subscription_set;
    struct gecko_msg_mesh_prov_heartbeat_subscription_set_rsp_t  rsp_mesh_prov_heartbeat_subscription_set;
    struct gecko_msg_mesh_prov_relay_get_cmd_t                   cmd_mesh_prov_relay_get;
    struct gecko_msg_mesh_prov_relay_get_rsp_t                   rsp_mesh_prov_relay_get;
    struct gecko_msg_mesh_prov_relay_set_cmd_t                   cmd_mesh_prov_relay_set;
    struct gecko_msg_mesh_prov_relay_set_rsp_t                   rsp_mesh_prov_relay_set;
    struct gecko_msg_mesh_prov_reset_node_cmd_t                  cmd_mesh_prov_reset_node;
    struct gecko_msg_mesh_prov_reset_node_rsp_t                  rsp_mesh_prov_reset_node;
    struct gecko_msg_mesh_prov_appkey_get_cmd_t                  cmd_mesh_prov_appkey_get;
    struct gecko_msg_mesh_prov_appkey_get_rsp_t                  rsp_mesh_prov_appkey_get;
    struct gecko_msg_mesh_prov_network_get_cmd_t                 cmd_mesh_prov_network_get;
    struct gecko_msg_mesh_prov_network_get_rsp_t                 rsp_mesh_prov_network_get;
    struct gecko_msg_mesh_prov_model_sub_clear_cmd_t             cmd_mesh_prov_model_sub_clear;
    struct gecko_msg_mesh_prov_model_sub_clear_rsp_t             rsp_mesh_prov_model_sub_clear;
    struct gecko_msg_mesh_prov_model_pub_get_cmd_t               cmd_mesh_prov_model_pub_get;
    struct gecko_msg_mesh_prov_model_pub_get_rsp_t               rsp_mesh_prov_model_pub_get;
    struct gecko_msg_mesh_prov_model_pub_set_va_cmd_t            cmd_mesh_prov_model_pub_set_va;
    struct gecko_msg_mesh_prov_model_pub_set_va_rsp_t            rsp_mesh_prov_model_pub_set_va;
    struct gecko_msg_mesh_prov_model_pub_set_cred_cmd_t          cmd_mesh_prov_model_pub_set_cred;
    struct gecko_msg_mesh_prov_model_pub_set_cred_rsp_t          rsp_mesh_prov_model_pub_set_cred;
    struct gecko_msg_mesh_prov_model_pub_set_va_cred_cmd_t       cmd_mesh_prov_model_pub_set_va_cred;
    struct gecko_msg_mesh_prov_model_pub_set_va_cred_rsp_t       rsp_mesh_prov_model_pub_set_va_cred;
    struct gecko_msg_mesh_prov_model_sub_get_cmd_t               cmd_mesh_prov_model_sub_get;
    struct gecko_msg_mesh_prov_model_sub_get_rsp_t               rsp_mesh_prov_model_sub_get;
    struct gecko_msg_mesh_prov_friend_timeout_get_cmd_t          cmd_mesh_prov_friend_timeout_get;
    struct gecko_msg_mesh_prov_friend_timeout_get_rsp_t          rsp_mesh_prov_friend_timeout_get;
    struct gecko_msg_mesh_prov_get_default_configuration_timeout_rsp_t rsp_mesh_prov_get_default_configuration_timeout;
    struct gecko_msg_mesh_prov_set_default_configuration_timeout_cmd_t cmd_mesh_prov_set_default_configuration_timeout;
    struct gecko_msg_mesh_prov_set_default_configuration_timeout_rsp_t rsp_mesh_prov_set_default_configuration_timeout;
    struct gecko_msg_mesh_prov_provision_device_with_address_cmd_t cmd_mesh_prov_provision_device_with_address;
    struct gecko_msg_mesh_prov_provision_device_with_address_rsp_t rsp_mesh_prov_provision_device_with_address;
    struct gecko_msg_mesh_prov_provision_gatt_device_with_address_cmd_t cmd_mesh_prov_provision_gatt_device_with_address;
    struct gecko_msg_mesh_prov_provision_gatt_device_with_address_rsp_t rsp_mesh_prov_provision_gatt_device_with_address;
    struct gecko_msg_mesh_prov_initialize_network_cmd_t          cmd_mesh_prov_initialize_network;
    struct gecko_msg_mesh_prov_initialize_network_rsp_t          rsp_mesh_prov_initialize_network;
    struct gecko_msg_mesh_prov_get_key_refresh_appkey_blacklist_cmd_t cmd_mesh_prov_get_key_refresh_appkey_blacklist;
    struct gecko_msg_mesh_prov_get_key_refresh_appkey_blacklist_rsp_t rsp_mesh_prov_get_key_refresh_appkey_blacklist;
    struct gecko_msg_mesh_prov_set_key_refresh_appkey_blacklist_cmd_t cmd_mesh_prov_set_key_refresh_appkey_blacklist;
    struct gecko_msg_mesh_prov_set_key_refresh_appkey_blacklist_rsp_t rsp_mesh_prov_set_key_refresh_appkey_blacklist;
    struct gecko_msg_mesh_prov_stop_scan_unprov_beacons_rsp_t    rsp_mesh_prov_stop_scan_unprov_beacons;
    struct gecko_msg_mesh_prov_ddb_update_netkey_index_cmd_t     cmd_mesh_prov_ddb_update_netkey_index;
    struct gecko_msg_mesh_prov_ddb_update_netkey_index_rsp_t     rsp_mesh_prov_ddb_update_netkey_index;
    struct gecko_msg_mesh_prov_key_refresh_suspend_cmd_t         cmd_mesh_prov_key_refresh_suspend;
    struct gecko_msg_mesh_prov_key_refresh_suspend_rsp_t         rsp_mesh_prov_key_refresh_suspend;
    struct gecko_msg_mesh_prov_key_refresh_resume_cmd_t          cmd_mesh_prov_key_refresh_resume;
    struct gecko_msg_mesh_prov_key_refresh_resume_rsp_t          rsp_mesh_prov_key_refresh_resume;
    struct gecko_msg_mesh_prov_get_key_refresh_phase_cmd_t       cmd_mesh_prov_get_key_refresh_phase;
    struct gecko_msg_mesh_prov_get_key_refresh_phase_rsp_t       rsp_mesh_prov_get_key_refresh_phase;
    struct gecko_msg_mesh_prov_key_refresh_start_from_phase_cmd_t cmd_mesh_prov_key_refresh_start_from_phase;
    struct gecko_msg_mesh_prov_key_refresh_start_from_phase_rsp_t rsp_mesh_prov_key_refresh_start_from_phase;
    struct gecko_msg_mesh_prov_flush_key_refresh_state_cmd_t     cmd_mesh_prov_flush_key_refresh_state;
    struct gecko_msg_mesh_prov_flush_key_refresh_state_rsp_t     rsp_mesh_prov_flush_key_refresh_state;
    struct gecko_msg_mesh_prov_initialized_evt_t                 evt_mesh_prov_initialized;
    struct gecko_msg_mesh_prov_provisioning_failed_evt_t         evt_mesh_prov_provisioning_failed;
    struct gecko_msg_mesh_prov_device_provisioned_evt_t          evt_mesh_prov_device_provisioned;
    struct gecko_msg_mesh_prov_unprov_beacon_evt_t               evt_mesh_prov_unprov_beacon;
    struct gecko_msg_mesh_prov_dcd_status_evt_t                  evt_mesh_prov_dcd_status;
    struct gecko_msg_mesh_prov_config_status_evt_t               evt_mesh_prov_config_status;
    struct gecko_msg_mesh_prov_oob_pkey_request_evt_t            evt_mesh_prov_oob_pkey_request;
    struct gecko_msg_mesh_prov_oob_auth_request_evt_t            evt_mesh_prov_oob_auth_request;
    struct gecko_msg_mesh_prov_oob_display_input_evt_t           evt_mesh_prov_oob_display_input;
    struct gecko_msg_mesh_prov_ddb_list_evt_t                    evt_mesh_prov_ddb_list;
    struct gecko_msg_mesh_prov_heartbeat_publication_status_evt_t evt_mesh_prov_heartbeat_publication_status;
    struct gecko_msg_mesh_prov_heartbeat_subscription_status_evt_t evt_mesh_prov_heartbeat_subscription_status;
    struct gecko_msg_mesh_prov_relay_status_evt_t                evt_mesh_prov_relay_status;
    struct gecko_msg_mesh_prov_uri_evt_t                         evt_mesh_prov_uri;
    struct gecko_msg_mesh_prov_node_reset_evt_t                  evt_mesh_prov_node_reset;
    struct gecko_msg_mesh_prov_appkey_list_evt_t                 evt_mesh_prov_appkey_list;
    struct gecko_msg_mesh_prov_appkey_list_end_evt_t             evt_mesh_prov_appkey_list_end;
    struct gecko_msg_mesh_prov_network_list_evt_t                evt_mesh_prov_network_list;
    struct gecko_msg_mesh_prov_network_list_end_evt_t            evt_mesh_prov_network_list_end;
    struct gecko_msg_mesh_prov_model_pub_status_evt_t            evt_mesh_prov_model_pub_status;
    struct gecko_msg_mesh_prov_key_refresh_phase_update_evt_t    evt_mesh_prov_key_refresh_phase_update;
    struct gecko_msg_mesh_prov_key_refresh_node_update_evt_t     evt_mesh_prov_key_refresh_node_update;
    struct gecko_msg_mesh_prov_key_refresh_complete_evt_t        evt_mesh_prov_key_refresh_complete;
    struct gecko_msg_mesh_prov_model_sub_addr_evt_t              evt_mesh_prov_model_sub_addr;
    struct gecko_msg_mesh_prov_model_sub_addr_end_evt_t          evt_mesh_prov_model_sub_addr_end;
    struct gecko_msg_mesh_prov_friend_timeout_status_evt_t       evt_mesh_prov_friend_timeout_status;
    struct gecko_msg_mesh_proxy_connect_cmd_t                    cmd_mesh_proxy_connect;
    struct gecko_msg_mesh_proxy_connect_rsp_t                    rsp_mesh_proxy_connect;
    struct gecko_msg_mesh_proxy_disconnect_cmd_t                 cmd_mesh_proxy_disconnect;
    struct gecko_msg_mesh_proxy_disconnect_rsp_t                 rsp_mesh_proxy_disconnect;
    struct gecko_msg_mesh_proxy_set_filter_type_cmd_t            cmd_mesh_proxy_set_filter_type;
    struct gecko_msg_mesh_proxy_set_filter_type_rsp_t            rsp_mesh_proxy_set_filter_type;
    struct gecko_msg_mesh_proxy_allow_cmd_t                      cmd_mesh_proxy_allow;
    struct gecko_msg_mesh_proxy_allow_rsp_t                      rsp_mesh_proxy_allow;
    struct gecko_msg_mesh_proxy_deny_cmd_t                       cmd_mesh_proxy_deny;
    struct gecko_msg_mesh_proxy_deny_rsp_t                       rsp_mesh_proxy_deny;
    struct gecko_msg_mesh_proxy_connected_evt_t                  evt_mesh_proxy_connected;
    struct gecko_msg_mesh_proxy_disconnected_evt_t               evt_mesh_proxy_disconnected;
    struct gecko_msg_mesh_proxy_filter_status_evt_t              evt_mesh_proxy_filter_status;
    struct gecko_msg_mesh_vendor_model_send_cmd_t                cmd_mesh_vendor_model_send;
    struct gecko_msg_mesh_vendor_model_send_rsp_t                rsp_mesh_vendor_model_send;
    struct gecko_msg_mesh_vendor_model_set_publication_cmd_t     cmd_mesh_vendor_model_set_publication;
    struct gecko_msg_mesh_vendor_model_set_publication_rsp_t     rsp_mesh_vendor_model_set_publication;
    struct gecko_msg_mesh_vendor_model_clear_publication_cmd_t   cmd_mesh_vendor_model_clear_publication;
    struct gecko_msg_mesh_vendor_model_clear_publication_rsp_t   rsp_mesh_vendor_model_clear_publication;
    struct gecko_msg_mesh_vendor_model_publish_cmd_t             cmd_mesh_vendor_model_publish;
    struct gecko_msg_mesh_vendor_model_publish_rsp_t             rsp_mesh_vendor_model_publish;
    struct gecko_msg_mesh_vendor_model_init_cmd_t                cmd_mesh_vendor_model_init;
    struct gecko_msg_mesh_vendor_model_init_rsp_t                rsp_mesh_vendor_model_init;
    struct gecko_msg_mesh_vendor_model_deinit_cmd_t              cmd_mesh_vendor_model_deinit;
    struct gecko_msg_mesh_vendor_model_deinit_rsp_t              rsp_mesh_vendor_model_deinit;
    struct gecko_msg_mesh_vendor_model_receive_evt_t             evt_mesh_vendor_model_receive;
    struct gecko_msg_mesh_health_client_get_cmd_t                cmd_mesh_health_client_get;
    struct gecko_msg_mesh_health_client_get_rsp_t                rsp_mesh_health_client_get;
    struct gecko_msg_mesh_health_client_clear_cmd_t              cmd_mesh_health_client_clear;
    struct gecko_msg_mesh_health_client_clear_rsp_t              rsp_mesh_health_client_clear;
    struct gecko_msg_mesh_health_client_test_cmd_t               cmd_mesh_health_client_test;
    struct gecko_msg_mesh_health_client_test_rsp_t               rsp_mesh_health_client_test;
    struct gecko_msg_mesh_health_client_get_period_cmd_t         cmd_mesh_health_client_get_period;
    struct gecko_msg_mesh_health_client_get_period_rsp_t         rsp_mesh_health_client_get_period;
    struct gecko_msg_mesh_health_client_set_period_cmd_t         cmd_mesh_health_client_set_period;
    struct gecko_msg_mesh_health_client_set_period_rsp_t         rsp_mesh_health_client_set_period;
    struct gecko_msg_mesh_health_client_get_attention_cmd_t      cmd_mesh_health_client_get_attention;
    struct gecko_msg_mesh_health_client_get_attention_rsp_t      rsp_mesh_health_client_get_attention;
    struct gecko_msg_mesh_health_client_set_attention_cmd_t      cmd_mesh_health_client_set_attention;
    struct gecko_msg_mesh_health_client_set_attention_rsp_t      rsp_mesh_health_client_set_attention;
    struct gecko_msg_mesh_health_client_server_status_evt_t      evt_mesh_health_client_server_status;
    struct gecko_msg_mesh_health_client_server_status_period_evt_t evt_mesh_health_client_server_status_period;
    struct gecko_msg_mesh_health_client_server_status_attention_evt_t evt_mesh_health_client_server_status_attention;
    struct gecko_msg_mesh_health_server_set_fault_cmd_t          cmd_mesh_health_server_set_fault;
    struct gecko_msg_mesh_health_server_set_fault_rsp_t          rsp_mesh_health_server_set_fault;
    struct gecko_msg_mesh_health_server_clear_fault_cmd_t        cmd_mesh_health_server_clear_fault;
    struct gecko_msg_mesh_health_server_clear_fault_rsp_t        rsp_mesh_health_server_clear_fault;
    struct gecko_msg_mesh_health_server_test_response_cmd_t      cmd_mesh_health_server_test_response;
    struct gecko_msg_mesh_health_server_test_response_rsp_t      rsp_mesh_health_server_test_response;
    struct gecko_msg_mesh_health_server_attention_evt_t          evt_mesh_health_server_attention;
    struct gecko_msg_mesh_health_server_test_request_evt_t       evt_mesh_health_server_test_request;
    struct gecko_msg_mesh_generic_client_get_cmd_t               cmd_mesh_generic_client_get;
    struct gecko_msg_mesh_generic_client_get_rsp_t               rsp_mesh_generic_client_get;
    struct gecko_msg_mesh_generic_client_set_cmd_t               cmd_mesh_generic_client_set;
    struct gecko_msg_mesh_generic_client_set_rsp_t               rsp_mesh_generic_client_set;
    struct gecko_msg_mesh_generic_client_publish_cmd_t           cmd_mesh_generic_client_publish;
    struct gecko_msg_mesh_generic_client_publish_rsp_t           rsp_mesh_generic_client_publish;
    struct gecko_msg_mesh_generic_client_get_params_cmd_t        cmd_mesh_generic_client_get_params;
    struct gecko_msg_mesh_generic_client_get_params_rsp_t        rsp_mesh_generic_client_get_params;
    struct gecko_msg_mesh_generic_client_init_rsp_t              rsp_mesh_generic_client_init;
    struct gecko_msg_mesh_generic_client_init_common_rsp_t       rsp_mesh_generic_client_init_common;
    struct gecko_msg_mesh_generic_client_init_on_off_rsp_t       rsp_mesh_generic_client_init_on_off;
    struct gecko_msg_mesh_generic_client_init_level_rsp_t        rsp_mesh_generic_client_init_level;
    struct gecko_msg_mesh_generic_client_init_default_transition_time_rsp_t rsp_mesh_generic_client_init_default_transition_time;
    struct gecko_msg_mesh_generic_client_init_power_on_off_rsp_t rsp_mesh_generic_client_init_power_on_off;
    struct gecko_msg_mesh_generic_client_init_power_level_rsp_t  rsp_mesh_generic_client_init_power_level;
    struct gecko_msg_mesh_generic_client_init_battery_rsp_t      rsp_mesh_generic_client_init_battery;
    struct gecko_msg_mesh_generic_client_init_location_rsp_t     rsp_mesh_generic_client_init_location;
    struct gecko_msg_mesh_generic_client_init_property_rsp_t     rsp_mesh_generic_client_init_property;
    struct gecko_msg_mesh_generic_client_init_lightness_rsp_t    rsp_mesh_generic_client_init_lightness;
    struct gecko_msg_mesh_generic_client_init_ctl_rsp_t          rsp_mesh_generic_client_init_ctl;
    struct gecko_msg_mesh_generic_client_server_status_evt_t     evt_mesh_generic_client_server_status;
    struct gecko_msg_mesh_generic_server_response_cmd_t          cmd_mesh_generic_server_response;
    struct gecko_msg_mesh_generic_server_response_rsp_t          rsp_mesh_generic_server_response;
    struct gecko_msg_mesh_generic_server_update_cmd_t            cmd_mesh_generic_server_update;
    struct gecko_msg_mesh_generic_server_update_rsp_t            rsp_mesh_generic_server_update;
    struct gecko_msg_mesh_generic_server_publish_cmd_t           cmd_mesh_generic_server_publish;
    struct gecko_msg_mesh_generic_server_publish_rsp_t           rsp_mesh_generic_server_publish;
    struct gecko_msg_mesh_generic_server_init_rsp_t              rsp_mesh_generic_server_init;
    struct gecko_msg_mesh_generic_server_init_common_rsp_t       rsp_mesh_generic_server_init_common;
    struct gecko_msg_mesh_generic_server_init_on_off_rsp_t       rsp_mesh_generic_server_init_on_off;
    struct gecko_msg_mesh_generic_server_init_level_rsp_t        rsp_mesh_generic_server_init_level;
    struct gecko_msg_mesh_generic_server_init_default_transition_time_rsp_t rsp_mesh_generic_server_init_default_transition_time;
    struct gecko_msg_mesh_generic_server_init_power_on_off_rsp_t rsp_mesh_generic_server_init_power_on_off;
    struct gecko_msg_mesh_generic_server_init_power_level_rsp_t  rsp_mesh_generic_server_init_power_level;
    struct gecko_msg_mesh_generic_server_init_battery_rsp_t      rsp_mesh_generic_server_init_battery;
    struct gecko_msg_mesh_generic_server_init_location_rsp_t     rsp_mesh_generic_server_init_location;
    struct gecko_msg_mesh_generic_server_init_property_rsp_t     rsp_mesh_generic_server_init_property;
    struct gecko_msg_mesh_generic_server_init_lightness_rsp_t    rsp_mesh_generic_server_init_lightness;
    struct gecko_msg_mesh_generic_server_init_ctl_rsp_t          rsp_mesh_generic_server_init_ctl;
    struct gecko_msg_mesh_generic_server_client_request_evt_t    evt_mesh_generic_server_client_request;
    struct gecko_msg_mesh_generic_server_state_changed_evt_t     evt_mesh_generic_server_state_changed;
    struct gecko_msg_mesh_generic_server_state_recall_evt_t      evt_mesh_generic_server_state_recall;
    struct gecko_msg_coex_set_options_cmd_t                      cmd_coex_set_options;
    struct gecko_msg_coex_set_options_rsp_t                      rsp_coex_set_options;
    struct gecko_msg_coex_get_counters_cmd_t                     cmd_coex_get_counters;
    struct gecko_msg_coex_get_counters_rsp_t                     rsp_coex_get_counters;
    struct gecko_msg_coex_set_parameters_cmd_t                   cmd_coex_set_parameters;
    struct gecko_msg_coex_set_parameters_rsp_t                   rsp_coex_set_parameters;
    struct gecko_msg_coex_set_directional_priority_pulse_cmd_t   cmd_coex_set_directional_priority_pulse;
    struct gecko_msg_coex_set_directional_priority_pulse_rsp_t   rsp_coex_set_directional_priority_pulse;
    struct gecko_msg_mesh_test_get_nettx_rsp_t                   rsp_mesh_test_get_nettx;
    struct gecko_msg_mesh_test_set_nettx_cmd_t                   cmd_mesh_test_set_nettx;
    struct gecko_msg_mesh_test_set_nettx_rsp_t                   rsp_mesh_test_set_nettx;
    struct gecko_msg_mesh_test_get_relay_rsp_t                   rsp_mesh_test_get_relay;
    struct gecko_msg_mesh_test_set_relay_cmd_t                   cmd_mesh_test_set_relay;
    struct gecko_msg_mesh_test_set_relay_rsp_t                   rsp_mesh_test_set_relay;
    struct gecko_msg_mesh_test_set_adv_scan_params_cmd_t         cmd_mesh_test_set_adv_scan_params;
    struct gecko_msg_mesh_test_set_adv_scan_params_rsp_t         rsp_mesh_test_set_adv_scan_params;
    struct gecko_msg_mesh_test_set_ivupdate_test_mode_cmd_t      cmd_mesh_test_set_ivupdate_test_mode;
    struct gecko_msg_mesh_test_set_ivupdate_test_mode_rsp_t      rsp_mesh_test_set_ivupdate_test_mode;
    struct gecko_msg_mesh_test_get_ivupdate_test_mode_rsp_t      rsp_mesh_test_get_ivupdate_test_mode;
    struct gecko_msg_mesh_test_set_segment_send_delay_cmd_t      cmd_mesh_test_set_segment_send_delay;
    struct gecko_msg_mesh_test_set_segment_send_delay_rsp_t      rsp_mesh_test_set_segment_send_delay;
    struct gecko_msg_mesh_test_set_ivupdate_state_cmd_t          cmd_mesh_test_set_ivupdate_state;
    struct gecko_msg_mesh_test_set_ivupdate_state_rsp_t          rsp_mesh_test_set_ivupdate_state;
    struct gecko_msg_mesh_test_send_beacons_rsp_t                rsp_mesh_test_send_beacons;
    struct gecko_msg_mesh_test_bind_local_model_app_cmd_t        cmd_mesh_test_bind_local_model_app;
    struct gecko_msg_mesh_test_bind_local_model_app_rsp_t        rsp_mesh_test_bind_local_model_app;
    struct gecko_msg_mesh_test_unbind_local_model_app_cmd_t      cmd_mesh_test_unbind_local_model_app;
    struct gecko_msg_mesh_test_unbind_local_model_app_rsp_t      rsp_mesh_test_unbind_local_model_app;
    struct gecko_msg_mesh_test_add_local_model_sub_cmd_t         cmd_mesh_test_add_local_model_sub;
    struct gecko_msg_mesh_test_add_local_model_sub_rsp_t         rsp_mesh_test_add_local_model_sub;
    struct gecko_msg_mesh_test_del_local_model_sub_cmd_t         cmd_mesh_test_del_local_model_sub;
    struct gecko_msg_mesh_test_del_local_model_sub_rsp_t         rsp_mesh_test_del_local_model_sub;
    struct gecko_msg_mesh_test_add_local_model_sub_va_cmd_t      cmd_mesh_test_add_local_model_sub_va;
    struct gecko_msg_mesh_test_add_local_model_sub_va_rsp_t      rsp_mesh_test_add_local_model_sub_va;
    struct gecko_msg_mesh_test_del_local_model_sub_va_cmd_t      cmd_mesh_test_del_local_model_sub_va;
    struct gecko_msg_mesh_test_del_local_model_sub_va_rsp_t      rsp_mesh_test_del_local_model_sub_va;
    struct gecko_msg_mesh_test_get_local_model_sub_cmd_t         cmd_mesh_test_get_local_model_sub;
    struct gecko_msg_mesh_test_get_local_model_sub_rsp_t         rsp_mesh_test_get_local_model_sub;
    struct gecko_msg_mesh_test_set_local_model_pub_cmd_t         cmd_mesh_test_set_local_model_pub;
    struct gecko_msg_mesh_test_set_local_model_pub_rsp_t         rsp_mesh_test_set_local_model_pub;
    struct gecko_msg_mesh_test_set_local_model_pub_va_cmd_t      cmd_mesh_test_set_local_model_pub_va;
    struct gecko_msg_mesh_test_set_local_model_pub_va_rsp_t      rsp_mesh_test_set_local_model_pub_va;
    struct gecko_msg_mesh_test_get_local_model_pub_cmd_t         cmd_mesh_test_get_local_model_pub;
    struct gecko_msg_mesh_test_get_local_model_pub_rsp_t         rsp_mesh_test_get_local_model_pub;
    struct gecko_msg_mesh_test_set_local_heartbeat_subscription_cmd_t cmd_mesh_test_set_local_heartbeat_subscription;
    struct gecko_msg_mesh_test_set_local_heartbeat_subscription_rsp_t rsp_mesh_test_set_local_heartbeat_subscription;
    struct gecko_msg_mesh_test_get_local_heartbeat_subscription_rsp_t rsp_mesh_test_get_local_heartbeat_subscription;
    struct gecko_msg_mesh_test_get_local_heartbeat_publication_rsp_t rsp_mesh_test_get_local_heartbeat_publication;
    struct gecko_msg_mesh_test_set_local_heartbeat_publication_cmd_t cmd_mesh_test_set_local_heartbeat_publication;
    struct gecko_msg_mesh_test_set_local_heartbeat_publication_rsp_t rsp_mesh_test_set_local_heartbeat_publication;
    struct gecko_msg_mesh_test_set_local_config_cmd_t            cmd_mesh_test_set_local_config;
    struct gecko_msg_mesh_test_set_local_config_rsp_t            rsp_mesh_test_set_local_config;
    struct gecko_msg_mesh_test_get_local_config_cmd_t            cmd_mesh_test_get_local_config;
    struct gecko_msg_mesh_test_get_local_config_rsp_t            rsp_mesh_test_get_local_config;
    struct gecko_msg_mesh_test_add_local_key_cmd_t               cmd_mesh_test_add_local_key;
    struct gecko_msg_mesh_test_add_local_key_rsp_t               rsp_mesh_test_add_local_key;
    struct gecko_msg_mesh_test_del_local_key_cmd_t               cmd_mesh_test_del_local_key;
    struct gecko_msg_mesh_test_del_local_key_rsp_t               rsp_mesh_test_del_local_key;
    struct gecko_msg_mesh_test_update_local_key_cmd_t            cmd_mesh_test_update_local_key;
    struct gecko_msg_mesh_test_update_local_key_rsp_t            rsp_mesh_test_update_local_key;
    struct gecko_msg_mesh_test_set_sar_config_cmd_t              cmd_mesh_test_set_sar_config;
    struct gecko_msg_mesh_test_set_sar_config_rsp_t              rsp_mesh_test_set_sar_config;
    struct gecko_msg_mesh_test_get_element_seqnum_cmd_t          cmd_mesh_test_get_element_seqnum;
    struct gecko_msg_mesh_test_get_element_seqnum_rsp_t          rsp_mesh_test_get_element_seqnum;
    struct gecko_msg_mesh_test_set_adv_bearer_state_cmd_t        cmd_mesh_test_set_adv_bearer_state;
    struct gecko_msg_mesh_test_set_adv_bearer_state_rsp_t        rsp_mesh_test_set_adv_bearer_state;
    struct gecko_msg_mesh_test_get_key_count_cmd_t               cmd_mesh_test_get_key_count;
    struct gecko_msg_mesh_test_get_key_count_rsp_t               rsp_mesh_test_get_key_count;
    struct gecko_msg_mesh_test_get_key_cmd_t                     cmd_mesh_test_get_key;
    struct gecko_msg_mesh_test_get_key_rsp_t                     rsp_mesh_test_get_key;
    struct gecko_msg_mesh_test_prov_get_device_key_cmd_t         cmd_mesh_test_prov_get_device_key;
    struct gecko_msg_mesh_test_prov_get_device_key_rsp_t         rsp_mesh_test_prov_get_device_key;
    struct gecko_msg_mesh_test_prov_prepare_key_refresh_cmd_t    cmd_mesh_test_prov_prepare_key_refresh;
    struct gecko_msg_mesh_test_prov_prepare_key_refresh_rsp_t    rsp_mesh_test_prov_prepare_key_refresh;
    struct gecko_msg_mesh_test_cancel_segmented_tx_cmd_t         cmd_mesh_test_cancel_segmented_tx;
    struct gecko_msg_mesh_test_cancel_segmented_tx_rsp_t         rsp_mesh_test_cancel_segmented_tx;
    struct gecko_msg_mesh_test_set_iv_index_cmd_t                cmd_mesh_test_set_iv_index;
    struct gecko_msg_mesh_test_set_iv_index_rsp_t                rsp_mesh_test_set_iv_index;
    struct gecko_msg_mesh_test_set_element_seqnum_cmd_t          cmd_mesh_test_set_element_seqnum;
    struct gecko_msg_mesh_test_set_element_seqnum_rsp_t          rsp_mesh_test_set_element_seqnum;
    struct gecko_msg_mesh_test_set_model_option_cmd_t            cmd_mesh_test_set_model_option;
    struct gecko_msg_mesh_test_set_model_option_rsp_t            rsp_mesh_test_set_model_option;
    struct gecko_msg_mesh_test_get_local_model_app_bindings_cmd_t cmd_mesh_test_get_local_model_app_bindings;
    struct gecko_msg_mesh_test_get_local_model_app_bindings_rsp_t rsp_mesh_test_get_local_model_app_bindings;
    struct gecko_msg_mesh_test_local_heartbeat_subscription_complete_evt_t evt_mesh_test_local_heartbeat_subscription_complete;
    struct gecko_msg_mesh_lpn_init_rsp_t                         rsp_mesh_lpn_init;
    struct gecko_msg_mesh_lpn_deinit_rsp_t                       rsp_mesh_lpn_deinit;
    struct gecko_msg_mesh_lpn_configure_cmd_t                    cmd_mesh_lpn_configure;
    struct gecko_msg_mesh_lpn_configure_rsp_t                    rsp_mesh_lpn_configure;
    struct gecko_msg_mesh_lpn_establish_friendship_cmd_t         cmd_mesh_lpn_establish_friendship;
    struct gecko_msg_mesh_lpn_establish_friendship_rsp_t         rsp_mesh_lpn_establish_friendship;
    struct gecko_msg_mesh_lpn_poll_rsp_t                         rsp_mesh_lpn_poll;
    struct gecko_msg_mesh_lpn_terminate_friendship_rsp_t         rsp_mesh_lpn_terminate_friendship;
    struct gecko_msg_mesh_lpn_config_cmd_t                       cmd_mesh_lpn_config;
    struct gecko_msg_mesh_lpn_config_rsp_t                       rsp_mesh_lpn_config;
    struct gecko_msg_mesh_lpn_friendship_established_evt_t       evt_mesh_lpn_friendship_established;
    struct gecko_msg_mesh_lpn_friendship_failed_evt_t            evt_mesh_lpn_friendship_failed;
    struct gecko_msg_mesh_lpn_friendship_terminated_evt_t        evt_mesh_lpn_friendship_terminated;
    struct gecko_msg_mesh_friend_init_rsp_t                      rsp_mesh_friend_init;
    struct gecko_msg_mesh_friend_deinit_rsp_t                    rsp_mesh_friend_deinit;
    struct gecko_msg_mesh_friend_friendship_established_evt_t    evt_mesh_friend_friendship_established;
    struct gecko_msg_mesh_friend_friendship_terminated_evt_t     evt_mesh_friend_friendship_terminated;
    struct gecko_msg_mesh_config_client_cancel_request_cmd_t     cmd_mesh_config_client_cancel_request;
    struct gecko_msg_mesh_config_client_cancel_request_rsp_t     rsp_mesh_config_client_cancel_request;
    struct gecko_msg_mesh_config_client_get_request_status_cmd_t cmd_mesh_config_client_get_request_status;
    struct gecko_msg_mesh_config_client_get_request_status_rsp_t rsp_mesh_config_client_get_request_status;
    struct gecko_msg_mesh_config_client_get_default_timeout_rsp_t rsp_mesh_config_client_get_default_timeout;
    struct gecko_msg_mesh_config_client_set_default_timeout_cmd_t cmd_mesh_config_client_set_default_timeout;
    struct gecko_msg_mesh_config_client_set_default_timeout_rsp_t rsp_mesh_config_client_set_default_timeout;
    struct gecko_msg_mesh_config_client_add_netkey_cmd_t         cmd_mesh_config_client_add_netkey;
    struct gecko_msg_mesh_config_client_add_netkey_rsp_t         rsp_mesh_config_client_add_netkey;
    struct gecko_msg_mesh_config_client_remove_netkey_cmd_t      cmd_mesh_config_client_remove_netkey;
    struct gecko_msg_mesh_config_client_remove_netkey_rsp_t      rsp_mesh_config_client_remove_netkey;
    struct gecko_msg_mesh_config_client_list_netkeys_cmd_t       cmd_mesh_config_client_list_netkeys;
    struct gecko_msg_mesh_config_client_list_netkeys_rsp_t       rsp_mesh_config_client_list_netkeys;
    struct gecko_msg_mesh_config_client_add_appkey_cmd_t         cmd_mesh_config_client_add_appkey;
    struct gecko_msg_mesh_config_client_add_appkey_rsp_t         rsp_mesh_config_client_add_appkey;
    struct gecko_msg_mesh_config_client_remove_appkey_cmd_t      cmd_mesh_config_client_remove_appkey;
    struct gecko_msg_mesh_config_client_remove_appkey_rsp_t      rsp_mesh_config_client_remove_appkey;
    struct gecko_msg_mesh_config_client_list_appkeys_cmd_t       cmd_mesh_config_client_list_appkeys;
    struct gecko_msg_mesh_config_client_list_appkeys_rsp_t       rsp_mesh_config_client_list_appkeys;
    struct gecko_msg_mesh_config_client_bind_model_cmd_t         cmd_mesh_config_client_bind_model;
    struct gecko_msg_mesh_config_client_bind_model_rsp_t         rsp_mesh_config_client_bind_model;
    struct gecko_msg_mesh_config_client_unbind_model_cmd_t       cmd_mesh_config_client_unbind_model;
    struct gecko_msg_mesh_config_client_unbind_model_rsp_t       rsp_mesh_config_client_unbind_model;
    struct gecko_msg_mesh_config_client_list_bindings_cmd_t      cmd_mesh_config_client_list_bindings;
    struct gecko_msg_mesh_config_client_list_bindings_rsp_t      rsp_mesh_config_client_list_bindings;
    struct gecko_msg_mesh_config_client_get_model_pub_cmd_t      cmd_mesh_config_client_get_model_pub;
    struct gecko_msg_mesh_config_client_get_model_pub_rsp_t      rsp_mesh_config_client_get_model_pub;
    struct gecko_msg_mesh_config_client_set_model_pub_cmd_t      cmd_mesh_config_client_set_model_pub;
    struct gecko_msg_mesh_config_client_set_model_pub_rsp_t      rsp_mesh_config_client_set_model_pub;
    struct gecko_msg_mesh_config_client_set_model_pub_va_cmd_t   cmd_mesh_config_client_set_model_pub_va;
    struct gecko_msg_mesh_config_client_set_model_pub_va_rsp_t   rsp_mesh_config_client_set_model_pub_va;
    struct gecko_msg_mesh_config_client_add_model_sub_cmd_t      cmd_mesh_config_client_add_model_sub;
    struct gecko_msg_mesh_config_client_add_model_sub_rsp_t      rsp_mesh_config_client_add_model_sub;
    struct gecko_msg_mesh_config_client_add_model_sub_va_cmd_t   cmd_mesh_config_client_add_model_sub_va;
    struct gecko_msg_mesh_config_client_add_model_sub_va_rsp_t   rsp_mesh_config_client_add_model_sub_va;
    struct gecko_msg_mesh_config_client_remove_model_sub_cmd_t   cmd_mesh_config_client_remove_model_sub;
    struct gecko_msg_mesh_config_client_remove_model_sub_rsp_t   rsp_mesh_config_client_remove_model_sub;
    struct gecko_msg_mesh_config_client_remove_model_sub_va_cmd_t cmd_mesh_config_client_remove_model_sub_va;
    struct gecko_msg_mesh_config_client_remove_model_sub_va_rsp_t rsp_mesh_config_client_remove_model_sub_va;
    struct gecko_msg_mesh_config_client_set_model_sub_cmd_t      cmd_mesh_config_client_set_model_sub;
    struct gecko_msg_mesh_config_client_set_model_sub_rsp_t      rsp_mesh_config_client_set_model_sub;
    struct gecko_msg_mesh_config_client_set_model_sub_va_cmd_t   cmd_mesh_config_client_set_model_sub_va;
    struct gecko_msg_mesh_config_client_set_model_sub_va_rsp_t   rsp_mesh_config_client_set_model_sub_va;
    struct gecko_msg_mesh_config_client_clear_model_sub_cmd_t    cmd_mesh_config_client_clear_model_sub;
    struct gecko_msg_mesh_config_client_clear_model_sub_rsp_t    rsp_mesh_config_client_clear_model_sub;
    struct gecko_msg_mesh_config_client_list_subs_cmd_t          cmd_mesh_config_client_list_subs;
    struct gecko_msg_mesh_config_client_list_subs_rsp_t          rsp_mesh_config_client_list_subs;
    struct gecko_msg_mesh_config_client_get_heartbeat_pub_cmd_t  cmd_mesh_config_client_get_heartbeat_pub;
    struct gecko_msg_mesh_config_client_get_heartbeat_pub_rsp_t  rsp_mesh_config_client_get_heartbeat_pub;
    struct gecko_msg_mesh_config_client_set_heartbeat_pub_cmd_t  cmd_mesh_config_client_set_heartbeat_pub;
    struct gecko_msg_mesh_config_client_set_heartbeat_pub_rsp_t  rsp_mesh_config_client_set_heartbeat_pub;
    struct gecko_msg_mesh_config_client_get_heartbeat_sub_cmd_t  cmd_mesh_config_client_get_heartbeat_sub;
    struct gecko_msg_mesh_config_client_get_heartbeat_sub_rsp_t  rsp_mesh_config_client_get_heartbeat_sub;
    struct gecko_msg_mesh_config_client_set_heartbeat_sub_cmd_t  cmd_mesh_config_client_set_heartbeat_sub;
    struct gecko_msg_mesh_config_client_set_heartbeat_sub_rsp_t  rsp_mesh_config_client_set_heartbeat_sub;
    struct gecko_msg_mesh_config_client_get_beacon_cmd_t         cmd_mesh_config_client_get_beacon;
    struct gecko_msg_mesh_config_client_get_beacon_rsp_t         rsp_mesh_config_client_get_beacon;
    struct gecko_msg_mesh_config_client_set_beacon_cmd_t         cmd_mesh_config_client_set_beacon;
    struct gecko_msg_mesh_config_client_set_beacon_rsp_t         rsp_mesh_config_client_set_beacon;
    struct gecko_msg_mesh_config_client_get_default_ttl_cmd_t    cmd_mesh_config_client_get_default_ttl;
    struct gecko_msg_mesh_config_client_get_default_ttl_rsp_t    rsp_mesh_config_client_get_default_ttl;
    struct gecko_msg_mesh_config_client_set_default_ttl_cmd_t    cmd_mesh_config_client_set_default_ttl;
    struct gecko_msg_mesh_config_client_set_default_ttl_rsp_t    rsp_mesh_config_client_set_default_ttl;
    struct gecko_msg_mesh_config_client_get_gatt_proxy_cmd_t     cmd_mesh_config_client_get_gatt_proxy;
    struct gecko_msg_mesh_config_client_get_gatt_proxy_rsp_t     rsp_mesh_config_client_get_gatt_proxy;
    struct gecko_msg_mesh_config_client_set_gatt_proxy_cmd_t     cmd_mesh_config_client_set_gatt_proxy;
    struct gecko_msg_mesh_config_client_set_gatt_proxy_rsp_t     rsp_mesh_config_client_set_gatt_proxy;
    struct gecko_msg_mesh_config_client_get_relay_cmd_t          cmd_mesh_config_client_get_relay;
    struct gecko_msg_mesh_config_client_get_relay_rsp_t          rsp_mesh_config_client_get_relay;
    struct gecko_msg_mesh_config_client_set_relay_cmd_t          cmd_mesh_config_client_set_relay;
    struct gecko_msg_mesh_config_client_set_relay_rsp_t          rsp_mesh_config_client_set_relay;
    struct gecko_msg_mesh_config_client_get_network_transmit_cmd_t cmd_mesh_config_client_get_network_transmit;
    struct gecko_msg_mesh_config_client_get_network_transmit_rsp_t rsp_mesh_config_client_get_network_transmit;
    struct gecko_msg_mesh_config_client_set_network_transmit_cmd_t cmd_mesh_config_client_set_network_transmit;
    struct gecko_msg_mesh_config_client_set_network_transmit_rsp_t rsp_mesh_config_client_set_network_transmit;
    struct gecko_msg_mesh_config_client_get_identity_cmd_t       cmd_mesh_config_client_get_identity;
    struct gecko_msg_mesh_config_client_get_identity_rsp_t       rsp_mesh_config_client_get_identity;
    struct gecko_msg_mesh_config_client_set_identity_cmd_t       cmd_mesh_config_client_set_identity;
    struct gecko_msg_mesh_config_client_set_identity_rsp_t       rsp_mesh_config_client_set_identity;
    struct gecko_msg_mesh_config_client_get_friend_cmd_t         cmd_mesh_config_client_get_friend;
    struct gecko_msg_mesh_config_client_get_friend_rsp_t         rsp_mesh_config_client_get_friend;
    struct gecko_msg_mesh_config_client_set_friend_cmd_t         cmd_mesh_config_client_set_friend;
    struct gecko_msg_mesh_config_client_set_friend_rsp_t         rsp_mesh_config_client_set_friend;
    struct gecko_msg_mesh_config_client_get_lpn_polltimeout_cmd_t cmd_mesh_config_client_get_lpn_polltimeout;
    struct gecko_msg_mesh_config_client_get_lpn_polltimeout_rsp_t rsp_mesh_config_client_get_lpn_polltimeout;
    struct gecko_msg_mesh_config_client_get_dcd_cmd_t            cmd_mesh_config_client_get_dcd;
    struct gecko_msg_mesh_config_client_get_dcd_rsp_t            rsp_mesh_config_client_get_dcd;
    struct gecko_msg_mesh_config_client_reset_node_cmd_t         cmd_mesh_config_client_reset_node;
    struct gecko_msg_mesh_config_client_reset_node_rsp_t         rsp_mesh_config_client_reset_node;
    struct gecko_msg_mesh_config_client_request_modified_evt_t   evt_mesh_config_client_request_modified;
    struct gecko_msg_mesh_config_client_netkey_status_evt_t      evt_mesh_config_client_netkey_status;
    struct gecko_msg_mesh_config_client_netkey_list_evt_t        evt_mesh_config_client_netkey_list;
    struct gecko_msg_mesh_config_client_netkey_list_end_evt_t    evt_mesh_config_client_netkey_list_end;
    struct gecko_msg_mesh_config_client_appkey_status_evt_t      evt_mesh_config_client_appkey_status;
    struct gecko_msg_mesh_config_client_appkey_list_evt_t        evt_mesh_config_client_appkey_list;
    struct gecko_msg_mesh_config_client_appkey_list_end_evt_t    evt_mesh_config_client_appkey_list_end;
    struct gecko_msg_mesh_config_client_binding_status_evt_t     evt_mesh_config_client_binding_status;
    struct gecko_msg_mesh_config_client_bindings_list_evt_t      evt_mesh_config_client_bindings_list;
    struct gecko_msg_mesh_config_client_bindings_list_end_evt_t  evt_mesh_config_client_bindings_list_end;
    struct gecko_msg_mesh_config_client_model_pub_status_evt_t   evt_mesh_config_client_model_pub_status;
    struct gecko_msg_mesh_config_client_model_sub_status_evt_t   evt_mesh_config_client_model_sub_status;
    struct gecko_msg_mesh_config_client_subs_list_evt_t          evt_mesh_config_client_subs_list;
    struct gecko_msg_mesh_config_client_subs_list_end_evt_t      evt_mesh_config_client_subs_list_end;
    struct gecko_msg_mesh_config_client_heartbeat_pub_status_evt_t evt_mesh_config_client_heartbeat_pub_status;
    struct gecko_msg_mesh_config_client_heartbeat_sub_status_evt_t evt_mesh_config_client_heartbeat_sub_status;
    struct gecko_msg_mesh_config_client_beacon_status_evt_t      evt_mesh_config_client_beacon_status;
    struct gecko_msg_mesh_config_client_default_ttl_status_evt_t evt_mesh_config_client_default_ttl_status;
    struct gecko_msg_mesh_config_client_gatt_proxy_status_evt_t  evt_mesh_config_client_gatt_proxy_status;
    struct gecko_msg_mesh_config_client_relay_status_evt_t       evt_mesh_config_client_relay_status;
    struct gecko_msg_mesh_config_client_network_transmit_status_evt_t evt_mesh_config_client_network_transmit_status;
    struct gecko_msg_mesh_config_client_identity_status_evt_t    evt_mesh_config_client_identity_status;
    struct gecko_msg_mesh_config_client_friend_status_evt_t      evt_mesh_config_client_friend_status;
    struct gecko_msg_mesh_config_client_lpn_polltimeout_status_evt_t evt_mesh_config_client_lpn_polltimeout_status;
    struct gecko_msg_mesh_config_client_dcd_data_evt_t           evt_mesh_config_client_dcd_data;
    struct gecko_msg_mesh_config_client_dcd_data_end_evt_t       evt_mesh_config_client_dcd_data_end;
    struct gecko_msg_mesh_config_client_reset_status_evt_t       evt_mesh_config_client_reset_status;
    struct gecko_msg_l2cap_coc_send_connection_request_cmd_t     cmd_l2cap_coc_send_connection_request;
    struct gecko_msg_l2cap_coc_send_connection_request_rsp_t     rsp_l2cap_coc_send_connection_request;
    struct gecko_msg_l2cap_coc_send_connection_response_cmd_t    cmd_l2cap_coc_send_connection_response;
    struct gecko_msg_l2cap_coc_send_connection_response_rsp_t    rsp_l2cap_coc_send_connection_response;
    struct gecko_msg_l2cap_coc_send_le_flow_control_credit_cmd_t cmd_l2cap_coc_send_le_flow_control_credit;
    struct gecko_msg_l2cap_coc_send_le_flow_control_credit_rsp_t rsp_l2cap_coc_send_le_flow_control_credit;
    struct gecko_msg_l2cap_coc_send_disconnection_request_cmd_t  cmd_l2cap_coc_send_disconnection_request;
    struct gecko_msg_l2cap_coc_send_disconnection_request_rsp_t  rsp_l2cap_coc_send_disconnection_request;
    struct gecko_msg_l2cap_coc_send_data_cmd_t                   cmd_l2cap_coc_send_data;
    struct gecko_msg_l2cap_coc_send_data_rsp_t                   rsp_l2cap_coc_send_data;
    struct gecko_msg_l2cap_coc_connection_request_evt_t          evt_l2cap_coc_connection_request;
    struct gecko_msg_l2cap_coc_connection_response_evt_t         evt_l2cap_coc_connection_response;
    struct gecko_msg_l2cap_coc_le_flow_control_credit_evt_t      evt_l2cap_coc_le_flow_control_credit;
    struct gecko_msg_l2cap_coc_channel_disconnected_evt_t        evt_l2cap_coc_channel_disconnected;
    struct gecko_msg_l2cap_coc_data_evt_t                        evt_l2cap_coc_data;
    struct gecko_msg_l2cap_command_rejected_evt_t                evt_l2cap_command_rejected;
    struct gecko_msg_cte_transmitter_enable_connection_cte_cmd_t cmd_cte_transmitter_enable_connection_cte;
    struct gecko_msg_cte_transmitter_enable_connection_cte_rsp_t rsp_cte_transmitter_enable_connection_cte;
    struct gecko_msg_cte_transmitter_disable_connection_cte_cmd_t cmd_cte_transmitter_disable_connection_cte;
    struct gecko_msg_cte_transmitter_disable_connection_cte_rsp_t rsp_cte_transmitter_disable_connection_cte;
    struct gecko_msg_cte_transmitter_enable_connectionless_cte_cmd_t cmd_cte_transmitter_enable_connectionless_cte;
    struct gecko_msg_cte_transmitter_enable_connectionless_cte_rsp_t rsp_cte_transmitter_enable_connectionless_cte;
    struct gecko_msg_cte_transmitter_disable_connectionless_cte_cmd_t cmd_cte_transmitter_disable_connectionless_cte;
    struct gecko_msg_cte_transmitter_disable_connectionless_cte_rsp_t rsp_cte_transmitter_disable_connectionless_cte;
    struct gecko_msg_cte_transmitter_set_dtm_parameters_cmd_t    cmd_cte_transmitter_set_dtm_parameters;
    struct gecko_msg_cte_transmitter_set_dtm_parameters_rsp_t    rsp_cte_transmitter_set_dtm_parameters;
    struct gecko_msg_cte_transmitter_clear_dtm_parameters_rsp_t  rsp_cte_transmitter_clear_dtm_parameters;
    struct gecko_msg_cte_transmitter_enable_silabs_cte_cmd_t     cmd_cte_transmitter_enable_silabs_cte;
    struct gecko_msg_cte_transmitter_enable_silabs_cte_rsp_t     rsp_cte_transmitter_enable_silabs_cte;
    struct gecko_msg_cte_transmitter_disable_silabs_cte_cmd_t    cmd_cte_transmitter_disable_silabs_cte;
    struct gecko_msg_cte_transmitter_disable_silabs_cte_rsp_t    rsp_cte_transmitter_disable_silabs_cte;
    struct gecko_msg_cte_receiver_configure_cmd_t                cmd_cte_receiver_configure;
    struct gecko_msg_cte_receiver_configure_rsp_t                rsp_cte_receiver_configure;
    struct gecko_msg_cte_receiver_enable_connection_cte_cmd_t    cmd_cte_receiver_enable_connection_cte;
    struct gecko_msg_cte_receiver_enable_connection_cte_rsp_t    rsp_cte_receiver_enable_connection_cte;
    struct gecko_msg_cte_receiver_disable_connection_cte_cmd_t   cmd_cte_receiver_disable_connection_cte;
    struct gecko_msg_cte_receiver_disable_connection_cte_rsp_t   rsp_cte_receiver_disable_connection_cte;
    struct gecko_msg_cte_receiver_enable_connectionless_cte_cmd_t cmd_cte_receiver_enable_connectionless_cte;
    struct gecko_msg_cte_receiver_enable_connectionless_cte_rsp_t rsp_cte_receiver_enable_connectionless_cte;
    struct gecko_msg_cte_receiver_disable_connectionless_cte_cmd_t cmd_cte_receiver_disable_connectionless_cte;
    struct gecko_msg_cte_receiver_disable_connectionless_cte_rsp_t rsp_cte_receiver_disable_connectionless_cte;
    struct gecko_msg_cte_receiver_set_dtm_parameters_cmd_t       cmd_cte_receiver_set_dtm_parameters;
    struct gecko_msg_cte_receiver_set_dtm_parameters_rsp_t       rsp_cte_receiver_set_dtm_parameters;
    struct gecko_msg_cte_receiver_clear_dtm_parameters_rsp_t     rsp_cte_receiver_clear_dtm_parameters;
    struct gecko_msg_cte_receiver_enable_silabs_cte_cmd_t        cmd_cte_receiver_enable_silabs_cte;
    struct gecko_msg_cte_receiver_enable_silabs_cte_rsp_t        rsp_cte_receiver_enable_silabs_cte;
    struct gecko_msg_cte_receiver_disable_silabs_cte_rsp_t       rsp_cte_receiver_disable_silabs_cte;
    struct gecko_msg_cte_receiver_connection_iq_report_evt_t     evt_cte_receiver_connection_iq_report;
    struct gecko_msg_cte_receiver_connectionless_iq_report_evt_t evt_cte_receiver_connectionless_iq_report;
    struct gecko_msg_cte_receiver_dtm_iq_report_evt_t            evt_cte_receiver_dtm_iq_report;
    struct gecko_msg_cte_receiver_silabs_iq_report_evt_t         evt_cte_receiver_silabs_iq_report;
    struct gecko_msg_mesh_sensor_server_init_cmd_t               cmd_mesh_sensor_server_init;
    struct gecko_msg_mesh_sensor_server_init_rsp_t               rsp_mesh_sensor_server_init;
    struct gecko_msg_mesh_sensor_server_deinit_cmd_t             cmd_mesh_sensor_server_deinit;
    struct gecko_msg_mesh_sensor_server_deinit_rsp_t             rsp_mesh_sensor_server_deinit;
    struct gecko_msg_mesh_sensor_server_send_descriptor_status_cmd_t cmd_mesh_sensor_server_send_descriptor_status;
    struct gecko_msg_mesh_sensor_server_send_descriptor_status_rsp_t rsp_mesh_sensor_server_send_descriptor_status;
    struct gecko_msg_mesh_sensor_server_send_status_cmd_t        cmd_mesh_sensor_server_send_status;
    struct gecko_msg_mesh_sensor_server_send_status_rsp_t        rsp_mesh_sensor_server_send_status;
    struct gecko_msg_mesh_sensor_server_send_column_status_cmd_t cmd_mesh_sensor_server_send_column_status;
    struct gecko_msg_mesh_sensor_server_send_column_status_rsp_t rsp_mesh_sensor_server_send_column_status;
    struct gecko_msg_mesh_sensor_server_send_series_status_cmd_t cmd_mesh_sensor_server_send_series_status;
    struct gecko_msg_mesh_sensor_server_send_series_status_rsp_t rsp_mesh_sensor_server_send_series_status;
    struct gecko_msg_mesh_sensor_server_get_request_evt_t        evt_mesh_sensor_server_get_request;
    struct gecko_msg_mesh_sensor_server_get_column_request_evt_t evt_mesh_sensor_server_get_column_request;
    struct gecko_msg_mesh_sensor_server_get_series_request_evt_t evt_mesh_sensor_server_get_series_request;
    struct gecko_msg_mesh_sensor_server_publish_evt_t            evt_mesh_sensor_server_publish;
    struct gecko_msg_mesh_sensor_setup_server_send_cadence_status_cmd_t cmd_mesh_sensor_setup_server_send_cadence_status;
    struct gecko_msg_mesh_sensor_setup_server_send_cadence_status_rsp_t rsp_mesh_sensor_setup_server_send_cadence_status;
    struct gecko_msg_mesh_sensor_setup_server_send_settings_status_cmd_t cmd_mesh_sensor_setup_server_send_settings_status;
    struct gecko_msg_mesh_sensor_setup_server_send_settings_status_rsp_t rsp_mesh_sensor_setup_server_send_settings_status;
    struct gecko_msg_mesh_sensor_setup_server_send_setting_status_cmd_t cmd_mesh_sensor_setup_server_send_setting_status;
    struct gecko_msg_mesh_sensor_setup_server_send_setting_status_rsp_t rsp_mesh_sensor_setup_server_send_setting_status;
    struct gecko_msg_mesh_sensor_setup_server_get_cadence_request_evt_t evt_mesh_sensor_setup_server_get_cadence_request;
    struct gecko_msg_mesh_sensor_setup_server_set_cadence_request_evt_t evt_mesh_sensor_setup_server_set_cadence_request;
    struct gecko_msg_mesh_sensor_setup_server_get_settings_request_evt_t evt_mesh_sensor_setup_server_get_settings_request;
    struct gecko_msg_mesh_sensor_setup_server_get_setting_request_evt_t evt_mesh_sensor_setup_server_get_setting_request;
    struct gecko_msg_mesh_sensor_setup_server_set_setting_request_evt_t evt_mesh_sensor_setup_server_set_setting_request;
    struct gecko_msg_mesh_sensor_setup_server_publish_evt_t      evt_mesh_sensor_setup_server_publish;
    struct gecko_msg_mesh_sensor_client_init_rsp_t               rsp_mesh_sensor_client_init;
    struct gecko_msg_mesh_sensor_client_deinit_rsp_t             rsp_mesh_sensor_client_deinit;
    struct gecko_msg_mesh_sensor_client_get_descriptor_cmd_t     cmd_mesh_sensor_client_get_descriptor;
    struct gecko_msg_mesh_sensor_client_get_descriptor_rsp_t     rsp_mesh_sensor_client_get_descriptor;
    struct gecko_msg_mesh_sensor_client_get_cmd_t                cmd_mesh_sensor_client_get;
    struct gecko_msg_mesh_sensor_client_get_rsp_t                rsp_mesh_sensor_client_get;
    struct gecko_msg_mesh_sensor_client_get_column_cmd_t         cmd_mesh_sensor_client_get_column;
    struct gecko_msg_mesh_sensor_client_get_column_rsp_t         rsp_mesh_sensor_client_get_column;
    struct gecko_msg_mesh_sensor_client_get_series_cmd_t         cmd_mesh_sensor_client_get_series;
    struct gecko_msg_mesh_sensor_client_get_series_rsp_t         rsp_mesh_sensor_client_get_series;
    struct gecko_msg_mesh_sensor_client_get_cadence_cmd_t        cmd_mesh_sensor_client_get_cadence;
    struct gecko_msg_mesh_sensor_client_get_cadence_rsp_t        rsp_mesh_sensor_client_get_cadence;
    struct gecko_msg_mesh_sensor_client_set_cadence_cmd_t        cmd_mesh_sensor_client_set_cadence;
    struct gecko_msg_mesh_sensor_client_set_cadence_rsp_t        rsp_mesh_sensor_client_set_cadence;
    struct gecko_msg_mesh_sensor_client_get_settings_cmd_t       cmd_mesh_sensor_client_get_settings;
    struct gecko_msg_mesh_sensor_client_get_settings_rsp_t       rsp_mesh_sensor_client_get_settings;
    struct gecko_msg_mesh_sensor_client_get_setting_cmd_t        cmd_mesh_sensor_client_get_setting;
    struct gecko_msg_mesh_sensor_client_get_setting_rsp_t        rsp_mesh_sensor_client_get_setting;
    struct gecko_msg_mesh_sensor_client_set_setting_cmd_t        cmd_mesh_sensor_client_set_setting;
    struct gecko_msg_mesh_sensor_client_set_setting_rsp_t        rsp_mesh_sensor_client_set_setting;
    struct gecko_msg_mesh_sensor_client_descriptor_status_evt_t  evt_mesh_sensor_client_descriptor_status;
    struct gecko_msg_mesh_sensor_client_cadence_status_evt_t     evt_mesh_sensor_client_cadence_status;
    struct gecko_msg_mesh_sensor_client_settings_status_evt_t    evt_mesh_sensor_client_settings_status;
    struct gecko_msg_mesh_sensor_client_setting_status_evt_t     evt_mesh_sensor_client_setting_status;
    struct gecko_msg_mesh_sensor_client_status_evt_t             evt_mesh_sensor_client_status;
    struct gecko_msg_mesh_sensor_client_column_status_evt_t      evt_mesh_sensor_client_column_status;
    struct gecko_msg_mesh_sensor_client_series_status_evt_t      evt_mesh_sensor_client_series_status;
    struct gecko_msg_mesh_sensor_client_publish_evt_t            evt_mesh_sensor_client_publish;
    struct gecko_msg_mesh_lc_client_init_cmd_t                   cmd_mesh_lc_client_init;
    struct gecko_msg_mesh_lc_client_init_rsp_t                   rsp_mesh_lc_client_init;
    struct gecko_msg_mesh_lc_client_get_mode_cmd_t               cmd_mesh_lc_client_get_mode;
    struct gecko_msg_mesh_lc_client_get_mode_rsp_t               rsp_mesh_lc_client_get_mode;
    struct gecko_msg_mesh_lc_client_set_mode_cmd_t               cmd_mesh_lc_client_set_mode;
    struct gecko_msg_mesh_lc_client_set_mode_rsp_t               rsp_mesh_lc_client_set_mode;
    struct gecko_msg_mesh_lc_client_get_om_cmd_t                 cmd_mesh_lc_client_get_om;
    struct gecko_msg_mesh_lc_client_get_om_rsp_t                 rsp_mesh_lc_client_get_om;
    struct gecko_msg_mesh_lc_client_set_om_cmd_t                 cmd_mesh_lc_client_set_om;
    struct gecko_msg_mesh_lc_client_set_om_rsp_t                 rsp_mesh_lc_client_set_om;
    struct gecko_msg_mesh_lc_client_get_light_onoff_cmd_t        cmd_mesh_lc_client_get_light_onoff;
    struct gecko_msg_mesh_lc_client_get_light_onoff_rsp_t        rsp_mesh_lc_client_get_light_onoff;
    struct gecko_msg_mesh_lc_client_set_light_onoff_cmd_t        cmd_mesh_lc_client_set_light_onoff;
    struct gecko_msg_mesh_lc_client_set_light_onoff_rsp_t        rsp_mesh_lc_client_set_light_onoff;
    struct gecko_msg_mesh_lc_client_get_property_cmd_t           cmd_mesh_lc_client_get_property;
    struct gecko_msg_mesh_lc_client_get_property_rsp_t           rsp_mesh_lc_client_get_property;
    struct gecko_msg_mesh_lc_client_set_property_cmd_t           cmd_mesh_lc_client_set_property;
    struct gecko_msg_mesh_lc_client_set_property_rsp_t           rsp_mesh_lc_client_set_property;
    struct gecko_msg_mesh_lc_client_mode_status_evt_t            evt_mesh_lc_client_mode_status;
    struct gecko_msg_mesh_lc_client_om_status_evt_t              evt_mesh_lc_client_om_status;
    struct gecko_msg_mesh_lc_client_light_onoff_status_evt_t     evt_mesh_lc_client_light_onoff_status;
    struct gecko_msg_mesh_lc_client_property_status_evt_t        evt_mesh_lc_client_property_status;
    struct gecko_msg_mesh_lc_server_init_cmd_t                   cmd_mesh_lc_server_init;
    struct gecko_msg_mesh_lc_server_init_rsp_t                   rsp_mesh_lc_server_init;
    struct gecko_msg_mesh_lc_server_deinit_cmd_t                 cmd_mesh_lc_server_deinit;
    struct gecko_msg_mesh_lc_server_deinit_rsp_t                 rsp_mesh_lc_server_deinit;
    struct gecko_msg_mesh_lc_server_update_mode_cmd_t            cmd_mesh_lc_server_update_mode;
    struct gecko_msg_mesh_lc_server_update_mode_rsp_t            rsp_mesh_lc_server_update_mode;
    struct gecko_msg_mesh_lc_server_update_om_cmd_t              cmd_mesh_lc_server_update_om;
    struct gecko_msg_mesh_lc_server_update_om_rsp_t              rsp_mesh_lc_server_update_om;
    struct gecko_msg_mesh_lc_server_update_light_onoff_cmd_t     cmd_mesh_lc_server_update_light_onoff;
    struct gecko_msg_mesh_lc_server_update_light_onoff_rsp_t     rsp_mesh_lc_server_update_light_onoff;
    struct gecko_msg_mesh_lc_server_init_all_properties_cmd_t    cmd_mesh_lc_server_init_all_properties;
    struct gecko_msg_mesh_lc_server_init_all_properties_rsp_t    rsp_mesh_lc_server_init_all_properties;
    struct gecko_msg_mesh_lc_server_set_publish_mask_cmd_t       cmd_mesh_lc_server_set_publish_mask;
    struct gecko_msg_mesh_lc_server_set_publish_mask_rsp_t       rsp_mesh_lc_server_set_publish_mask;
    struct gecko_msg_mesh_lc_server_set_regulator_interval_cmd_t cmd_mesh_lc_server_set_regulator_interval;
    struct gecko_msg_mesh_lc_server_set_regulator_interval_rsp_t rsp_mesh_lc_server_set_regulator_interval;
    struct gecko_msg_mesh_lc_server_set_event_mask_cmd_t         cmd_mesh_lc_server_set_event_mask;
    struct gecko_msg_mesh_lc_server_set_event_mask_rsp_t         rsp_mesh_lc_server_set_event_mask;
    struct gecko_msg_mesh_lc_server_get_lc_state_cmd_t           cmd_mesh_lc_server_get_lc_state;
    struct gecko_msg_mesh_lc_server_get_lc_state_rsp_t           rsp_mesh_lc_server_get_lc_state;
    struct gecko_msg_mesh_lc_server_mode_updated_evt_t           evt_mesh_lc_server_mode_updated;
    struct gecko_msg_mesh_lc_server_om_updated_evt_t             evt_mesh_lc_server_om_updated;
    struct gecko_msg_mesh_lc_server_light_onoff_updated_evt_t    evt_mesh_lc_server_light_onoff_updated;
    struct gecko_msg_mesh_lc_server_occupancy_updated_evt_t      evt_mesh_lc_server_occupancy_updated;
    struct gecko_msg_mesh_lc_server_ambient_lux_level_updated_evt_t evt_mesh_lc_server_ambient_lux_level_updated;
    struct gecko_msg_mesh_lc_server_linear_output_updated_evt_t  evt_mesh_lc_server_linear_output_updated;
    struct gecko_msg_mesh_lc_server_state_updated_evt_t          evt_mesh_lc_server_state_updated;
    struct gecko_msg_mesh_lc_server_regulator_debug_info_evt_t   evt_mesh_lc_server_regulator_debug_info;
    struct gecko_msg_mesh_lc_setup_server_update_property_cmd_t  cmd_mesh_lc_setup_server_update_property;
    struct gecko_msg_mesh_lc_setup_server_update_property_rsp_t  rsp_mesh_lc_setup_server_update_property;
    struct gecko_msg_mesh_lc_setup_server_set_property_evt_t     evt_mesh_lc_setup_server_set_property;
    struct gecko_msg_mesh_scene_client_init_cmd_t                cmd_mesh_scene_client_init;
    struct gecko_msg_mesh_scene_client_init_rsp_t                rsp_mesh_scene_client_init;
    struct gecko_msg_mesh_scene_client_get_cmd_t                 cmd_mesh_scene_client_get;
    struct gecko_msg_mesh_scene_client_get_rsp_t                 rsp_mesh_scene_client_get;
    struct gecko_msg_mesh_scene_client_get_register_cmd_t        cmd_mesh_scene_client_get_register;
    struct gecko_msg_mesh_scene_client_get_register_rsp_t        rsp_mesh_scene_client_get_register;
    struct gecko_msg_mesh_scene_client_recall_cmd_t              cmd_mesh_scene_client_recall;
    struct gecko_msg_mesh_scene_client_recall_rsp_t              rsp_mesh_scene_client_recall;
    struct gecko_msg_mesh_scene_client_store_cmd_t               cmd_mesh_scene_client_store;
    struct gecko_msg_mesh_scene_client_store_rsp_t               rsp_mesh_scene_client_store;
    struct gecko_msg_mesh_scene_client_delete_cmd_t              cmd_mesh_scene_client_delete;
    struct gecko_msg_mesh_scene_client_delete_rsp_t              rsp_mesh_scene_client_delete;
    struct gecko_msg_mesh_scene_client_status_evt_t              evt_mesh_scene_client_status;
    struct gecko_msg_mesh_scene_client_register_status_evt_t     evt_mesh_scene_client_register_status;
    struct gecko_msg_mesh_scene_server_init_cmd_t                cmd_mesh_scene_server_init;
    struct gecko_msg_mesh_scene_server_init_rsp_t                rsp_mesh_scene_server_init;
    struct gecko_msg_mesh_scene_server_deinit_cmd_t              cmd_mesh_scene_server_deinit;
    struct gecko_msg_mesh_scene_server_deinit_rsp_t              rsp_mesh_scene_server_deinit;
    struct gecko_msg_mesh_scene_server_reset_register_cmd_t      cmd_mesh_scene_server_reset_register;
    struct gecko_msg_mesh_scene_server_reset_register_rsp_t      rsp_mesh_scene_server_reset_register;
    struct gecko_msg_mesh_scene_server_get_evt_t                 evt_mesh_scene_server_get;
    struct gecko_msg_mesh_scene_server_register_get_evt_t        evt_mesh_scene_server_register_get;
    struct gecko_msg_mesh_scene_server_recall_evt_t              evt_mesh_scene_server_recall;
    struct gecko_msg_mesh_scene_server_publish_evt_t             evt_mesh_scene_server_publish;
    struct gecko_msg_mesh_scene_setup_server_init_cmd_t          cmd_mesh_scene_setup_server_init;
    struct gecko_msg_mesh_scene_setup_server_init_rsp_t          rsp_mesh_scene_setup_server_init;
    struct gecko_msg_mesh_scene_setup_server_store_evt_t         evt_mesh_scene_setup_server_store;
    struct gecko_msg_mesh_scene_setup_server_delete_evt_t        evt_mesh_scene_setup_server_delete;
    struct gecko_msg_mesh_scene_setup_server_publish_evt_t       evt_mesh_scene_setup_server_publish;
    struct gecko_msg_mesh_scheduler_client_init_cmd_t            cmd_mesh_scheduler_client_init;
    struct gecko_msg_mesh_scheduler_client_init_rsp_t            rsp_mesh_scheduler_client_init;
    struct gecko_msg_mesh_scheduler_client_deinit_cmd_t          cmd_mesh_scheduler_client_deinit;
    struct gecko_msg_mesh_scheduler_client_deinit_rsp_t          rsp_mesh_scheduler_client_deinit;
    struct gecko_msg_mesh_scheduler_client_get_cmd_t             cmd_mesh_scheduler_client_get;
    struct gecko_msg_mesh_scheduler_client_get_rsp_t             rsp_mesh_scheduler_client_get;
    struct gecko_msg_mesh_scheduler_client_get_action_cmd_t      cmd_mesh_scheduler_client_get_action;
    struct gecko_msg_mesh_scheduler_client_get_action_rsp_t      rsp_mesh_scheduler_client_get_action;
    struct gecko_msg_mesh_scheduler_client_set_action_cmd_t      cmd_mesh_scheduler_client_set_action;
    struct gecko_msg_mesh_scheduler_client_set_action_rsp_t      rsp_mesh_scheduler_client_set_action;
    struct gecko_msg_mesh_scheduler_client_status_evt_t          evt_mesh_scheduler_client_status;
    struct gecko_msg_mesh_scheduler_client_action_status_evt_t   evt_mesh_scheduler_client_action_status;
    struct gecko_msg_mesh_scheduler_server_init_cmd_t            cmd_mesh_scheduler_server_init;
    struct gecko_msg_mesh_scheduler_server_init_rsp_t            rsp_mesh_scheduler_server_init;
    struct gecko_msg_mesh_scheduler_server_deinit_cmd_t          cmd_mesh_scheduler_server_deinit;
    struct gecko_msg_mesh_scheduler_server_deinit_rsp_t          rsp_mesh_scheduler_server_deinit;
    struct gecko_msg_mesh_scheduler_server_get_cmd_t             cmd_mesh_scheduler_server_get;
    struct gecko_msg_mesh_scheduler_server_get_rsp_t             rsp_mesh_scheduler_server_get;
    struct gecko_msg_mesh_scheduler_server_get_action_cmd_t      cmd_mesh_scheduler_server_get_action;
    struct gecko_msg_mesh_scheduler_server_get_action_rsp_t      rsp_mesh_scheduler_server_get_action;
    struct gecko_msg_mesh_scheduler_server_set_action_cmd_t      cmd_mesh_scheduler_server_set_action;
    struct gecko_msg_mesh_scheduler_server_set_action_rsp_t      rsp_mesh_scheduler_server_set_action;
    struct gecko_msg_mesh_scheduler_server_action_changed_evt_t  evt_mesh_scheduler_server_action_changed;
    struct gecko_msg_mesh_time_server_init_cmd_t                 cmd_mesh_time_server_init;
    struct gecko_msg_mesh_time_server_init_rsp_t                 rsp_mesh_time_server_init;
    struct gecko_msg_mesh_time_server_deinit_cmd_t               cmd_mesh_time_server_deinit;
    struct gecko_msg_mesh_time_server_deinit_rsp_t               rsp_mesh_time_server_deinit;
    struct gecko_msg_mesh_time_server_get_time_cmd_t             cmd_mesh_time_server_get_time;
    struct gecko_msg_mesh_time_server_get_time_rsp_t             rsp_mesh_time_server_get_time;
    struct gecko_msg_mesh_time_server_set_time_cmd_t             cmd_mesh_time_server_set_time;
    struct gecko_msg_mesh_time_server_set_time_rsp_t             rsp_mesh_time_server_set_time;
    struct gecko_msg_mesh_time_server_get_time_zone_offset_new_cmd_t cmd_mesh_time_server_get_time_zone_offset_new;
    struct gecko_msg_mesh_time_server_get_time_zone_offset_new_rsp_t rsp_mesh_time_server_get_time_zone_offset_new;
    struct gecko_msg_mesh_time_server_set_time_zone_offset_new_cmd_t cmd_mesh_time_server_set_time_zone_offset_new;
    struct gecko_msg_mesh_time_server_set_time_zone_offset_new_rsp_t rsp_mesh_time_server_set_time_zone_offset_new;
    struct gecko_msg_mesh_time_server_get_tai_utc_delta_new_cmd_t cmd_mesh_time_server_get_tai_utc_delta_new;
    struct gecko_msg_mesh_time_server_get_tai_utc_delta_new_rsp_t rsp_mesh_time_server_get_tai_utc_delta_new;
    struct gecko_msg_mesh_time_server_set_tai_utc_delta_new_cmd_t cmd_mesh_time_server_set_tai_utc_delta_new;
    struct gecko_msg_mesh_time_server_set_tai_utc_delta_new_rsp_t rsp_mesh_time_server_set_tai_utc_delta_new;
    struct gecko_msg_mesh_time_server_get_time_role_cmd_t        cmd_mesh_time_server_get_time_role;
    struct gecko_msg_mesh_time_server_get_time_role_rsp_t        rsp_mesh_time_server_get_time_role;
    struct gecko_msg_mesh_time_server_set_time_role_cmd_t        cmd_mesh_time_server_set_time_role;
    struct gecko_msg_mesh_time_server_set_time_role_rsp_t        rsp_mesh_time_server_set_time_role;
    struct gecko_msg_mesh_time_server_get_datetime_cmd_t         cmd_mesh_time_server_get_datetime;
    struct gecko_msg_mesh_time_server_get_datetime_rsp_t         rsp_mesh_time_server_get_datetime;
    struct gecko_msg_mesh_time_server_time_updated_evt_t         evt_mesh_time_server_time_updated;
    struct gecko_msg_mesh_time_server_time_zone_offset_updated_evt_t evt_mesh_time_server_time_zone_offset_updated;
    struct gecko_msg_mesh_time_server_tai_utc_delta_updated_evt_t evt_mesh_time_server_tai_utc_delta_updated;
    struct gecko_msg_mesh_time_server_time_role_updated_evt_t    evt_mesh_time_server_time_role_updated;
    struct gecko_msg_mesh_time_client_init_cmd_t                 cmd_mesh_time_client_init;
    struct gecko_msg_mesh_time_client_init_rsp_t                 rsp_mesh_time_client_init;
    struct gecko_msg_mesh_time_client_deinit_cmd_t               cmd_mesh_time_client_deinit;
    struct gecko_msg_mesh_time_client_deinit_rsp_t               rsp_mesh_time_client_deinit;
    struct gecko_msg_mesh_time_client_get_time_cmd_t             cmd_mesh_time_client_get_time;
    struct gecko_msg_mesh_time_client_get_time_rsp_t             rsp_mesh_time_client_get_time;
    struct gecko_msg_mesh_time_client_set_time_cmd_t             cmd_mesh_time_client_set_time;
    struct gecko_msg_mesh_time_client_set_time_rsp_t             rsp_mesh_time_client_set_time;
    struct gecko_msg_mesh_time_client_get_time_zone_cmd_t        cmd_mesh_time_client_get_time_zone;
    struct gecko_msg_mesh_time_client_get_time_zone_rsp_t        rsp_mesh_time_client_get_time_zone;
    struct gecko_msg_mesh_time_client_set_time_zone_cmd_t        cmd_mesh_time_client_set_time_zone;
    struct gecko_msg_mesh_time_client_set_time_zone_rsp_t        rsp_mesh_time_client_set_time_zone;
    struct gecko_msg_mesh_time_client_get_tai_utc_delta_cmd_t    cmd_mesh_time_client_get_tai_utc_delta;
    struct gecko_msg_mesh_time_client_get_tai_utc_delta_rsp_t    rsp_mesh_time_client_get_tai_utc_delta;
    struct gecko_msg_mesh_time_client_set_tai_utc_delta_cmd_t    cmd_mesh_time_client_set_tai_utc_delta;
    struct gecko_msg_mesh_time_client_set_tai_utc_delta_rsp_t    rsp_mesh_time_client_set_tai_utc_delta;
    struct gecko_msg_mesh_time_client_get_time_role_cmd_t        cmd_mesh_time_client_get_time_role;
    struct gecko_msg_mesh_time_client_get_time_role_rsp_t        rsp_mesh_time_client_get_time_role;
    struct gecko_msg_mesh_time_client_set_time_role_cmd_t        cmd_mesh_time_client_set_time_role;
    struct gecko_msg_mesh_time_client_set_time_role_rsp_t        rsp_mesh_time_client_set_time_role;
    struct gecko_msg_mesh_time_client_time_status_evt_t          evt_mesh_time_client_time_status;
    struct gecko_msg_mesh_time_client_time_zone_status_evt_t     evt_mesh_time_client_time_zone_status;
    struct gecko_msg_mesh_time_client_tai_utc_delta_status_evt_t evt_mesh_time_client_tai_utc_delta_status;
    struct gecko_msg_mesh_time_client_time_role_status_evt_t     evt_mesh_time_client_time_role_status;
    struct gecko_msg_user_message_to_target_cmd_t                cmd_user_message_to_target;
    struct gecko_msg_user_message_to_target_rsp_t                rsp_user_message_to_target;
    struct gecko_msg_user_message_to_host_evt_t                  evt_user_message_to_host;

    uint8 *payload;
}data;
});

/**
 * Initialize BGAPI class dfu. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_dfu_init();

/**
 * Initialize BGAPI class system. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_system_init();

/**
 * Initialize BGAPI class le_gap. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_le_gap_init();

/**
 * Initialize BGAPI class sync. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_sync_init();

/**
 * Initialize BGAPI class le_connection. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_le_connection_init();

/**
 * Initialize BGAPI class gatt. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_gatt_init();

/**
 * Initialize BGAPI class gatt_server. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_gatt_server_init();

/**
 * Initialize BGAPI class hardware. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_hardware_init();

/**
 * Initialize BGAPI class flash. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_flash_init();

/**
 * Initialize BGAPI class test. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_test_init();

/**
 * Initialize BGAPI class sm. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_sm_init();

/**
 * Initialize BGAPI class mesh_node. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_mesh_node_init();

/**
 * Initialize BGAPI class mesh_prov. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_mesh_prov_init();

/**
 * Initialize BGAPI class mesh_proxy. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_mesh_proxy_init();

/**
 * Initialize BGAPI class mesh_vendor_model. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_mesh_vendor_model_init();

/**
 * Initialize BGAPI class mesh_health_client. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_mesh_health_client_init();

/**
 * Initialize BGAPI class mesh_health_server. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_mesh_health_server_init();

/**
 * Initialize BGAPI class mesh_generic_client. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_mesh_generic_client_init();

/**
 * Initialize BGAPI class mesh_generic_server. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_mesh_generic_server_init();

/**
 * Initialize BGAPI class coex. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_coex_init();

/**
 * Initialize BGAPI class mesh_test. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_mesh_test_init();

/**
 * Initialize BGAPI class mesh_lpn. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_mesh_lpn_init();

/**
 * Initialize BGAPI class mesh_friend. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_mesh_friend_init();

/**
 * Initialize BGAPI class mesh_proxy_client. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_mesh_proxy_client_init();

/**
 * Initialize BGAPI class mesh_proxy_server. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_mesh_proxy_server_init();

/**
 * Initialize BGAPI class mesh_config_client. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_mesh_config_client_init();

/**
 * Initialize BGAPI class l2cap. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_l2cap_init();

/**
 * Initialize BGAPI class cte_transmitter. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_cte_transmitter_init();

/**
 * Initialize BGAPI class cte_receiver. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_cte_receiver_init();

/**
 * Initialize BGAPI class mesh_sensor_server. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_mesh_sensor_server_init();

/**
 * Initialize BGAPI class mesh_sensor_setup_server. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_mesh_sensor_setup_server_init();

/**
 * Initialize BGAPI class mesh_sensor_client. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_mesh_sensor_client_init();

/**
 * Initialize BGAPI class mesh_lc_client. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_mesh_lc_client_init();

/**
 * Initialize BGAPI class mesh_lc_server. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_mesh_lc_server_init();

/**
 * Initialize BGAPI class mesh_lc_setup_server. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_mesh_lc_setup_server_init();

/**
 * Initialize BGAPI class mesh_scene_client. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_mesh_scene_client_init();

/**
 * Initialize BGAPI class mesh_scene_server. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_mesh_scene_server_init();

/**
 * Initialize BGAPI class mesh_scene_setup_server. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_mesh_scene_setup_server_init();

/**
 * Initialize BGAPI class mesh_scheduler_client. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_mesh_scheduler_client_init();

/**
 * Initialize BGAPI class mesh_scheduler_server. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_mesh_scheduler_server_init();

/**
 * Initialize BGAPI class mesh_time_server. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_mesh_time_server_init();

/**
 * Initialize BGAPI class mesh_time_client. This initializer function must be called if any command
 * from this class is going to be used.
 */
void ncp_gecko_bgapi_class_mesh_time_client_init();

void ll_initAFH();
/**
 * Initialize and enable Adaptive Frequency Hopping (AFH). By default this feature is disabled in stack.
 */
static inline void gecko_init_afh()
{
  ll_initAFH();
}

void ll_initPeriodicAdv();
void sli_bt_init_periodic_advertising();
/**
 * Initialize and enable Periodic Advertising. By default this feature is disabled in stack.
 */
static inline void gecko_init_periodic_advertising()
{
  ll_initPeriodicAdv();
  sli_bt_init_periodic_advertising();
}

void sli_bt_init_whitelisting();
/**
 * Initialize whitelisting feature. After initialization the application can enable whitelisting
 * using command cmd_le_gap_enable_whitelisting. By default this feature is not initialized in stack.
 */
static inline void gecko_init_whitelisting()
{
  sli_bt_init_whitelisting();
}


/**
 * Initialize stack and all BGAPI classes.
 * This is a convenience method for getting the stack and all BGAPI classes usable by the application.
 * If application wants to initialize only a subset of BGAPI classes, this function should not be called. Instead,
 * first call gecko_stack_init() to initialize stack, and then call individual BGAPI class initializers.
 *
 * @param config The pointer to configuration parameters, cannot be NULL.
 * @return bg_err_success if the initialization was successful; Other error code
 *         indicates a failure on initializing persistent storage.
 */
static inline errorcode_t gecko_init(const gecko_configuration_t *config)
{
    errorcode_t err = gecko_stack_init(config);
    if (err != bg_err_success) {
        return err;
    }

    ncp_gecko_bgapi_class_dfu_init();
    ncp_gecko_bgapi_class_system_init();
    ncp_gecko_bgapi_class_le_gap_init();
    ncp_gecko_bgapi_class_le_connection_init();
    ncp_gecko_bgapi_class_gatt_init();
    ncp_gecko_bgapi_class_gatt_server_init();
    ncp_gecko_bgapi_class_hardware_init();
    ncp_gecko_bgapi_class_flash_init();
    ncp_gecko_bgapi_class_test_init();
    ncp_gecko_bgapi_class_sm_init();
    ncp_gecko_bgapi_class_mesh_node_init();
    ncp_gecko_bgapi_class_mesh_prov_init();
    ncp_gecko_bgapi_class_mesh_proxy_init();
    ncp_gecko_bgapi_class_mesh_vendor_model_init();
    ncp_gecko_bgapi_class_mesh_health_client_init();
    ncp_gecko_bgapi_class_mesh_health_server_init();
    ncp_gecko_bgapi_class_mesh_generic_client_init();
    ncp_gecko_bgapi_class_mesh_generic_server_init();
    ncp_gecko_bgapi_class_mesh_test_init();
    ncp_gecko_bgapi_class_mesh_lpn_init();
    ncp_gecko_bgapi_class_mesh_friend_init();
    ncp_gecko_bgapi_class_mesh_proxy_client_init();
    ncp_gecko_bgapi_class_mesh_proxy_server_init();
    ncp_gecko_bgapi_class_mesh_config_client_init();
    ncp_gecko_bgapi_class_mesh_sensor_server_init();
    ncp_gecko_bgapi_class_mesh_sensor_setup_server_init();
    ncp_gecko_bgapi_class_mesh_sensor_client_init();
    ncp_gecko_bgapi_class_mesh_lc_client_init();
    ncp_gecko_bgapi_class_mesh_lc_server_init();
    ncp_gecko_bgapi_class_mesh_lc_setup_server_init();
    ncp_gecko_bgapi_class_mesh_scene_client_init();
    ncp_gecko_bgapi_class_mesh_scene_server_init();
    ncp_gecko_bgapi_class_mesh_scene_setup_server_init();
    ncp_gecko_bgapi_class_mesh_scheduler_client_init();
    ncp_gecko_bgapi_class_mesh_scheduler_server_init();
    ncp_gecko_bgapi_class_mesh_time_server_init();
    ncp_gecko_bgapi_class_mesh_time_client_init();

    return bg_err_success;
}
/**
 * Sends the NCP host a message whose BGLIB_MSG_ID is gecko_rsp_user_message_to_target_id.
 * This a utility helping a NCP host and target application to exchange user data. Do not use it in SoC mode.
 */
void gecko_send_rsp_user_message_to_target(uint16 result,uint8 data_len, const uint8* data_data);

/**
 * Sends the NCP host a message whose BGLIB_MSG_ID is gecko_evt_user_message_to_host_id.
 * This a utility helping a NCP host and target application to exchange user data. Do not use it in SoC mode.
 */
void gecko_send_evt_user_message_to_host(uint8 data_len, const uint8* data_data);

void gecko_handle_command(uint32_t,void*);
void gecko_handle_command_noresponse(uint32_t,void*);

extern void*  gecko_cmd_msg_buf;
extern void*  gecko_rsp_msg_buf;

/** 
*
* gecko_cmd_dfu_reset
*
* Reset the system. The command does not have a response but it triggers one of
* the boot events (normal reset or boot to DFU mode) after re-boot. 
*
* @param dfu   Boot mode:
*  
*      0: Normal reset
*      1: Boot to UART DFU mode
*      2: Boot to OTA DFU mode
*
* Events generated
*
* gecko_evt_system_boot - Sent after the device has booted in normal mode
* gecko_evt_dfu_boot - Sent after the device has booted in UART DFU mode
*
**/

static inline void* gecko_cmd_dfu_reset(uint8 dfu)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    
    gecko_cmd_msg->data.cmd_dfu_reset.dfu=dfu;
    gecko_cmd_msg->header=(gecko_cmd_dfu_reset_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command_noresponse(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return 0;
}

/** 
*
* gecko_cmd_dfu_flash_set_address
*
* After re-booting the local device in DFU mode, this command defines the
* starting address on the flash where the new firmware will be written. 
*
* @param address   The offset in the flash where the new firmware is uploaded to. Always use the
*  value 0x00000000.
*
**/

static inline struct gecko_msg_dfu_flash_set_address_rsp_t* gecko_cmd_dfu_flash_set_address(uint32 address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_dfu_flash_set_address.address=address;
    gecko_cmd_msg->header=(gecko_cmd_dfu_flash_set_address_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_dfu_flash_set_address;
}

/** 
*
* gecko_cmd_dfu_flash_upload
*
* Upload the whole firmware image file into the Bluetooth device. The passed
* data length must be a multiple of 4 bytes. Because the BGAPI command payload
* size is limited, multiple commands need to be issued one after the other until
* the whole .bin firmware image file is uploaded to the device. After each
* command, the next address of the flash sector in memory to write to is
* automatically updated by the bootloader. 
*
* @param data_len   Array length
* @param data_data   An array of data which will be written onto the flash.
*
**/

static inline struct gecko_msg_dfu_flash_upload_rsp_t* gecko_cmd_dfu_flash_upload(uint8 data_len, const uint8* data_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)data_len > 256 - 1)
    {
        gecko_rsp_msg->data.rsp_dfu_flash_upload.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_dfu_flash_upload;
    }

    
    gecko_cmd_msg->data.cmd_dfu_flash_upload.data.len=data_len;
    memcpy(gecko_cmd_msg->data.cmd_dfu_flash_upload.data.data,data_data,data_len);
    gecko_cmd_msg->header=(gecko_cmd_dfu_flash_upload_id+(((1+data_len)&0xff)<<8)+(((1+data_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_dfu_flash_upload;
}

/** 
*
* gecko_cmd_dfu_flash_upload_finish
*
* Inform the device that the DFU file is fully uploaded. To return the device
* back to normal mode, issue the command DFU Reset . 
*
*
**/

static inline struct gecko_msg_dfu_flash_upload_finish_rsp_t* gecko_cmd_dfu_flash_upload_finish()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_dfu_flash_upload_finish_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_dfu_flash_upload_finish;
}

/** 
*
* gecko_cmd_system_hello
*
* Verify whether the communication between the host and the device is
* functional. 
*
*
**/

static inline struct gecko_msg_system_hello_rsp_t* gecko_cmd_system_hello()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_system_hello_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_system_hello;
}

/** 
*
* gecko_cmd_system_reset
*
* Reset the system. The command does not have a response but it triggers one of
* the boot events (normal reset or boot to DFU mode) depending on the selected
* boot mode. 
*
* @param dfu   Boot mode:
*  
*      0: Normal reset
*      1: Boot to UART DFU mode
*      2: Boot to OTA DFU mode
*
* Events generated
*
* gecko_evt_system_boot - Sent after the device has booted in normal mode.
* gecko_evt_dfu_boot - Sent after the device has booted in UART DFU mode.
*
**/

static inline void* gecko_cmd_system_reset(uint8 dfu)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    
    gecko_cmd_msg->data.cmd_system_reset.dfu=dfu;
    gecko_cmd_msg->header=(gecko_cmd_system_reset_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command_noresponse(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return 0;
}

/** 
*
* gecko_cmd_system_get_bt_address
*
* Read the Bluetooth public address used by the device. 
*
*
**/

static inline struct gecko_msg_system_get_bt_address_rsp_t* gecko_cmd_system_get_bt_address()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_system_get_bt_address_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_system_get_bt_address;
}

/** 
*
* gecko_cmd_system_set_bt_address
*
* Deprecated and replaced by system_set_identity_address command.
* 
* Set the Bluetooth public address used by the device. A valid address set with
* this command overrides the default Bluetooth public address programmed at
* production and is effective in the next system reboot. The stack treats
* 00:00:00:00:00:00 and ff:ff:ff:ff:ff:ff as invalid addresses. As a result,
* passing one of them into this command will cause the stack to use the default
* address in the next system reboot. 
*
* @param address   Bluetooth public address in little endian format
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_system_set_bt_address_rsp_t* gecko_cmd_system_set_bt_address(bd_addr address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    memcpy(&gecko_cmd_msg->data.cmd_system_set_bt_address.address,&address,sizeof(bd_addr));
    gecko_cmd_msg->header=(gecko_cmd_system_set_bt_address_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_system_set_bt_address;
}

/** 
*
* gecko_cmd_system_set_tx_power
*
* Set the global maximum TX power for Bluetooth. The returned value is the
* selected maximum output power level after applying the RF path compensation.
* If the GATT server contains a TX power service, the TX Power Level attribute
* will be updated accordingly.
* 
* The selected power level may be less than the specified value if the device
* does not meet the power requirements. For Bluetooth connections, the maximum
* TX power is limited to 10 dBm if Adaptive Frequency Hopping (AFH) is not
* enabled.
* 
* By default, the global maximum TX power value is 8 dBm.
* 
* NOTE: Do not use this command while advertising, scanning, or during
* connection. 
*
* @param power   TX power in 0.1 dBm steps. For example, the value of 10 is 1 dBm and 55 is 5.5
*  dBm.
*
**/

static inline struct gecko_msg_system_set_tx_power_rsp_t* gecko_cmd_system_set_tx_power(int16 power)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_system_set_tx_power.power=power;
    gecko_cmd_msg->header=(gecko_cmd_system_set_tx_power_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_system_set_tx_power;
}

/** 
*
* gecko_cmd_system_get_random_data
*
* Get random data up to 16 bytes. 
*
* @param length   Length of random data. Maximum length is 16 bytes.
*
**/

static inline struct gecko_msg_system_get_random_data_rsp_t* gecko_cmd_system_get_random_data(uint8 length)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_system_get_random_data.length=length;
    gecko_cmd_msg->header=(gecko_cmd_system_get_random_data_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_system_get_random_data;
}

/** 
*
* gecko_cmd_system_halt
*
* Force radio to idle state and allow device to sleep. Advertising, scanning,
* connections, and software timers are halted by this command. Halted operations
* resume after calling this command with parameter 0. Connections stay alive if
* system is resumed before connection supervision timeout.
* 
* Use this command only for a short time period (a few seconds at maximum).
* Although it halts Bluetooth activity, all tasks and operations still exist
* inside the stack with their own concepts of time. Halting the system for a
* long time period may have negative consequences on stack's internal states.
* 
* NOTE: The software timer is also halted. Hardware interrupts are the only way
* to wake up from energy mode 2 when the system is halted. 
*
* @param halt   Values:
*  
*      1: halt
*      0: resume
*
**/

static inline struct gecko_msg_system_halt_rsp_t* gecko_cmd_system_halt(uint8 halt)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_system_halt.halt=halt;
    gecko_cmd_msg->header=(gecko_cmd_system_halt_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_system_halt;
}

/** 
*
* gecko_cmd_system_set_device_name
*
* Set the device name which will be used during the OTA update. The name will be
* stored in the persistent store. If the OTA device name is also set in the
* stack configuration, the name stored in the persistent store is overwritten by
* the name in the stack configuration during the device boot. 
*
* @param type   Device name to set. Values:
*  
*       0: OTA device name
* @param name_len   Array length
* @param name_data   Device name
*
**/

static inline struct gecko_msg_system_set_device_name_rsp_t* gecko_cmd_system_set_device_name(uint8 type,uint8 name_len, const uint8* name_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)name_len > 256 - 2)
    {
        gecko_rsp_msg->data.rsp_system_set_device_name.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_system_set_device_name;
    }

    
    gecko_cmd_msg->data.cmd_system_set_device_name.type=type;
    gecko_cmd_msg->data.cmd_system_set_device_name.name.len=name_len;
    memcpy(gecko_cmd_msg->data.cmd_system_set_device_name.name.data,name_data,name_len);
    gecko_cmd_msg->header=(gecko_cmd_system_set_device_name_id+(((2+name_len)&0xff)<<8)+(((2+name_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_system_set_device_name;
}

/** 
*
* gecko_cmd_system_linklayer_configure
*
* Send configuration data to the link layer. This command fine tunes low-level
* Bluetooth operations. 
*
* @param key   Key to configure
* @param data_len   Array length
* @param data_data   Configuration data. Length and contents of the data field depend on the key
*  value used.
*
**/

static inline struct gecko_msg_system_linklayer_configure_rsp_t* gecko_cmd_system_linklayer_configure(uint8 key,uint8 data_len, const uint8* data_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)data_len > 256 - 2)
    {
        gecko_rsp_msg->data.rsp_system_linklayer_configure.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_system_linklayer_configure;
    }

    
    gecko_cmd_msg->data.cmd_system_linklayer_configure.key=key;
    gecko_cmd_msg->data.cmd_system_linklayer_configure.data.len=data_len;
    memcpy(gecko_cmd_msg->data.cmd_system_linklayer_configure.data.data,data_data,data_len);
    gecko_cmd_msg->header=(gecko_cmd_system_linklayer_configure_id+(((2+data_len)&0xff)<<8)+(((2+data_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_system_linklayer_configure;
}

/** 
*
* gecko_cmd_system_get_counters
*
* Get packet and error counters. Passing a non-zero value also resets counters. 
*
* @param reset   Reset counters if the parameter value is not zero.
*
**/

static inline struct gecko_msg_system_get_counters_rsp_t* gecko_cmd_system_get_counters(uint8 reset)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_system_get_counters.reset=reset;
    gecko_cmd_msg->header=(gecko_cmd_system_get_counters_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_system_get_counters;
}

/** 
*
* gecko_cmd_system_data_buffer_write
*
* Write data into the system data buffer. Data will be appended to the end of
* existing data. 
*
* @param data_len   Array length
* @param data_data   Data to write
*
**/

static inline struct gecko_msg_system_data_buffer_write_rsp_t* gecko_cmd_system_data_buffer_write(uint8 data_len, const uint8* data_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)data_len > 256 - 1)
    {
        gecko_rsp_msg->data.rsp_system_data_buffer_write.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_system_data_buffer_write;
    }

    
    gecko_cmd_msg->data.cmd_system_data_buffer_write.data.len=data_len;
    memcpy(gecko_cmd_msg->data.cmd_system_data_buffer_write.data.data,data_data,data_len);
    gecko_cmd_msg->header=(gecko_cmd_system_data_buffer_write_id+(((1+data_len)&0xff)<<8)+(((1+data_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_system_data_buffer_write;
}

/** 
*
* gecko_cmd_system_set_identity_address
*
* Set the device's Bluetooth identity address. The address can be a public
* device address or a static device address. A valid address set with this
* command will be written into persistent storage using PS keys. The stack
* returns an error if the static device address does not conform to the
* Bluetooth specification.
* 
* The new address will be effective in the next system reboot. The stack will
* use the address in the PS keys when present. Otherwise, it uses the default
* Bluetooth public device address which is programmed at production.
* 
* The stack treats 00:00:00:00:00:00 and ff:ff:ff:ff:ff:ff as invalid addresses.
* Therefore, passing one of them into this command will cause the stack to
* delete the PS keys and use the default address in the next system reboot.
* 
* Note: Because the PS keys are located in flash and flash wearing can occur,
* avoid calling this command regularly. 
*
* @param address   Bluetooth identity address in little endian format
* @param type   Address type
*  
*      0: Public device address
*      1: Static device address
*
**/

static inline struct gecko_msg_system_set_identity_address_rsp_t* gecko_cmd_system_set_identity_address(bd_addr address,uint8 type)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    memcpy(&gecko_cmd_msg->data.cmd_system_set_identity_address.address,&address,sizeof(bd_addr));
    gecko_cmd_msg->data.cmd_system_set_identity_address.type=type;
    gecko_cmd_msg->header=(gecko_cmd_system_set_identity_address_id+(((7)&0xff)<<8)+(((7)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_system_set_identity_address;
}

/** 
*
* gecko_cmd_system_data_buffer_clear
*
* Remove all data from the system data buffer. 
*
*
**/

static inline struct gecko_msg_system_data_buffer_clear_rsp_t* gecko_cmd_system_data_buffer_clear()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_system_data_buffer_clear_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_system_data_buffer_clear;
}

/** 
*
* gecko_cmd_le_gap_open
*
* Deprecated and replaced by le_gap_connect command, which allows opening a
* connection with a specified PHY.
* 
* Connect to an advertising device where 1M PHY is the initiating PHY. 
*
* @param address   An address of the device to connect to
* @param address_type   An address type of the device to connect to
*
* Events generated
*
* gecko_evt_le_connection_opened - Triggered after the connection is opened and indicates whether the devices are
*  already bonded and whether the role of the Bluetooth device is Slave or
*  Master.
* gecko_evt_le_connection_parameters - Indicates the connection parameters and security mode of the connection.
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_le_gap_open_rsp_t* gecko_cmd_le_gap_open(bd_addr address,uint8 address_type)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    memcpy(&gecko_cmd_msg->data.cmd_le_gap_open.address,&address,sizeof(bd_addr));
    gecko_cmd_msg->data.cmd_le_gap_open.address_type=address_type;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_open_id+(((7)&0xff)<<8)+(((7)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_open;
}

/** 
*
* gecko_cmd_le_gap_set_mode
*
* Deprecated. Use le_gap_start_advertising command to enable advertising and
* le_gap_stop_advertising command to disable advertising.
* 
* This command is only effective on the first advertising set (handle value 0).
* Other advertising sets are not affected. 
*
* @param discover   Discoverable mode
* @param connect   Connectable mode
*
* Events generated
*
* gecko_evt_le_gap_adv_timeout - Triggered when the number of advertising events is done and advertising has
*  stopped.
* gecko_evt_le_connection_opened - Triggered when a remote device opens a connection to this advertising device.
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_le_gap_set_mode_rsp_t* gecko_cmd_le_gap_set_mode(uint8 discover,uint8 connect)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_set_mode.discover=discover;
    gecko_cmd_msg->data.cmd_le_gap_set_mode.connect=connect;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_set_mode_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_set_mode;
}

/** 
*
* gecko_cmd_le_gap_discover
*
* Deprecated and replaced by le_gap_start_discovery command. To preserve the
* same functionality when migrating to the new command, use 1M PHY in
* scanning_phy parameter.
* 
* This command can be used to start the GAP discovery procedure to scan for
* advertising devices on 1M PHY. To cancel an ongoing discovery process, use the
* le_gap_end_procedure command. 
*
* @param mode   Bluetooth discovery Mode. For values see link.
*
* Events generated
*
* gecko_evt_le_gap_scan_response - Each time an advertising packet is received, this event is triggered. The
*  packets are not filtered in any way, so multiple events will be received for
*  every advertising device in range.
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_le_gap_discover_rsp_t* gecko_cmd_le_gap_discover(uint8 mode)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_discover.mode=mode;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_discover_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_discover;
}

/** 
*
* gecko_cmd_le_gap_end_procedure
*
* End the current GAP discovery procedure (i.e., scanning for advertising
* devices). 
*
*
**/

static inline struct gecko_msg_le_gap_end_procedure_rsp_t* gecko_cmd_le_gap_end_procedure()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_le_gap_end_procedure_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_end_procedure;
}

/** 
*
* gecko_cmd_le_gap_set_adv_parameters
*
* Deprecated and replaced by le_gap_set_advertise_timing command to set the
* advertising intervals and le_gap_set_advertise_channel_map command to set the
* channel map.
* 
* This command is only effective on the first advertising set (handle value 0).
* Other advertising sets are not affected. 
*
* @param interval_min   Minimum advertising interval. Value in units of 0.625 ms
*  
*      Range: 0x20 to 0xFFFF
*      Time range: 20 ms to 40.96 s
*  
*  Default value: 100 ms
* @param interval_max   Maximum advertising interval. Value in units of 0.625 ms
*  
*      Range: 0x20 to 0xFFFF
*      Time range: 20 ms to 40.96 s
*      Note: interval_max should be bigger than interval_min
*  
*  Default value: 200 ms
* @param channel_map   Advertising channel map, which determines which of the three channels will be
*  used for advertising. This value is given as a bitmask. Values:
*  
*       1: Advertise on CH37
*       2: Advertise on CH38
*       3: Advertise on CH37 and CH38
*       4: Advertise on CH39
*       5: Advertise on CH37 and CH39
*       6: Advertise on CH38 and CH39
*       7: Advertise on all channels
*  
*  Recommended value: 7
*  
*  Default value: 7
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_le_gap_set_adv_parameters_rsp_t* gecko_cmd_le_gap_set_adv_parameters(uint16 interval_min,uint16 interval_max,uint8 channel_map)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_set_adv_parameters.interval_min=interval_min;
    gecko_cmd_msg->data.cmd_le_gap_set_adv_parameters.interval_max=interval_max;
    gecko_cmd_msg->data.cmd_le_gap_set_adv_parameters.channel_map=channel_map;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_set_adv_parameters_id+(((5)&0xff)<<8)+(((5)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_set_adv_parameters;
}

/** 
*
* gecko_cmd_le_gap_set_conn_parameters
*
* Deprecated and replaced by le_gap_set_conn_timing_parameters command for
* setting timing parameters.
* 
* Set the default Bluetooth connection parameters. The configured values are
* valid for all subsequent connections that will be established. To change the
* parameters of an already established connection, use the command
* le_connection_set_parameters. 
*
* @param min_interval   Minimum value for the connection event interval. This must be set less than or
*  equal to the max_interval.
*  
*      Time = Value x 1.25 ms
*      Range: 0x0006 to 0x0c80
*      Time Range: 7.5 ms to 4 s
*  
*  Default value: 20 ms
* @param max_interval   Maximum value for the connection event interval. This must be set greater than
*  or equal to the min_interval.
*  
*      Time = Value x 1.25 ms
*      Range: 0x0006 to 0x0c80
*      Time Range: 7.5 ms to 4 s
*  
*  Default value: 50 ms
* @param latency   Slave latency, which defines how many connection intervals the slave can skip
*  if it has no data to send
*  
*      Range: 0x0000 to 0x01f4
*  
*  Default value: 0
* @param timeout   Supervision timeout, which defines the time that the connection is maintained
*  although the devices can't communicate at the currently configured connection
*  intervals.
*  
*      Range: 0x000a to 0x0c80
*      Time = Value x 10 ms
*      Time Range: 100 ms to 32 s
*      The value in milliseconds must be larger than (1 + latency) * max_interval * 2, where max_interval is given in milliseconds
*  
*  Set the supervision timeout at a value which allows communication attempts
*  over at least a few connection intervals.
*  
*  Default value: 1000 ms
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_le_gap_set_conn_parameters_rsp_t* gecko_cmd_le_gap_set_conn_parameters(uint16 min_interval,uint16 max_interval,uint16 latency,uint16 timeout)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_set_conn_parameters.min_interval=min_interval;
    gecko_cmd_msg->data.cmd_le_gap_set_conn_parameters.max_interval=max_interval;
    gecko_cmd_msg->data.cmd_le_gap_set_conn_parameters.latency=latency;
    gecko_cmd_msg->data.cmd_le_gap_set_conn_parameters.timeout=timeout;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_set_conn_parameters_id+(((8)&0xff)<<8)+(((8)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_set_conn_parameters;
}

/** 
*
* gecko_cmd_le_gap_set_scan_parameters
*
* Deprecated and replaced by le_gap_set_discovery_timing command to set timing
* parameters, and le_gap_set_discovery_type command for the scan type.
* 
* The parameters set by this command are only effective on the 1M PHY. For Coded
* PHY, use the above replacement command. 
*
* @param scan_interval   Scanner interval is defined as the time interval when the device starts its
*  last scan until it begins the subsequent scan. In other words, it indicates
*  how often to scan
*  
*      Time = Value x 0.625 ms
*      Range: 0x0004 to 0x4000
*      Time Range: 2.5 ms to 10.24 s
*  
*  Default value: 10 ms
*  
*  A variable delay occurs when switching channels at the end of each scanning
*  interval, which is included in the scanning interval time. During the switch
*  time no advertising packets are received by the device. The switch time
*  variation is use case-dependent. For example, if scanning while keeping active
*  connections, the channel switch time might be longer than scanning without any
*  active connections. Increasing the scanning interval reduces the amount of
*  time in which the device can't receive advertising packets because it will
*  switch channels less often.
*  
*  After every scan interval, the scanner changes the frequency at which it
*  operates. It cycles through all three advertising channels in a round robin
*  fashion. According to the specification, all three channels must be used by
*  the scanner.
* @param scan_window   Scan window defines the duration of the scan which must be less than or equal
*  to scan_interval
*  
*      Time = Value x 0.625 ms
*      Range: 0x0004 to 0x4000
*      Time Range: 2.5 ms to 10.24 s
*  
*  Default value: 10 ms Note that packet reception is aborted if it was started
*  before the scan window ends.
* @param active   The scan type. Values:
*  
*       0: Passive scanning
*       1: Active scanning
*      In passive scanning mode, the device only listens to advertising packets and does not transmit any packets.
*      In active scanning mode, the device will send out a scan request packet upon receiving an advertising packet from a remote device and then it will listen to the scan response packet from the device.
*  
*  Default value: 0
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_le_gap_set_scan_parameters_rsp_t* gecko_cmd_le_gap_set_scan_parameters(uint16 scan_interval,uint16 scan_window,uint8 active)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_set_scan_parameters.scan_interval=scan_interval;
    gecko_cmd_msg->data.cmd_le_gap_set_scan_parameters.scan_window=scan_window;
    gecko_cmd_msg->data.cmd_le_gap_set_scan_parameters.active=active;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_set_scan_parameters_id+(((5)&0xff)<<8)+(((5)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_set_scan_parameters;
}

/** 
*
* gecko_cmd_le_gap_set_adv_data
*
* Deprecated. Use le_gap_bt5_set_adv_data command to set advertising data and
* scan response data.
* 
* This command is only effective on the first advertising set (handle value 0).
* Other advertising sets are not affected. 
*
* @param scan_rsp   This value selects if data is intended for advertising packets, scan response
*  packets, or advertising packet in OTA. Values:
*  
*      0: Advertising packets
*       1: Scan response packets
*       2: OTA advertising packets
*       4: OTA scan response packets
* @param adv_data_len   Array length
* @param adv_data_data   Data to be set
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_le_gap_set_adv_data_rsp_t* gecko_cmd_le_gap_set_adv_data(uint8 scan_rsp,uint8 adv_data_len, const uint8* adv_data_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)adv_data_len > 256 - 2)
    {
        gecko_rsp_msg->data.rsp_le_gap_set_adv_data.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_le_gap_set_adv_data;
    }

    
    gecko_cmd_msg->data.cmd_le_gap_set_adv_data.scan_rsp=scan_rsp;
    gecko_cmd_msg->data.cmd_le_gap_set_adv_data.adv_data.len=adv_data_len;
    memcpy(gecko_cmd_msg->data.cmd_le_gap_set_adv_data.adv_data.data,adv_data_data,adv_data_len);
    gecko_cmd_msg->header=(gecko_cmd_le_gap_set_adv_data_id+(((2+adv_data_len)&0xff)<<8)+(((2+adv_data_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_set_adv_data;
}

/** 
*
* gecko_cmd_le_gap_set_adv_timeout
*
* Deprecated. Use the new command le_gap_set_advertise_timing.
* 
* This command is only effective on the first advertising set (handle value 0).
* Other advertising sets are not affected. 
*
* @param maxevents   If non-zero, indicates the maximum number of advertising events to send before
*  stopping advertiser. Value 0 indicates no maximum number limit.
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_le_gap_set_adv_timeout_rsp_t* gecko_cmd_le_gap_set_adv_timeout(uint8 maxevents)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_set_adv_timeout.maxevents=maxevents;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_set_adv_timeout_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_set_adv_timeout;
}

/** 
*
* gecko_cmd_le_gap_set_conn_phy
*
* Set default preferred and accepted PHYs. PHY settings will be used for all
* subsequent connections. Non-preferred PHY can also be set if the remote device
* does not accept any of the preferred PHYs.
* 
* The parameter accepted_phy is used to specify PHYs that the stack can accept
* in a remotely-initiated PHY update request. A PHY update will not happen if
* none of the accepted PHYs are present in the request.
* 
* NOTE: 2M and Coded PHYs are not supported by all devices. 
*
* @param preferred_phy   Preferred PHYs. This parameter is a bitfield and multiple PHYs can be set.
*  
*      0x01: 1M PHY
*      0x02: 2M PHY
*      0x04: Coded PHY
*      0xff: Any PHYs
*  
*  Default: 0xff (no preference)
* @param accepted_phy   Accepted PHYs in remotely-initiated PHY update request. This parameter is a
*  bitfield and multiple PHYs can be set.
*  
*      0x01: 1M PHY
*      0x02: 2M PHY
*      0x04: Coded PHY
*      0xff: Any PHYs
*  
*  Default: 0xff (all PHYs accepted)
*
**/

static inline struct gecko_msg_le_gap_set_conn_phy_rsp_t* gecko_cmd_le_gap_set_conn_phy(uint8 preferred_phy,uint8 accepted_phy)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_set_conn_phy.preferred_phy=preferred_phy;
    gecko_cmd_msg->data.cmd_le_gap_set_conn_phy.accepted_phy=accepted_phy;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_set_conn_phy_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_set_conn_phy;
}

/** 
*
* gecko_cmd_le_gap_bt5_set_mode
*
* Deprecated and replaced by le_gap_start_advertising command to start
* advertising, and le_gap_stop_advertising command to stop advertising.
* le_gap_set_advertise_timing command can be used for setting the maxevents and
* command le_gap_set_advertise_configuration can be used for setting address
* types. 
*
* @param handle   Advertising set handle
* @param discover   Discoverable mode
* @param connect   Connectable mode
* @param maxevents   If non-zero, indicates the maximum number of advertising events to send before
*  stopping the advertiser. Value 0 indicates no maximum number limit.
* @param address_type   Address type to use for packets
*
* Events generated
*
* gecko_evt_le_gap_adv_timeout - Triggered when the advertising events set by this command are complete and
*  advertising is stopped on the given advertising set.
* gecko_evt_le_connection_opened - Triggered when a remote device opens a connection to the advertiser on the
*  specified advertising set.
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_le_gap_bt5_set_mode_rsp_t* gecko_cmd_le_gap_bt5_set_mode(uint8 handle,uint8 discover,uint8 connect,uint16 maxevents,uint8 address_type)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_mode.handle=handle;
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_mode.discover=discover;
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_mode.connect=connect;
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_mode.maxevents=maxevents;
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_mode.address_type=address_type;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_bt5_set_mode_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_bt5_set_mode;
}

/** 
*
* gecko_cmd_le_gap_bt5_set_adv_parameters
*
* Deprecated and replaced by le_gap_set_advertise_timing command to set the
* advertising intervals, le_gap_set_advertise_channel_map command to set the
* channel map, and le_gap_set_advertise_report_scan_request command to enable
* and disable scan request notifications. 
*
* @param handle   Advertising set handle
* @param interval_min   Minimum advertising interval. Value in units of 0.625 ms
*  
*      Range: 0x20 to 0xFFFF
*      Time range: 20 ms to 40.96 s
*  
*  Default value: 100 ms
* @param interval_max   Maximum advertising interval. Value in units of 0.625 ms
*  
*      Range: 0x20 to 0xFFFF
*      Time range: 20 ms to 40.96 s
*      Note: interval_max should be bigger than interval_min
*  
*  Default value: 200 ms
* @param channel_map   Advertising channel map, which determines which of the three channels will be
*  used for advertising. This value is given as a bitmask. Values:
*  
*       1: Advertise on CH37
*       2: Advertise on CH38
*       3: Advertise on CH37 and CH38
*       4: Advertise on CH39
*       5: Advertise on CH37 and CH39
*       6: Advertise on CH38 and CH39
*       7: Advertise on all channels
*  
*  Recommended value: 7
*  
*  Default value: 7
* @param report_scan   If non-zero, enables scan request notification, and scan requests will be
*  reported as events.
*  
*  Default value: 0
*
* Events generated
*
* gecko_evt_le_gap_scan_request - Triggered when a scan request is received during advertising if the scan
*  request notification is enabled by this command.
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_le_gap_bt5_set_adv_parameters_rsp_t* gecko_cmd_le_gap_bt5_set_adv_parameters(uint8 handle,uint16 interval_min,uint16 interval_max,uint8 channel_map,uint8 report_scan)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_adv_parameters.handle=handle;
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_adv_parameters.interval_min=interval_min;
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_adv_parameters.interval_max=interval_max;
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_adv_parameters.channel_map=channel_map;
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_adv_parameters.report_scan=report_scan;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_bt5_set_adv_parameters_id+(((7)&0xff)<<8)+(((7)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_bt5_set_adv_parameters;
}

/** 
*
* gecko_cmd_le_gap_bt5_set_adv_data
*
* Set user-defined data in advertising packets, scan response packets, or
* periodic advertising packets. Maximum 31 bytes of data can be set for legacy
* advertising. Maximum 191 bytes of data can be set for connectable extended
* advertising. Maximum 253 bytes of data can be set for periodic and non-
* connectable extended advertising. For setting longer advertising data, use
* command le_gap_set_long_advertising_data.
* 
* If advertising mode is currently enabled, the new advertising data will be
* used immediately. Advertising mode can be enabled using command
* le_gap_start_advertising. Periodic advertising mode can be enabled using
* command le_gap_start_periodic_advertising.
* 
* The invalid parameter error will be returned in the following situations:
* 
*      Data length is more than 31 bytes but the advertiser can only advertise using legacy advertising PDUs.
*      Data is too long to fit into a single advertisement.
*      Set data of the advertising data packet when the advertiser is advertising in scannable mode using extended advertising PDUs.
*      Set data of the scan response data packet when the advertiser is advertising in connectable mode using extended advertising PDUs.
* 
* Note that the user-defined data may be overwritten by the system when the
* advertising is later enabled in a discoverable mode other than user_data. 
*
* @param handle   Advertising set handle
* @param scan_rsp   This value selects whether data is intended for advertising packets, scan
*  response packets, periodic advertising packets, or advertising packets in OTA.
*  Values are as follows:
*  
*      0: Advertising packets
*      1: Scan response packets
*      2: OTA advertising packets
*      4: OTA scan response packets
*      8: Periodic advertising packets
* @param adv_data_len   Array length
* @param adv_data_data   Data to be set
*
**/

static inline struct gecko_msg_le_gap_bt5_set_adv_data_rsp_t* gecko_cmd_le_gap_bt5_set_adv_data(uint8 handle,uint8 scan_rsp,uint8 adv_data_len, const uint8* adv_data_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)adv_data_len > 256 - 3)
    {
        gecko_rsp_msg->data.rsp_le_gap_bt5_set_adv_data.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_le_gap_bt5_set_adv_data;
    }

    
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_adv_data.handle=handle;
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_adv_data.scan_rsp=scan_rsp;
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_adv_data.adv_data.len=adv_data_len;
    memcpy(gecko_cmd_msg->data.cmd_le_gap_bt5_set_adv_data.adv_data.data,adv_data_data,adv_data_len);
    gecko_cmd_msg->header=(gecko_cmd_le_gap_bt5_set_adv_data_id+(((3+adv_data_len)&0xff)<<8)+(((3+adv_data_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_bt5_set_adv_data;
}

/** 
*
* gecko_cmd_le_gap_set_privacy_mode
*
* Enable or disable the privacy feature on all GAP roles. New privacy mode will
* take effect for advertising next time advertising is enabled, for scanning
* next time scanning is enabled, and for initiating on the next open connection
* command. When privacy is enabled and the device is advertising or scanning,
* the stack will maintain a periodic timer with the specified time interval as a
* timeout value. At each timeout, the stack will generate a new private
* resolvable address and use it in advertising data packets and scanning
* requests.
* 
* By default, privacy feature is disabled. 
*
* @param privacy   Values:
*  
*      0: Disable privacy
*       1: Enable privacy
* @param interval   The minimum time interval between a private address change. This parameter is
*  ignored if this command is issued to disable privacy mode. Values:
*  
*      0: Use default interval, 15 minutes
*       others: The time interval in minutes
*
**/

static inline struct gecko_msg_le_gap_set_privacy_mode_rsp_t* gecko_cmd_le_gap_set_privacy_mode(uint8 privacy,uint8 interval)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_set_privacy_mode.privacy=privacy;
    gecko_cmd_msg->data.cmd_le_gap_set_privacy_mode.interval=interval;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_set_privacy_mode_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_set_privacy_mode;
}

/** 
*
* gecko_cmd_le_gap_set_advertise_timing
*
* Set the advertising timing parameters of the given advertising set. This
* setting will take effect next time that advertising is enabled. 
*
* @param handle   Advertising set handle
* @param interval_min   Minimum advertising interval. Value in units of 0.625 ms
*  
*      Range: 0x20 to 0xFFFF
*      Time range: 20 ms to 40.96 s
*  
*  Default value: 100 ms
* @param interval_max   Maximum advertising interval. Value in units of 0.625 ms
*  
*      Range: 0x20 to 0xFFFF
*      Time range: 20 ms to 40.96 s
*      Note: interval_max should be bigger than interval_min
*  
*  Default value: 200 ms
* @param duration   Advertising duration for this advertising set. Value 0 indicates no
*  advertising duration limit and advertising continues until it is disabled. A
*  non-zero value sets the duration in units of 10 ms. The duration begins at the
*  start of the first advertising event of this advertising set.
*  
*      Range: 0x0001 to 0xFFFF
*      Time range: 10 ms to 655.35 s
*  
*  Default value: 0
* @param maxevents   If non-zero, indicates the maximum number of advertising events to send before
*  the advertiser is stopped. Value 0 indicates no maximum number limit.
*  
*  Default value: 0
*
**/

static inline struct gecko_msg_le_gap_set_advertise_timing_rsp_t* gecko_cmd_le_gap_set_advertise_timing(uint8 handle,uint32 interval_min,uint32 interval_max,uint16 duration,uint8 maxevents)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_set_advertise_timing.handle=handle;
    gecko_cmd_msg->data.cmd_le_gap_set_advertise_timing.interval_min=interval_min;
    gecko_cmd_msg->data.cmd_le_gap_set_advertise_timing.interval_max=interval_max;
    gecko_cmd_msg->data.cmd_le_gap_set_advertise_timing.duration=duration;
    gecko_cmd_msg->data.cmd_le_gap_set_advertise_timing.maxevents=maxevents;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_set_advertise_timing_id+(((12)&0xff)<<8)+(((12)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_set_advertise_timing;
}

/** 
*
* gecko_cmd_le_gap_set_advertise_channel_map
*
* Set the primary advertising channel map of the given advertising set. This
* setting will take effect next time that advertising is enabled. 
*
* @param handle   Advertising set handle
* @param channel_map   Advertising channel map which determines which of the three channels will be
*  used for advertising. This value is given as a bitmask. Values:
*  
*       1: Advertise on CH37
*       2: Advertise on CH38
*       3: Advertise on CH37 and CH38
*       4: Advertise on CH39
*       5: Advertise on CH37 and CH39
*       6: Advertise on CH38 and CH39
*       7: Advertise on all channels
*  
*  Recommended value: 7
*  
*  Default value: 7
*
**/

static inline struct gecko_msg_le_gap_set_advertise_channel_map_rsp_t* gecko_cmd_le_gap_set_advertise_channel_map(uint8 handle,uint8 channel_map)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_set_advertise_channel_map.handle=handle;
    gecko_cmd_msg->data.cmd_le_gap_set_advertise_channel_map.channel_map=channel_map;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_set_advertise_channel_map_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_set_advertise_channel_map;
}

/** 
*
* gecko_cmd_le_gap_set_advertise_report_scan_request
*
* Enable or disable the scan request notification of a given advertising set.
* This setting will take effect next time that advertising is enabled. 
*
* @param handle   Advertising set handle
* @param report_scan_req   If non-zero, enables scan request notification and scan requests will be
*  reported as events.
*  
*  Default value: 0
*
* Events generated
*
* gecko_evt_le_gap_scan_request - Triggered when a scan request is received during advertising if the scan
*  request notification is enabled by this command.
*
**/

static inline struct gecko_msg_le_gap_set_advertise_report_scan_request_rsp_t* gecko_cmd_le_gap_set_advertise_report_scan_request(uint8 handle,uint8 report_scan_req)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_set_advertise_report_scan_request.handle=handle;
    gecko_cmd_msg->data.cmd_le_gap_set_advertise_report_scan_request.report_scan_req=report_scan_req;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_set_advertise_report_scan_request_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_set_advertise_report_scan_request;
}

/** 
*
* gecko_cmd_le_gap_set_advertise_phy
*
* Set advertising PHYs of the given advertising set. This setting will take
* effect next time that advertising is enabled. The invalid parameter error is
* returned if a PHY value is invalid or the device does not support a given PHY. 
*
* @param handle   Advertising set handle
* @param primary_phy   The PHY on which the advertising packets are transmitted on the primary
*  advertising channel. If legacy advertising PDUs are used, 1M PHY must be used.
*  
*  Values:
*  
*       1: Advertising PHY is 1M PHY
*       4: Advertising PHY is Coded PHY
*  
*  Default: 1
* @param secondary_phy   The PHY on which the advertising packets are transmitted on the secondary
*  advertising channel.
*  
*  Values:
*  
*       1: Advertising PHY is 1M PHY
*       2: Advertising PHY is 2M PHY
*       4: Advertising PHY is Coded PHY
*  
*  Default: 1
*
**/

static inline struct gecko_msg_le_gap_set_advertise_phy_rsp_t* gecko_cmd_le_gap_set_advertise_phy(uint8 handle,uint8 primary_phy,uint8 secondary_phy)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_set_advertise_phy.handle=handle;
    gecko_cmd_msg->data.cmd_le_gap_set_advertise_phy.primary_phy=primary_phy;
    gecko_cmd_msg->data.cmd_le_gap_set_advertise_phy.secondary_phy=secondary_phy;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_set_advertise_phy_id+(((3)&0xff)<<8)+(((3)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_set_advertise_phy;
}

/** 
*
* gecko_cmd_le_gap_set_advertise_configuration
*
* Enable advertising configuration flags on the given advertising set. The
* configuration change will take effect next time that advertising is enabled.
* 
* These configuration flags can be disabled using
* le_gap_clear_advertise_configuration command. 
*
* @param handle   Advertising set handle
* @param configurations   Advertising configuration flags to enable. This value can be a bitmask of
*  multiple flags. Flags:
*  
*      1 (Bit 0): Use legacy advertising PDUs. 
*      2 (Bit 1): Omit advertiser's address from all PDUs (anonymous advertising). This flag is effective only in extended advertising.
*       4 (Bit 2): Use le_gap_non_resolvable address type. Advertising must be in non-connectable mode if this configuration is enabled.
*       8 (Bit 3): Include TX power in advertising packets. This flag is effective only in extended advertising.
*  
*  Default value: 1
*
**/

static inline struct gecko_msg_le_gap_set_advertise_configuration_rsp_t* gecko_cmd_le_gap_set_advertise_configuration(uint8 handle,uint32 configurations)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_set_advertise_configuration.handle=handle;
    gecko_cmd_msg->data.cmd_le_gap_set_advertise_configuration.configurations=configurations;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_set_advertise_configuration_id+(((5)&0xff)<<8)+(((5)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_set_advertise_configuration;
}

/** 
*
* gecko_cmd_le_gap_clear_advertise_configuration
*
* Disable advertising configuration flags on the given advertising set. The
* configuration change will take effect next time that advertising is enabled.
* 
* These configuration flags can be enabled using
* le_gap_set_advertise_configuration command. 
*
* @param handle   Advertising set handle
* @param configurations   Advertising configuration flags to disable. This value can be a bitmask of
*  multiple flags. See le_gap_set_advertise_configuration for possible flags.
*
**/

static inline struct gecko_msg_le_gap_clear_advertise_configuration_rsp_t* gecko_cmd_le_gap_clear_advertise_configuration(uint8 handle,uint32 configurations)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_clear_advertise_configuration.handle=handle;
    gecko_cmd_msg->data.cmd_le_gap_clear_advertise_configuration.configurations=configurations;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_clear_advertise_configuration_id+(((5)&0xff)<<8)+(((5)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_clear_advertise_configuration;
}

/** 
*
* gecko_cmd_le_gap_start_advertising
*
* Start advertising of a given advertising set with specified discoverable and
* connectable modes.
* 
* The number of concurrent advertising is limited by MAX_ADVERTISERS
* configuration.
* 
* The number of concurrent connectable advertising is also limited by
* MAX_CONNECTIONS configuration. For example, only one connectable advertising
* can be enabled if the device has (MAX_CONNECTIONS - 1) connections when this
* command is called. The limitation does not apply to non-connectable
* advertising.
* 
* The default advertising configuration in the stack is set to using legacy
* advertising PDUs on 1M PHY. The stack will automatically select extended
* advertising PDUs if either of the following has occurred with the default
* configuration:
* 
*   1. The connectable mode is set to le_gap_connectable_non_scannable.
*   2. The primary advertising PHY is set to Coded PHY by the command le_gap_set_advertise_phy.
*   3. The user advertising data length is more than 31 bytes.
*   4. Periodic advertising is enabled.
* 
* If currently set parameters can't be used, an error is returned. Specifically,
* this command fails with the connection limit exceeded error if it causes the
* number of connections exceeding the configured MAX_CONNECTIONS value. It fails
* with the invalid parameter error if one of the following use cases occurs:
* 
*   1. Non-resolvable random address is used but the connectable mode is le_gap_connectable_scannable or le_gap_connectable_non_scannable.
*   2. le_gap_connectable_non_scannable is the connectable mode but using legacy advertising PDUs has been explicitly enabled with command le_gap_set_advertise_configuration.
*   3. Coded PHY is the primary advertising PHY but using legacy advertising PDUs has been explicitly enabled with command le_gap_set_advertise_configuration.
*   4. le_gap_connectable_scannable is the connectable mode but using extended advertising PDUs has been explicitly enabled or the primary advertising PHY is set to Coded PHY.
* 
* If advertising is enabled in user_data mode, use le_gap_bt5_set_adv_data to
* set advertising and scan response data before issuing this command. When
* advertising is enabled in modes other than user_data, advertising and scan
* response data is generated by the stack using the following procedure:
* 
*   1. Add a flags field to advertising data.
*   2. Add a TX power level field to advertising data if the TX power service exists in the local GATT database.
*   3. Add a slave connection interval range field to advertising data if the GAP peripheral preferred connection parameters characteristic exists in the local GATT database.
*   4. Add a list of 16-bit service UUIDs to advertising data if there are one or more 16-bit service UUIDs to advertise. The list is complete if all advertised 16-bit UUIDs are in advertising data. Otherwise, the list is incomplete.
*   5. Add a list of 128-bit service UUIDs to advertising data if there are one or more 128-bit service UUIDs to advertise and there is still free space for this field. The list is complete if all advertised 128-bit UUIDs are in advertising data. Otherwise, the list is incomplete. Note that an advertising data packet can contain at most one 128-bit service UUID.
*   6. Try to add the full local name to advertising data if the device is not in privacy mode. If the full local name does not fit into the remaining free space, the advertised name is a shortened version by cutting off the end if the free space has at least 6 bytes. Otherwise, the local name is added to scan response data.
* 
* Event le_connection_opened will be received when a remote device opens a
* connection to the advertiser on this advertising set and also advertising on
* the given set stops.
* 
* Event le_gap_adv_timeout will be received when the number of advertising
* events set by le_gap_set_advertise_timing command is done and advertising with
* the current set has stopped. 
*
* @param handle   Advertising set handle
* @param discover   Discoverable mode
* @param connect   Connectable mode
*
* Events generated
*
* gecko_evt_le_gap_adv_timeout - Triggered when the number of advertising events set by
*  le_gap_set_advertise_timing command is done and advertising has stopped on the
*  given advertising set.
* gecko_evt_le_connection_opened - Triggered when a remote device opens a connection to the advertiser on the
*  specified advertising set and also advertising with the current set stops.
*
**/

static inline struct gecko_msg_le_gap_start_advertising_rsp_t* gecko_cmd_le_gap_start_advertising(uint8 handle,uint8 discover,uint8 connect)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_start_advertising.handle=handle;
    gecko_cmd_msg->data.cmd_le_gap_start_advertising.discover=discover;
    gecko_cmd_msg->data.cmd_le_gap_start_advertising.connect=connect;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_start_advertising_id+(((3)&0xff)<<8)+(((3)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_start_advertising;
}

/** 
*
* gecko_cmd_le_gap_stop_advertising
*
* Stop the advertising of the given advertising set. 
*
* @param handle   Advertising set handle
*
**/

static inline struct gecko_msg_le_gap_stop_advertising_rsp_t* gecko_cmd_le_gap_stop_advertising(uint8 handle)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_stop_advertising.handle=handle;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_stop_advertising_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_stop_advertising;
}

/** 
*
* gecko_cmd_le_gap_set_discovery_timing
*
* Set the timing parameters of scanning on the specified PHYs. If the device is
* currently scanning for advertising devices on PHYs, new parameters will take
* effect when scanning is restarted. 
*
* @param phys   PHYs for which the parameters are set.
*  
*      1: 1M PHY
*       4: Coded PHY
*       5: 1M PHY and Coded PHY
* @param scan_interval   Scan interval is defined as the time interval when the device starts its last
*  scan until it begins the subsequent scan. In other words, how often to scan
*  
*      Time = Value x 0.625 ms
*      Range: 0x0004 to 0xFFFF
*      Time Range: 2.5 ms to 40.96 s
*  
*  Default value: 10 ms
*  
*  A variable delay occurs when switching channels at the end of each scanning
*  interval, which is included in the scanning interval time. During the switch
*  time, advertising packets are not received by the device. The switch time
*  variation is use case-dependent. For example, if scanning while keeping active
*  connections, the channel switch time might be longer than when scanning
*  without any active connections. Increasing the scanning interval reduces the
*  amount of time in which the device can't receive advertising packets because
*  it switches channels less often.
*  
*  After every scan interval, the scanner changes the frequency at which it
*  operates. It cycles through all three advertising channels in a round robin
*  fashion. According to the specification, all three channels must be used by a
*  scanner.
* @param scan_window   Scan window defines the duration of the scan which must be less than or equal
*  to the scan_interval
*  
*      Time = Value x 0.625 ms
*      Range: 0x0004 to 0xFFFF
*      Time Range: 2.5 ms to 40.96 s
*  
*  Default value: 10 ms Note that the packet reception is aborted if it's started
*  just before the scan window ends.
*
**/

static inline struct gecko_msg_le_gap_set_discovery_timing_rsp_t* gecko_cmd_le_gap_set_discovery_timing(uint8 phys,uint16 scan_interval,uint16 scan_window)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_set_discovery_timing.phys=phys;
    gecko_cmd_msg->data.cmd_le_gap_set_discovery_timing.scan_interval=scan_interval;
    gecko_cmd_msg->data.cmd_le_gap_set_discovery_timing.scan_window=scan_window;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_set_discovery_timing_id+(((5)&0xff)<<8)+(((5)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_set_discovery_timing;
}

/** 
*
* gecko_cmd_le_gap_set_discovery_type
*
* Set the scan type on the specified PHYs. If the device is currently scanning
* for advertising devices on PHYs, new parameters will take effect when scanning
* is restarted. 
*
* @param phys   PHYs for which the parameters are set.
*  
*      1: 1M PHY
*       4: Coded PHY
*       5: 1M PHY and Coded PHY
* @param scan_type   Scan type. Values:
*  
*       0: Passive scanning
*       1: Active scanning
*      In passive scanning mode, the device only listens to advertising packets and does not transmit packets.
*      In active scanning mode, the device sends out a scan request packet upon receiving an advertising packet from a remote device. Then, it listens to the scan response packet from the remote device.
*  
*  Default value: 0
*
**/

static inline struct gecko_msg_le_gap_set_discovery_type_rsp_t* gecko_cmd_le_gap_set_discovery_type(uint8 phys,uint8 scan_type)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_set_discovery_type.phys=phys;
    gecko_cmd_msg->data.cmd_le_gap_set_discovery_type.scan_type=scan_type;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_set_discovery_type_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_set_discovery_type;
}

/** 
*
* gecko_cmd_le_gap_start_discovery
*
* Start the GAP discovery procedure to scan for advertising devices on the
* specified scanning PHY or to perform a device discovery. To cancel an ongoing
* discovery process use the le_gap_end_procedure command.
* 
* The invalid parameter error will be returned if the scanning PHY value is
* invalid or the device does not support the PHY. 
*
* @param scanning_phy   The scanning PHY. Value:
*  
*      1: 1M PHY
*       4: Coded PHY
* @param mode   Bluetooth discovery Mode. For values see link.
*
* Events generated
*
* gecko_evt_le_gap_scan_response - This event is triggered each time an advertising packet is received. Packets
*  are not filtered in any way, so multiple events will be received for every
*  advertising device in range.
* gecko_evt_le_gap_extended_scan_response - Each time an advertising packet is received and extended scan response is
*  enabled (by le_gap_set_discovery_extended_scan_response), this event is
*  triggered. The packets are not filtered in any way. As a result, multiple
*  events will be received for every advertising device in range.
*
**/

static inline struct gecko_msg_le_gap_start_discovery_rsp_t* gecko_cmd_le_gap_start_discovery(uint8 scanning_phy,uint8 mode)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_start_discovery.scanning_phy=scanning_phy;
    gecko_cmd_msg->data.cmd_le_gap_start_discovery.mode=mode;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_start_discovery_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_start_discovery;
}

/** 
*
* gecko_cmd_le_gap_set_data_channel_classification
*
* Specify a channel classification for data channels. This classification
* persists until overwritten with a subsequent command or until the system is
* reset. 
*
* @param channel_map_len   Array length
* @param channel_map_data   This parameter is 5 bytes and contains 37 1-bit fields.  
*  The nth such field (in the range 0 to 36) contains the value for the link
*  layer channel index n.  
*  
*      0: Channel n is bad.
*       1: Channel n is unknown.
*  
*  The rest of most significant bits are reserved for future use and shall be set
*  to 0.  
*  At least two channels shall be marked as unknown.
*
**/

static inline struct gecko_msg_le_gap_set_data_channel_classification_rsp_t* gecko_cmd_le_gap_set_data_channel_classification(uint8 channel_map_len, const uint8* channel_map_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)channel_map_len > 256 - 1)
    {
        gecko_rsp_msg->data.rsp_le_gap_set_data_channel_classification.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_le_gap_set_data_channel_classification;
    }

    
    gecko_cmd_msg->data.cmd_le_gap_set_data_channel_classification.channel_map.len=channel_map_len;
    memcpy(gecko_cmd_msg->data.cmd_le_gap_set_data_channel_classification.channel_map.data,channel_map_data,channel_map_len);
    gecko_cmd_msg->header=(gecko_cmd_le_gap_set_data_channel_classification_id+(((1+channel_map_len)&0xff)<<8)+(((1+channel_map_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_set_data_channel_classification;
}

/** 
*
* gecko_cmd_le_gap_connect
*
* Connect to an advertising device with the specified initiating PHY on which
* connectable advertisements on primary advertising channels are received. The
* Bluetooth stack will enter a state where it continuously scans for the
* connectable advertising packets from the remote device, which matches the
* Bluetooth address given as a parameter. Scan parameters set in
* le_gap_set_discovery_timing are used in this operation. Upon receiving the
* advertising packet, the module will send a connection request packet to the
* target device to initiate a Bluetooth connection. To cancel an ongoing
* connection process, use the le_connection_close command with the handle
* received in response from this command.
* 
* A connection is opened in no-security mode. If the GATT client needs to read
* or write the attributes on GATT server requiring encryption or authentication,
* it must first encrypt the connection using an appropriate authentication
* method.
* 
* If a connection can't be established (for example, the remote device has gone
* out of range, has entered into deep sleep, or is not advertising), the stack
* will try to connect forever. In this case, the application will not get an
* event related to the connection request. To recover from this situation, the
* application can implement a timeout and call le_connection_close to cancel the
* connection request.
* 
* This command fails with the connection limit exceeded error if the number of
* connections attempted exceeds the configured MAX_CONNECTIONS value.
* 
* This command fails with the invalid parameter error if the initiating PHY
* value is invalid or the device does not support PHY.
* 
* Later calls of this command have to wait for the ongoing command to complete.
* A received event le_connection_opened indicates that the connection opened
* successfully and a received event le_connection_closed indicates that
* connection failures have occurred. 
*
* @param address   Address of the device to connect to
* @param address_type   Address type of the device to connect to
* @param initiating_phy   The initiating PHY. Value:
*  
*      1: 1M PHY
*       4: Coded PHY
*
* Events generated
*
* gecko_evt_le_connection_opened - This event is triggered after the connection is opened and indicates whether
*  the devices are already bonded and whether the role of the Bluetooth device is
*  Slave or Master.
* gecko_evt_le_connection_parameters - This event indicates the connection parameters and security mode of the
*  connection.
*
**/

static inline struct gecko_msg_le_gap_connect_rsp_t* gecko_cmd_le_gap_connect(bd_addr address,uint8 address_type,uint8 initiating_phy)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    memcpy(&gecko_cmd_msg->data.cmd_le_gap_connect.address,&address,sizeof(bd_addr));
    gecko_cmd_msg->data.cmd_le_gap_connect.address_type=address_type;
    gecko_cmd_msg->data.cmd_le_gap_connect.initiating_phy=initiating_phy;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_connect_id+(((8)&0xff)<<8)+(((8)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_connect;
}

/** 
*
* gecko_cmd_le_gap_set_advertise_tx_power
*
* Limit the maximum advertising TX power on the given advertising set. If the
* value goes over the global value that was set using system_set_tx_power
* command, the global value will be the maximum limit. The maximum TX power of
* legacy advertising is further constrained to be less than +10 dBm. Extended
* advertising TX power can be +10 dBm and over if Adaptive Frequency Hopping is
* enabled.
* 
* This setting will take effect next time advertising is enabled.
* 
* By default, maximum advertising TX power is limited by the global value. 
*
* @param handle   Advertising set handle
* @param power   TX power in 0.1 dBm steps. For example, the value of 10 is 1 dBm and 55 is 5.5
*  dBm.
*
**/

static inline struct gecko_msg_le_gap_set_advertise_tx_power_rsp_t* gecko_cmd_le_gap_set_advertise_tx_power(uint8 handle,int16 power)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_set_advertise_tx_power.handle=handle;
    gecko_cmd_msg->data.cmd_le_gap_set_advertise_tx_power.power=power;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_set_advertise_tx_power_id+(((3)&0xff)<<8)+(((3)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_set_advertise_tx_power;
}

/** 
*
* gecko_cmd_le_gap_set_discovery_extended_scan_response
*
* Enable or disable the extended scan response event. When the extended scan
* response event is enabled, it replaces le_gap_scan_response, that is, the
* stack will generate either le_gap_extended_scan_response or
* le_gap_scan_response, but not both. 
*
* @param enable   Values:
*  
*      0: Disable extended scan response event
*       1: Enable extended scan response event
*
**/

static inline struct gecko_msg_le_gap_set_discovery_extended_scan_response_rsp_t* gecko_cmd_le_gap_set_discovery_extended_scan_response(uint8 enable)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_set_discovery_extended_scan_response.enable=enable;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_set_discovery_extended_scan_response_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_set_discovery_extended_scan_response;
}

/** 
*
* gecko_cmd_le_gap_start_periodic_advertising
*
* Start periodic advertising on the given advertising set. The stack enables the
* advertising set automatically if the set was not enabled and the set can
* advertise using extended advertising PDUs beside the syncInfo (which is needed
* for the periodic advertising).
* 
* The invalid parameter error is returned if the application has configured
* legacy advertising PDUs or anonymous advertising, or the advertising set is
* enabled using legacy advertising PDUs. 
*
* @param handle   Advertising set handle
* @param interval_min   Minimum periodic advertising interval. Value in units of 1.25 ms
*  
*      Range: 0x06 to 0xFFFF
*      Time range: 7.5 ms to 81.92 s
*  
*  Default value: 100 ms
* @param interval_max   Maximum periodic advertising interval. Value in units of 1.25 ms
*  
*      Range: 0x06 to 0xFFFF
*      Time range: 7.5 ms to 81.92 s
*      Note: interval_max should be bigger than interval_min
*  
*  Default value: 200 ms
* @param flags   Periodic advertising configurations. Bitmask of the following:
*  
*      Bit 0: Include TX power in advertising PDU
*
**/

static inline struct gecko_msg_le_gap_start_periodic_advertising_rsp_t* gecko_cmd_le_gap_start_periodic_advertising(uint8 handle,uint16 interval_min,uint16 interval_max,uint32 flags)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_start_periodic_advertising.handle=handle;
    gecko_cmd_msg->data.cmd_le_gap_start_periodic_advertising.interval_min=interval_min;
    gecko_cmd_msg->data.cmd_le_gap_start_periodic_advertising.interval_max=interval_max;
    gecko_cmd_msg->data.cmd_le_gap_start_periodic_advertising.flags=flags;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_start_periodic_advertising_id+(((9)&0xff)<<8)+(((9)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_start_periodic_advertising;
}

/** 
*
* gecko_cmd_le_gap_stop_periodic_advertising
*
* Stop the periodic advertising on the given advertising set.
* 
* This command does not affect the enable state of the advertising set, i.e.,
* legacy or extended advertising is not stopped. 
*
* @param handle   Advertising set handle
*
**/

static inline struct gecko_msg_le_gap_stop_periodic_advertising_rsp_t* gecko_cmd_le_gap_stop_periodic_advertising(uint8 handle)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_stop_periodic_advertising.handle=handle;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_stop_periodic_advertising_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_stop_periodic_advertising;
}

/** 
*
* gecko_cmd_le_gap_set_long_advertising_data
*
* Set advertising data for a specified packet type and advertising set. Data
* currently in the system data buffer will be extracted as the advertising data.
* The buffer will be emptied after this command regardless of the completion
* status.
* 
* Prior to calling this command, add data to the buffer with one or multiple
* calls of system_data_buffer_write.
* 
* Maximum 31 bytes of data can be set for legacy advertising. Maximum 191 bytes
* of data can be set for connectable extended advertising. Maximum 1650 bytes of
* data can be set for periodic and non-connectable extended advertising, but
* advertising parameters may limit the amount of data that can be sent in a
* single advertisement.
* 
* See le_gap_bt5_set_adv_data for more details on advertising data. 
*
* @param handle   Advertising set handle
* @param packet_type   This value selects whether data is intended for advertising packets, scan
*  response packets, or periodic advertising packets. Values:
*  
*      0: Advertising packets
*      1: Scan response packets
*      2: OTA advertising packets
*      4: OTA scan response packets
*      8: Periodic advertising packets
*
**/

static inline struct gecko_msg_le_gap_set_long_advertising_data_rsp_t* gecko_cmd_le_gap_set_long_advertising_data(uint8 handle,uint8 packet_type)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_set_long_advertising_data.handle=handle;
    gecko_cmd_msg->data.cmd_le_gap_set_long_advertising_data.packet_type=packet_type;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_set_long_advertising_data_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_set_long_advertising_data;
}

/** 
*
* gecko_cmd_le_gap_enable_whitelisting
*
* Enable or disable whitelisting. The setting will be effective the next time
* that scanning is enabled. To add devices to the whitelist, either bond with
* the device or add it manually with sm_add_to_whitelist. 
*
* @param enable   1 enable, 0 disable whitelisting.
*
**/

static inline struct gecko_msg_le_gap_enable_whitelisting_rsp_t* gecko_cmd_le_gap_enable_whitelisting(uint8 enable)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_enable_whitelisting.enable=enable;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_enable_whitelisting_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_enable_whitelisting;
}

/** 
*
* gecko_cmd_le_gap_set_conn_timing_parameters
*
* Set the default Bluetooth connection parameters. The configured values are
* valid for all subsequent connections that will be established. To change
* parameters of an already established connection, use the command
* le_connection_set_timing_parameters. 
*
* @param min_interval   Minimum value for the connection event interval. This must be set less than or
*  equal to max_interval.
*  
*      Time = Value x 1.25 ms
*      Range: 0x0006 to 0x0c80
*      Time Range: 7.5 ms to 4 s
*  
*  Default value: 20 ms
* @param max_interval   Maximum value for the connection event interval. This must be set greater than
*  or equal to min_interval.
*  
*      Time = Value x 1.25 ms
*      Range: 0x0006 to 0x0c80
*      Time Range: 7.5 ms to 4 s
*  
*  Default value: 50 ms
* @param latency   Slave latency, which defines how many connection intervals the slave can skip
*  if it has no data to send
*  
*      Range: 0x0000 to 0x01f4
*  
*  Default value: 0
* @param timeout   Supervision timeout, which defines the time that the connection is maintained
*  although the devices can't communicate at the currently configured connection
*  intervals.
*  
*      Range: 0x000a to 0x0c80
*      Time = Value x 10 ms
*      Time Range: 100 ms to 32 s
*      The value in milliseconds must be larger than (1 + latency) * max_interval * 2, where max_interval is given in milliseconds
*  
*  Set the supervision timeout at a value which allows communication attempts
*  over at least a few connection intervals.
*  
*  Default value: 1000 ms
* @param min_ce_length   Minimum value for the connection event length. This must be set be less than
*  or equal to max_ce_length.
*  
*      Time = Value x 0.625 ms
*      Range: 0x0000 to 0xffff
*  
*  Default value: 0x0000
*  
*  Value is not currently used and is reserved for future. Set to 0.
* @param max_ce_length   Maximum value for the connection event length. This must be set greater than
*  or equal to min_ce_length.
*  
*      Time = Value x 0.625 ms
*      Range: 0x0000 to 0xffff
*  
*  Default value: 0xffff
*
**/

static inline struct gecko_msg_le_gap_set_conn_timing_parameters_rsp_t* gecko_cmd_le_gap_set_conn_timing_parameters(uint16 min_interval,uint16 max_interval,uint16 latency,uint16 timeout,uint16 min_ce_length,uint16 max_ce_length)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_set_conn_timing_parameters.min_interval=min_interval;
    gecko_cmd_msg->data.cmd_le_gap_set_conn_timing_parameters.max_interval=max_interval;
    gecko_cmd_msg->data.cmd_le_gap_set_conn_timing_parameters.latency=latency;
    gecko_cmd_msg->data.cmd_le_gap_set_conn_timing_parameters.timeout=timeout;
    gecko_cmd_msg->data.cmd_le_gap_set_conn_timing_parameters.min_ce_length=min_ce_length;
    gecko_cmd_msg->data.cmd_le_gap_set_conn_timing_parameters.max_ce_length=max_ce_length;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_set_conn_timing_parameters_id+(((12)&0xff)<<8)+(((12)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_set_conn_timing_parameters;
}

/** 
*
* gecko_cmd_le_gap_set_advertise_random_address
*
* Set the advertiser on an advertising set to use a random address. This
* overrides the default advertiser address which is either the public device
* address programmed at production or the address written into persistent
* storage using system_set_identity_address command. This setting is stored in
* RAM only and does not change the identity address in persistent storage.
* 
* When setting a resolvable random address, the address parameter is ignored.
* The stack generates a private resolvable random address and set it as the
* advertiser address. The generated address is returned in the response.
* 
* To use the default advertiser address, remove this setting using
* le_gap_clear_advertise_random_address command.
* 
* Wrong state error is returned if advertising has been enabled on the
* advertising set. Invalid parameter error is returned if the advertising set
* handle is invalid or the address does not conforms to the Bluetooth
* specification. 
*
* @param handle   Advertising set handle
* @param addr_type   Address type:
*  
*      1: Static device address
*      2: Private resolvable random address
*      3: Private non-resolvable random address. This type can only be used for non-connectable advertising.
* @param address   The random address to set. Ignore this field when setting a resolvable random
*  address.
*
**/

static inline struct gecko_msg_le_gap_set_advertise_random_address_rsp_t* gecko_cmd_le_gap_set_advertise_random_address(uint8 handle,uint8 addr_type,bd_addr address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_set_advertise_random_address.handle=handle;
    gecko_cmd_msg->data.cmd_le_gap_set_advertise_random_address.addr_type=addr_type;
    memcpy(&gecko_cmd_msg->data.cmd_le_gap_set_advertise_random_address.address,&address,sizeof(bd_addr));
    gecko_cmd_msg->header=(gecko_cmd_le_gap_set_advertise_random_address_id+(((8)&0xff)<<8)+(((8)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_set_advertise_random_address;
}

/** 
*
* gecko_cmd_le_gap_clear_advertise_random_address
*
* Clear the random address previously set for the advertiser address on an
* advertising set. A random address can be set using
* le_gap_set_advertise_random_address command. The default advertiser address
* will be used after this operation.
* 
* Wrong state error is returned if advertising has been enabled on the
* advertising set. Invalid parameter error is returned if the advertising set
* handle is invalid. 
*
* @param handle   Advertising set handle
*
**/

static inline struct gecko_msg_le_gap_clear_advertise_random_address_rsp_t* gecko_cmd_le_gap_clear_advertise_random_address(uint8 handle)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_clear_advertise_random_address.handle=handle;
    gecko_cmd_msg->header=(gecko_cmd_le_gap_clear_advertise_random_address_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_clear_advertise_random_address;
}

/** 
*
* gecko_cmd_sync_open
*
* Establish a synchronization with a periodic advertising from the specified
* advertiser and begin receiving periodic advertising packets. Note that
* synchronization establishment can only occur when scanning is enabled. While
* scanning is disabled, no attempt to synchronize will occur.
* 
* The application should determine skip and timeout values based on the periodic
* advertising interval provided by the advertiser. If skip and timeout are used,
* select appropriate values so that they allow a few receiving attempts.
* Periodic advertising intervals are reported in event
* le_gap_extended_scan_response. 
*
* @param adv_sid   Advertising set identifier
* @param skip   The maximum number of periodic advertising packets that can be skipped after a
*  successful receive. Range: 0x0000 to 0x01F3
* @param timeout   The maximum permitted time between successful receives. If this time is
*  exceeded, synchronization is lost. Unit: 10 ms.
*  
*      Range: 0x06 to 0xFFFF
*      Unit: 10 ms
*      Time range: 100 ms ms to 163.84 s
* @param address   Address of the advertiser
* @param address_type   Advertiser address type. Values:
*  
*      0: Public address
*       1: Random address
*
* Events generated
*
* gecko_evt_sync_opened - Triggered after the synchronization is established.
* gecko_evt_sync_data - Indicates that a periodic advertisement packet is received.
*
**/

static inline struct gecko_msg_sync_open_rsp_t* gecko_cmd_sync_open(uint8 adv_sid,uint16 skip,uint16 timeout,bd_addr address,uint8 address_type)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_sync_open.adv_sid=adv_sid;
    gecko_cmd_msg->data.cmd_sync_open.skip=skip;
    gecko_cmd_msg->data.cmd_sync_open.timeout=timeout;
    memcpy(&gecko_cmd_msg->data.cmd_sync_open.address,&address,sizeof(bd_addr));
    gecko_cmd_msg->data.cmd_sync_open.address_type=address_type;
    gecko_cmd_msg->header=(gecko_cmd_sync_open_id+(((12)&0xff)<<8)+(((12)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sync_open;
}

/** 
*
* gecko_cmd_sync_close
*
* Closes a periodic advertising synchronization or cancels an ongoing attempt of
* establishing a synchronization. 
*
* @param sync   Periodic advertising synchronization handle
*
* Events generated
*
* gecko_evt_sync_closed - Triggered after a periodic advertising synchronization has been closed or
*  canceled.
*
**/

static inline struct gecko_msg_sync_close_rsp_t* gecko_cmd_sync_close(uint8 sync)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_sync_close.sync=sync;
    gecko_cmd_msg->header=(gecko_cmd_sync_close_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sync_close;
}

/** 
*
* gecko_cmd_le_connection_set_parameters
*
* Deprecated and replaced by le_connection_set_timing_parameters command.
* 
* Request a change in the connection parameters of a Bluetooth connection. 
*
* @param connection   Connection Handle
* @param min_interval   Minimum value for the connection event interval. This must be set be less than
*  or equal to max_interval.
*  
*      Time = Value x 1.25 ms
*      Range: 0x0006 to 0x0c80
*      Time Range: 7.5 ms to 4 s
* @param max_interval   Maximum value for the connection event interval. This must be set greater than
*  or equal to min_interval.
*  
*      Time = Value x 1.25 ms
*      Range: 0x0006 to 0x0c80
*      Time Range: 7.5 ms to 4 s
* @param latency   Slave latency, which defines how many connection intervals the slave can skip
*  if it has no data to send
*  
*      Range: 0x0000 to 0x01f4
*  
*  Use 0x0000 for default value
* @param timeout   Supervision timeout, which defines the time that the connection is maintained
*  although the devices can't communicate at the currently configured connection
*  intervals.
*  
*      Range: 0x000a to 0x0c80
*      Time = Value x 10 ms
*      Time Range: 100 ms to 32 s
*      The value in milliseconds must be larger than (1 + latency) * max_interval * 2, where max_interval is given in milliseconds
*  
*  Set the supervision timeout at a value which allows communication attempts
*  over at least a few connection intervals.
*
* Events generated
*
* gecko_evt_le_connection_parameters - Triggered after new connection parameters are applied on the connection.
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_le_connection_set_parameters_rsp_t* gecko_cmd_le_connection_set_parameters(uint8 connection,uint16 min_interval,uint16 max_interval,uint16 latency,uint16 timeout)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_connection_set_parameters.connection=connection;
    gecko_cmd_msg->data.cmd_le_connection_set_parameters.min_interval=min_interval;
    gecko_cmd_msg->data.cmd_le_connection_set_parameters.max_interval=max_interval;
    gecko_cmd_msg->data.cmd_le_connection_set_parameters.latency=latency;
    gecko_cmd_msg->data.cmd_le_connection_set_parameters.timeout=timeout;
    gecko_cmd_msg->header=(gecko_cmd_le_connection_set_parameters_id+(((9)&0xff)<<8)+(((9)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_connection_set_parameters;
}

/** 
*
* gecko_cmd_le_connection_get_rssi
*
* Get the latest RSSI value of a Bluetooth connection. The RSSI value will be
* reported in a le_connection_rssi event. 
*
* @param connection   Connection handle
*
* Events generated
*
* gecko_evt_le_connection_rssi - Triggered when this command has completed.
*
**/

static inline struct gecko_msg_le_connection_get_rssi_rsp_t* gecko_cmd_le_connection_get_rssi(uint8 connection)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_connection_get_rssi.connection=connection;
    gecko_cmd_msg->header=(gecko_cmd_le_connection_get_rssi_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_connection_get_rssi;
}

/** 
*
* gecko_cmd_le_connection_disable_slave_latency
*
* Temporarily enable or disable slave latency. Used only when Bluetooth device
* is acting as slave. When slave latency is disabled, the slave latency
* connection parameter is not set to 0 but the device will wake up on every
* connection interval to receive and send packets. 
*
* @param connection   Connection Handle
* @param disable   0 enable, 1 disable slave latency. Default: 0
*
**/

static inline struct gecko_msg_le_connection_disable_slave_latency_rsp_t* gecko_cmd_le_connection_disable_slave_latency(uint8 connection,uint8 disable)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_connection_disable_slave_latency.connection=connection;
    gecko_cmd_msg->data.cmd_le_connection_disable_slave_latency.disable=disable;
    gecko_cmd_msg->header=(gecko_cmd_le_connection_disable_slave_latency_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_connection_disable_slave_latency;
}

/** 
*
* gecko_cmd_le_connection_set_phy
*
* Deprecated and replaced by le_connection_set_preferred_phy command.
* 
* Set preferred PHYs for a connection. Preferred PHYs are connection-specific.
* Event le_connection_phy_status is received when PHY update procedure is
* completed. Non-preferred PHY can also be set if remote device does not accept
* any of the preferred PHYs.
* 
* NOTE: 2 Mbit and Coded PHYs are not supported by all devices. 
*
* @param connection   
* @param phy   Preferred PHYs for connection. This parameter is a bitfield and multiple PHYs
*  can be preferred by setting multiple bits.
*  
*      0x01: 1M PHY
*      0x02: 2M PHY
*      0x04: 125k Coded PHY (S=8)
*      0x08: 500k Coded PHY (S=2)
*
* Events generated
*
* gecko_evt_le_connection_phy_status - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_le_connection_set_phy_rsp_t* gecko_cmd_le_connection_set_phy(uint8 connection,uint8 phy)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_connection_set_phy.connection=connection;
    gecko_cmd_msg->data.cmd_le_connection_set_phy.phy=phy;
    gecko_cmd_msg->header=(gecko_cmd_le_connection_set_phy_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_connection_set_phy;
}

/** 
*
* gecko_cmd_le_connection_close
*
* Close a Bluetooth connection or cancel an ongoing connection establishment
* process. The parameter is a connection handle which is reported in
* le_connection_opened event or le_gap_connect response. 
*
* @param connection   Handle of the connection to be closed
*
* Events generated
*
* gecko_evt_le_connection_closed - 
*
**/

static inline struct gecko_msg_le_connection_close_rsp_t* gecko_cmd_le_connection_close(uint8 connection)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_connection_close.connection=connection;
    gecko_cmd_msg->header=(gecko_cmd_le_connection_close_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_connection_close;
}

/** 
*
* gecko_cmd_le_connection_set_timing_parameters
*
* Request a change in the connection parameters of a Bluetooth connection. 
*
* @param connection   Connection Handle
* @param min_interval   Minimum value for the connection event interval. This must be set less than or
*  equal to max_interval.
*  
*      Time = Value x 1.25 ms
*      Range: 0x0006 to 0x0c80
*      Time Range: 7.5 ms to 4 s
* @param max_interval   Maximum value for the connection event interval. This must be set greater than
*  or equal to min_interval.
*  
*      Time = Value x 1.25 ms
*      Range: 0x0006 to 0x0c80
*      Time Range: 7.5 ms to 4 s
* @param latency   Slave latency, which defines how many connection intervals the slave can skip
*  if it has no data to send
*  
*      Range: 0x0000 to 0x01f4
*  
*  Use 0x0000 for default value
* @param timeout   Supervision timeout, which defines the time that the connection is maintained
*  although the devices can't communicate at the currently configured connection
*  intervals.
*  
*      Range: 0x000a to 0x0c80
*      Time = Value x 10 ms
*      Time Range: 100 ms to 32 s
*      The value in milliseconds must be larger than (1 + latency) * max_interval * 2, where max_interval is given in milliseconds
*  
*  Set the supervision timeout at a value which allows communication attempts
*  over at least a few connection intervals.
* @param min_ce_length   Minimum value for the connection event length. This must be set less than or
*  equal to max_ce_length.
*  
*      Time = Value x 0.625 ms
*      Range: 0x0000 to 0xffff
*  
*  Value is not currently used and is reserved for future. Set to 0.
* @param max_ce_length   Maximum value for the connection event length. This must be set greater than
*  or equal to min_ce_length.
*  
*      Time = Value x 0.625 ms
*      Range: 0x0000 to 0xffff
*  
*  Use 0xffff for no limitation.
*
* Events generated
*
* gecko_evt_le_connection_parameters - Triggered after new connection parameters are applied on the connection.
*
**/

static inline struct gecko_msg_le_connection_set_timing_parameters_rsp_t* gecko_cmd_le_connection_set_timing_parameters(uint8 connection,uint16 min_interval,uint16 max_interval,uint16 latency,uint16 timeout,uint16 min_ce_length,uint16 max_ce_length)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_connection_set_timing_parameters.connection=connection;
    gecko_cmd_msg->data.cmd_le_connection_set_timing_parameters.min_interval=min_interval;
    gecko_cmd_msg->data.cmd_le_connection_set_timing_parameters.max_interval=max_interval;
    gecko_cmd_msg->data.cmd_le_connection_set_timing_parameters.latency=latency;
    gecko_cmd_msg->data.cmd_le_connection_set_timing_parameters.timeout=timeout;
    gecko_cmd_msg->data.cmd_le_connection_set_timing_parameters.min_ce_length=min_ce_length;
    gecko_cmd_msg->data.cmd_le_connection_set_timing_parameters.max_ce_length=max_ce_length;
    gecko_cmd_msg->header=(gecko_cmd_le_connection_set_timing_parameters_id+(((13)&0xff)<<8)+(((13)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_connection_set_timing_parameters;
}

/** 
*
* gecko_cmd_le_connection_read_channel_map
*
* Read channel map for a specified connection. 
*
* @param connection   Connection Handle
*
**/

static inline struct gecko_msg_le_connection_read_channel_map_rsp_t* gecko_cmd_le_connection_read_channel_map(uint8 connection)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_connection_read_channel_map.connection=connection;
    gecko_cmd_msg->header=(gecko_cmd_le_connection_read_channel_map_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_connection_read_channel_map;
}

/** 
*
* gecko_cmd_le_connection_set_preferred_phy
*
* Sets preferred and accepted PHYs for the given connection. Event
* le_connection_phy_status is received when PHY update procedure is completed.
* Non-preferred PHY can also be set if remote device does not accept any of the
* preferred PHYs.
* 
* The parameter accepted_phy is used for specifying the PHYs that the stack can
* accept in a remote initiated PHY update request. A PHY update will not occur
* if none of the accepted PHYs presents in the request.
* 
* NOTE: 2M and Coded PHYs are not supported by all devices. 
*
* @param connection   Connection handle
* @param preferred_phy   Preferred PHYs. This parameter is a bitfield and multiple PHYs can be set.
*  
*      0x01: 1M PHY
*      0x02: 2M PHY
*      0x04: 125k Coded PHY (S=8)
*      0x08: 500k Coded PHY (S=2)
*  
*  Default: 0xff (no preference)
* @param accepted_phy   Accepted PHYs in remotely-initiated PHY update requests. This parameter is a
*  bitfield and multiple PHYs can be set.
*  
*      0x01: 1M PHY
*      0x02: 2M PHY
*      0x04: Coded PHY
*      0xff: Any PHYs
*  
*  Default: 0xff (all PHYs accepted)
*
* Events generated
*
* gecko_evt_le_connection_phy_status - 
*
**/

static inline struct gecko_msg_le_connection_set_preferred_phy_rsp_t* gecko_cmd_le_connection_set_preferred_phy(uint8 connection,uint8 preferred_phy,uint8 accepted_phy)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_connection_set_preferred_phy.connection=connection;
    gecko_cmd_msg->data.cmd_le_connection_set_preferred_phy.preferred_phy=preferred_phy;
    gecko_cmd_msg->data.cmd_le_connection_set_preferred_phy.accepted_phy=accepted_phy;
    gecko_cmd_msg->header=(gecko_cmd_le_connection_set_preferred_phy_id+(((3)&0xff)<<8)+(((3)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_connection_set_preferred_phy;
}

/** 
*
* gecko_cmd_gatt_set_max_mtu
*
* Set the maximum size of ATT Message Transfer Units (MTU). Functionality is the
* same as gatt_server_set_max_mtu and this setting applies to both GATT client
* and server. If the given value is too large according to the maximum BGAPI
* payload size, the system will select the maximum possible value as the maximum
* ATT_MTU. If maximum ATT_MTU is larger than 23, the GATT client in the stack
* will automatically send an MTU exchange request after a Bluetooth connection
* has been established. 
*
* @param max_mtu   Maximum size of Message Transfer Units (MTU) allowed
*  
*      Range: 23 to 250
*  
*  Default: 247
*
**/

static inline struct gecko_msg_gatt_set_max_mtu_rsp_t* gecko_cmd_gatt_set_max_mtu(uint16 max_mtu)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_set_max_mtu.max_mtu=max_mtu;
    gecko_cmd_msg->header=(gecko_cmd_gatt_set_max_mtu_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_set_max_mtu;
}

/** 
*
* gecko_cmd_gatt_discover_primary_services
*
* Discover all primary services of a remote GATT database. This command
* generates a unique gatt_service event for every discovered primary service.
* Received gatt_procedure_completed event indicates that this GATT procedure has
* successfully completed or failed with an error. 
*
* @param connection   
*
* Events generated
*
* gecko_evt_gatt_service - Discovered service from remote GATT database
* gecko_evt_gatt_procedure_completed - Procedure was successfully completed or failed with an error.
*
**/

static inline struct gecko_msg_gatt_discover_primary_services_rsp_t* gecko_cmd_gatt_discover_primary_services(uint8 connection)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_discover_primary_services.connection=connection;
    gecko_cmd_msg->header=(gecko_cmd_gatt_discover_primary_services_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_discover_primary_services;
}

/** 
*
* gecko_cmd_gatt_discover_primary_services_by_uuid
*
* Discover primary services with the specified UUID in a remote GATT database.
* This command generates unique gatt_service event for every discovered primary
* service. Received gatt_procedure_completed event indicates that this GATT
* procedure was successfully completed or failed with an error. 
*
* @param connection   
* @param uuid_len   Array length
* @param uuid_data   Service UUID in little endian format
*
* Events generated
*
* gecko_evt_gatt_service - Discovered service from remote GATT database.
* gecko_evt_gatt_procedure_completed - Procedure was successfully completed or failed with an error.
*
**/

static inline struct gecko_msg_gatt_discover_primary_services_by_uuid_rsp_t* gecko_cmd_gatt_discover_primary_services_by_uuid(uint8 connection,uint8 uuid_len, const uint8* uuid_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)uuid_len > 256 - 2)
    {
        gecko_rsp_msg->data.rsp_gatt_discover_primary_services_by_uuid.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_discover_primary_services_by_uuid;
    }

    
    gecko_cmd_msg->data.cmd_gatt_discover_primary_services_by_uuid.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_discover_primary_services_by_uuid.uuid.len=uuid_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_discover_primary_services_by_uuid.uuid.data,uuid_data,uuid_len);
    gecko_cmd_msg->header=(gecko_cmd_gatt_discover_primary_services_by_uuid_id+(((2+uuid_len)&0xff)<<8)+(((2+uuid_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_discover_primary_services_by_uuid;
}

/** 
*
* gecko_cmd_gatt_discover_characteristics
*
* Discover all characteristics of a GATT service from a remote GATT database.
* This command generates a unique gatt_characteristic event for every discovered
* characteristic. Received gatt_procedure_completed event indicates that this
* GATT procedure was successfully completed or failed with an error. 
*
* @param connection   
* @param service   
*
* Events generated
*
* gecko_evt_gatt_characteristic - Discovered characteristic from remote GATT database.
* gecko_evt_gatt_procedure_completed - Procedure was successfully completed or failed with an error.
*
**/

static inline struct gecko_msg_gatt_discover_characteristics_rsp_t* gecko_cmd_gatt_discover_characteristics(uint8 connection,uint32 service)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_discover_characteristics.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_discover_characteristics.service=service;
    gecko_cmd_msg->header=(gecko_cmd_gatt_discover_characteristics_id+(((5)&0xff)<<8)+(((5)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_discover_characteristics;
}

/** 
*
* gecko_cmd_gatt_discover_characteristics_by_uuid
*
* Discover all characteristics of a GATT service in a remote GATT database
* having the specified UUID. This command generates a unique gatt_characteristic
* event for every discovered characteristic having the specified UUID. Received
* gatt_procedure_completed event indicates that this GATT procedure was
* successfully completed or failed with an error. 
*
* @param connection   
* @param service   
* @param uuid_len   Array length
* @param uuid_data   Characteristic UUID in little endian format
*
* Events generated
*
* gecko_evt_gatt_characteristic - Discovered characteristic from remote GATT database.
* gecko_evt_gatt_procedure_completed - Procedure was successfully completed or failed with an error.
*
**/

static inline struct gecko_msg_gatt_discover_characteristics_by_uuid_rsp_t* gecko_cmd_gatt_discover_characteristics_by_uuid(uint8 connection,uint32 service,uint8 uuid_len, const uint8* uuid_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)uuid_len > 256 - 6)
    {
        gecko_rsp_msg->data.rsp_gatt_discover_characteristics_by_uuid.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_discover_characteristics_by_uuid;
    }

    
    gecko_cmd_msg->data.cmd_gatt_discover_characteristics_by_uuid.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_discover_characteristics_by_uuid.service=service;
    gecko_cmd_msg->data.cmd_gatt_discover_characteristics_by_uuid.uuid.len=uuid_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_discover_characteristics_by_uuid.uuid.data,uuid_data,uuid_len);
    gecko_cmd_msg->header=(gecko_cmd_gatt_discover_characteristics_by_uuid_id+(((6+uuid_len)&0xff)<<8)+(((6+uuid_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_discover_characteristics_by_uuid;
}

/** 
*
* gecko_cmd_gatt_set_characteristic_notification
*
* Enable or disable the notifications and indications sent from a remote GATT
* server. This procedure discovers a characteristic client configuration
* descriptor and writes the related configuration flags to a remote GATT
* database. A received gatt_procedure_completed event indicates that this GATT
* procedure was successfully completed or that it failed with an error. 
*
* @param connection   
* @param characteristic   
* @param flags   Characteristic client configuration flags
*
* Events generated
*
* gecko_evt_gatt_procedure_completed - Procedure was successfully completed or failed with an error.
* gecko_evt_gatt_characteristic_value - If an indication or notification has been enabled for a characteristic, this
*  event is triggered whenever an indication or notification is sent by the
*  remote GATT server. The triggering conditions of the GATT server are defined
*  by an upper level, for example by a profile. As a result, it is possible that
*  no values are ever received, or that it may take time, depending on how the
*  server is configured.
*
**/

static inline struct gecko_msg_gatt_set_characteristic_notification_rsp_t* gecko_cmd_gatt_set_characteristic_notification(uint8 connection,uint16 characteristic,uint8 flags)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_set_characteristic_notification.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_set_characteristic_notification.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_gatt_set_characteristic_notification.flags=flags;
    gecko_cmd_msg->header=(gecko_cmd_gatt_set_characteristic_notification_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_set_characteristic_notification;
}

/** 
*
* gecko_cmd_gatt_discover_descriptors
*
* Discover all descriptors of a GATT characteristic in a remote GATT database.
* It generates a unique gatt_descriptor event for every discovered descriptor.
* Received gatt_procedure_completed event indicates that this GATT procedure has
* successfully completed or failed with an error. 
*
* @param connection   
* @param characteristic   
*
* Events generated
*
* gecko_evt_gatt_descriptor - Discovered descriptor from remote GATT database.
* gecko_evt_gatt_procedure_completed - Procedure was successfully completed or failed with an error.
*
**/

static inline struct gecko_msg_gatt_discover_descriptors_rsp_t* gecko_cmd_gatt_discover_descriptors(uint8 connection,uint16 characteristic)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_discover_descriptors.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_discover_descriptors.characteristic=characteristic;
    gecko_cmd_msg->header=(gecko_cmd_gatt_discover_descriptors_id+(((3)&0xff)<<8)+(((3)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_discover_descriptors;
}

/** 
*
* gecko_cmd_gatt_read_characteristic_value
*
* Read the value of a characteristic from a remote GATT database. A single
* gatt_characteristic_value event is generated if the characteristic value fits
* in one ATT PDU. Otherwise, more than one  gatt_characteristic_value event is
* generated because the firmware will automatically use the Read Long
* Characteristic Values procedure. A received gatt_procedure_completed event
* indicates that all data was read successfully or that an error response was
* received.
* 
* Note that the GATT client does not verify if the requested attribute is a
* characteristic value. Therefore, before calling this command, ensure that the
* attribute handle is for a characteristic value, for example, by performing
* characteristic discovery. 
*
* @param connection   
* @param characteristic   
*
* Events generated
*
* gecko_evt_gatt_characteristic_value - Contains the data of a characteristic sent by the GATT Server.
* gecko_evt_gatt_procedure_completed - Procedure was successfully completed or failed with an error.
*
**/

static inline struct gecko_msg_gatt_read_characteristic_value_rsp_t* gecko_cmd_gatt_read_characteristic_value(uint8 connection,uint16 characteristic)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_read_characteristic_value.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_read_characteristic_value.characteristic=characteristic;
    gecko_cmd_msg->header=(gecko_cmd_gatt_read_characteristic_value_id+(((3)&0xff)<<8)+(((3)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_read_characteristic_value;
}

/** 
*
* gecko_cmd_gatt_read_characteristic_value_by_uuid
*
* Read characteristic values of a service from a remote GATT database by giving
* the UUID of the characteristic and the handle of the service containing this
* characteristic. If multiple characteristic values are received in one ATT PDU,
* then one  gatt_characteristic_value event is generated for each value. If the
* first characteristic value does not fit in one ATT PDU, the firmware
* automatically uses the Read Long Characteristic Values procedure and generate
* more  gatt_characteristic_value events until the value has been completely
* read. A received gatt_procedure_completed event indicates that all data was
* read successfully or that an error response was received. 
*
* @param connection   
* @param service   
* @param uuid_len   Array length
* @param uuid_data   Characteristic UUID in little endian format
*
* Events generated
*
* gecko_evt_gatt_characteristic_value - Contains the data of a characteristic sent by the GATT Server.
* gecko_evt_gatt_procedure_completed - Procedure was successfully completed or failed with an error.
*
**/

static inline struct gecko_msg_gatt_read_characteristic_value_by_uuid_rsp_t* gecko_cmd_gatt_read_characteristic_value_by_uuid(uint8 connection,uint32 service,uint8 uuid_len, const uint8* uuid_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)uuid_len > 256 - 6)
    {
        gecko_rsp_msg->data.rsp_gatt_read_characteristic_value_by_uuid.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_read_characteristic_value_by_uuid;
    }

    
    gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_by_uuid.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_by_uuid.service=service;
    gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_by_uuid.uuid.len=uuid_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_by_uuid.uuid.data,uuid_data,uuid_len);
    gecko_cmd_msg->header=(gecko_cmd_gatt_read_characteristic_value_by_uuid_id+(((6+uuid_len)&0xff)<<8)+(((6+uuid_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_read_characteristic_value_by_uuid;
}

/** 
*
* gecko_cmd_gatt_write_characteristic_value
*
* Write the value of a characteristic in a remote GATT database. If the given
* value does not fit in one ATT PDU, "write long" GATT procedure is used
* automatically. Received gatt_procedure_completed event indicates that all data
* was written successfully or that an error response was received. 
*
* @param connection   
* @param characteristic   
* @param value_len   Array length
* @param value_data   Characteristic value
*
* Events generated
*
* gecko_evt_gatt_procedure_completed - Procedure was successfully completed or failed with an error.
*
**/

static inline struct gecko_msg_gatt_write_characteristic_value_rsp_t* gecko_cmd_gatt_write_characteristic_value(uint8 connection,uint16 characteristic,uint8 value_len, const uint8* value_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)value_len > 256 - 4)
    {
        gecko_rsp_msg->data.rsp_gatt_write_characteristic_value.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_write_characteristic_value;
    }

    
    gecko_cmd_msg->data.cmd_gatt_write_characteristic_value.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_write_characteristic_value.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_gatt_write_characteristic_value.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_write_characteristic_value.value.data,value_data,value_len);
    gecko_cmd_msg->header=(gecko_cmd_gatt_write_characteristic_value_id+(((4+value_len)&0xff)<<8)+(((4+value_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_write_characteristic_value;
}

/** 
*
* gecko_cmd_gatt_write_characteristic_value_without_response
*
* Write the value of a characteristic in a remote GATT server. It does not
* generate an event. All failures on the server are ignored silently. For
* example, if an error is generated in the remote GATT server and the given
* value is not written into the database, no error message will be reported to
* the local GATT client. Note that this command can't be used to write long
* values. At most ATT_MTU - 3 amount of data can be sent once. 
*
* @param connection   
* @param characteristic   
* @param value_len   Array length
* @param value_data   Characteristic value
*
**/

static inline struct gecko_msg_gatt_write_characteristic_value_without_response_rsp_t* gecko_cmd_gatt_write_characteristic_value_without_response(uint8 connection,uint16 characteristic,uint8 value_len, const uint8* value_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)value_len > 256 - 4)
    {
        gecko_rsp_msg->data.rsp_gatt_write_characteristic_value_without_response.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_write_characteristic_value_without_response;
    }

    
    gecko_cmd_msg->data.cmd_gatt_write_characteristic_value_without_response.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_write_characteristic_value_without_response.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_gatt_write_characteristic_value_without_response.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_write_characteristic_value_without_response.value.data,value_data,value_len);
    gecko_cmd_msg->header=(gecko_cmd_gatt_write_characteristic_value_without_response_id+(((4+value_len)&0xff)<<8)+(((4+value_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_write_characteristic_value_without_response;
}

/** 
*
* gecko_cmd_gatt_prepare_characteristic_value_write
*
* Add a characteristic value to the write queue of a remote GATT server. It can
* be used when long attributes need to be written or a set of values needs to be
* written atomically. At most ATT_MTU - 5 amount of data can be sent at one
* time. Writes are executed or canceled with the
* execute_characteristic_value_write command. Whether the writes succeed or not
* is indicated in the response of the execute_characteristic_value_write
* command.
* 
* In all use cases where the amount of data to transfer fits into the BGAPI
* payload, use the command gatt_write_characteristic_value to write long values
* because it transparently performs the prepare_write and execute_write
* commands. 
*
* @param connection   
* @param characteristic   
* @param offset   Offset of the characteristic value
* @param value_len   Array length
* @param value_data   Value to write into the specified characteristic of the remote GATT database
*
* Events generated
*
* gecko_evt_gatt_procedure_completed - Procedure was successfully completed or failed with an error.
*
**/

static inline struct gecko_msg_gatt_prepare_characteristic_value_write_rsp_t* gecko_cmd_gatt_prepare_characteristic_value_write(uint8 connection,uint16 characteristic,uint16 offset,uint8 value_len, const uint8* value_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)value_len > 256 - 6)
    {
        gecko_rsp_msg->data.rsp_gatt_prepare_characteristic_value_write.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_prepare_characteristic_value_write;
    }

    
    gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_write.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_write.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_write.offset=offset;
    gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_write.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_write.value.data,value_data,value_len);
    gecko_cmd_msg->header=(gecko_cmd_gatt_prepare_characteristic_value_write_id+(((6+value_len)&0xff)<<8)+(((6+value_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_prepare_characteristic_value_write;
}

/** 
*
* gecko_cmd_gatt_execute_characteristic_value_write
*
* Commit or cancel previously queued writes to a long characteristic of a remote
* GATT server. Writes are sent to the queue with
* prepare_characteristic_value_write command. Content, offset, and length of
* queued values are validated by this procedure. A received
* gatt_procedure_completed event indicates that all data was written
* successfully or that an error response was received. 
*
* @param connection   
* @param flags   gatt_execute_write_flag
*  
*      0: cancel
*      1: commit
*
* Events generated
*
* gecko_evt_gatt_procedure_completed - Procedure was successfully completed or failed with an error.
*
**/

static inline struct gecko_msg_gatt_execute_characteristic_value_write_rsp_t* gecko_cmd_gatt_execute_characteristic_value_write(uint8 connection,uint8 flags)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_execute_characteristic_value_write.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_execute_characteristic_value_write.flags=flags;
    gecko_cmd_msg->header=(gecko_cmd_gatt_execute_characteristic_value_write_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_execute_characteristic_value_write;
}

/** 
*
* gecko_cmd_gatt_send_characteristic_confirmation
*
* Send a confirmation to a remote GATT server after receiving a characteristic
* indication. The gatt_characteristic_value event carries the att_opcode
* containing handle_value_indication (0x1d), which reveals that an indication
* has been received and must be confirmed with this command. The confirmation
* needs to be sent within 30 seconds, otherwise further GATT transactions are
* not allowed by the remote side. 
*
* @param connection   
*
**/

static inline struct gecko_msg_gatt_send_characteristic_confirmation_rsp_t* gecko_cmd_gatt_send_characteristic_confirmation(uint8 connection)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_send_characteristic_confirmation.connection=connection;
    gecko_cmd_msg->header=(gecko_cmd_gatt_send_characteristic_confirmation_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_send_characteristic_confirmation;
}

/** 
*
* gecko_cmd_gatt_read_descriptor_value
*
* Read the descriptor value of a characteristic in a remote GATT database. A
* single  gatt_descriptor_value event is generated if the descriptor value fits
* in one ATT PDU. Otherwise, more than one gatt_descriptor_value events are
* generated because the firmware automatically uses the Read Long Characteristic
* Values procedure. A received gatt_procedure_completed event indicates that all
* data was read successfully or that an error response was received. 
*
* @param connection   
* @param descriptor   
*
* Events generated
*
* gecko_evt_gatt_descriptor_value - Descriptor value received from the remote GATT server.
* gecko_evt_gatt_procedure_completed - Procedure was successfully completed or failed with an error.
*
**/

static inline struct gecko_msg_gatt_read_descriptor_value_rsp_t* gecko_cmd_gatt_read_descriptor_value(uint8 connection,uint16 descriptor)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_read_descriptor_value.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_read_descriptor_value.descriptor=descriptor;
    gecko_cmd_msg->header=(gecko_cmd_gatt_read_descriptor_value_id+(((3)&0xff)<<8)+(((3)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_read_descriptor_value;
}

/** 
*
* gecko_cmd_gatt_write_descriptor_value
*
* Write the value of a characteristic descriptor in a remote GATT database. If
* the given value does not fit in one ATT PDU, "write long" GATT procedure is
* used automatically. Received gatt_procedure_completed event indicates either
* that all data was written successfully or that an error response was received. 
*
* @param connection   
* @param descriptor   
* @param value_len   Array length
* @param value_data   Descriptor value
*
* Events generated
*
* gecko_evt_gatt_procedure_completed - Procedure was successfully completed or failed with an error.
*
**/

static inline struct gecko_msg_gatt_write_descriptor_value_rsp_t* gecko_cmd_gatt_write_descriptor_value(uint8 connection,uint16 descriptor,uint8 value_len, const uint8* value_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)value_len > 256 - 4)
    {
        gecko_rsp_msg->data.rsp_gatt_write_descriptor_value.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_write_descriptor_value;
    }

    
    gecko_cmd_msg->data.cmd_gatt_write_descriptor_value.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_write_descriptor_value.descriptor=descriptor;
    gecko_cmd_msg->data.cmd_gatt_write_descriptor_value.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_write_descriptor_value.value.data,value_data,value_len);
    gecko_cmd_msg->header=(gecko_cmd_gatt_write_descriptor_value_id+(((4+value_len)&0xff)<<8)+(((4+value_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_write_descriptor_value;
}

/** 
*
* gecko_cmd_gatt_find_included_services
*
* Find the services that are included by a service in a remote GATT database.
* This command generates a unique gatt_service event for each included service.
* The received gatt_procedure_completed event indicates that this GATT procedure
* was successfully completed or failed with an error. 
*
* @param connection   
* @param service   
*
* Events generated
*
* gecko_evt_gatt_service - Discovered service from remote GATT database.
* gecko_evt_gatt_procedure_completed - Procedure was successfully completed or failed with an error.
*
**/

static inline struct gecko_msg_gatt_find_included_services_rsp_t* gecko_cmd_gatt_find_included_services(uint8 connection,uint32 service)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_find_included_services.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_find_included_services.service=service;
    gecko_cmd_msg->header=(gecko_cmd_gatt_find_included_services_id+(((5)&0xff)<<8)+(((5)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_find_included_services;
}

/** 
*
* gecko_cmd_gatt_read_multiple_characteristic_values
*
* Read values of multiple characteristics from a remote GATT database at once.
* The GATT server returns values in one ATT PDU as the response. If the total
* set of values is greater than (ATT_MTU - 1) bytes in length, only the first
* (ATT_MTU - 1) bytes are included. A single gatt_characteristic_value event is
* generated, in which the characteristic is set to 0 and data in the value
* parameter is a concatenation of characteristic values in the order they were
* requested. The received gatt_procedure_completed event indicates either that
* this GATT procedure was successfully completed or failed with an error.
* 
* Use this command only for characteristics values that have a known fixed size,
* except the last one that could have variable length.
* 
* When the remote GATT server is from Silicon Labs Bluetooth stack, the server
* returns ATT Invalid PDU (0x04) if this command only reads one characteristic
* value. The server returns ATT Application Error 0x80 if this command reads the
* value of a user-type characteristic. 
*
* @param connection   
* @param characteristic_list_len   Array length
* @param characteristic_list_data   List of uint16 characteristic handles each in little endian format.
*
* Events generated
*
* gecko_evt_gatt_characteristic_value - A concatenation of characteristic values in the order they were requested
* gecko_evt_gatt_procedure_completed - Procedure was either successfully completed or failed with an error.
*
**/

static inline struct gecko_msg_gatt_read_multiple_characteristic_values_rsp_t* gecko_cmd_gatt_read_multiple_characteristic_values(uint8 connection,uint8 characteristic_list_len, const uint8* characteristic_list_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)characteristic_list_len > 256 - 2)
    {
        gecko_rsp_msg->data.rsp_gatt_read_multiple_characteristic_values.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_read_multiple_characteristic_values;
    }

    
    gecko_cmd_msg->data.cmd_gatt_read_multiple_characteristic_values.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_read_multiple_characteristic_values.characteristic_list.len=characteristic_list_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_read_multiple_characteristic_values.characteristic_list.data,characteristic_list_data,characteristic_list_len);
    gecko_cmd_msg->header=(gecko_cmd_gatt_read_multiple_characteristic_values_id+(((2+characteristic_list_len)&0xff)<<8)+(((2+characteristic_list_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_read_multiple_characteristic_values;
}

/** 
*
* gecko_cmd_gatt_read_characteristic_value_from_offset
*
* Read a partial characteristic value with a specified offset and maximum length
* from a remote GATT database. It is equivalent to
* gatt_read_characteristic_value if both the offset and maximum length
* parameters are 0. A single gatt_characteristic_value event is generated if the
* value to read fits in one ATT PDU. Otherwise, more than one
* gatt_characteristic_value events are generated because the firmware will
* automatically use the Read Long Characteristic Values procedure. A received
* gatt_procedure_completed event indicates that all data was read successfully
* or that an error response was received. 
*
* @param connection   
* @param characteristic   
* @param offset   Offset of the characteristic value
* @param maxlen   Maximum bytes to read. If this parameter is 0, all characteristic values
*  starting at a given offset will be read.
*
* Events generated
*
* gecko_evt_gatt_characteristic_value - Contains the data of a characteristic sent by the GATT Server.
* gecko_evt_gatt_procedure_completed - Procedure was successfully completed or failed with an error.
*
**/

static inline struct gecko_msg_gatt_read_characteristic_value_from_offset_rsp_t* gecko_cmd_gatt_read_characteristic_value_from_offset(uint8 connection,uint16 characteristic,uint16 offset,uint16 maxlen)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_from_offset.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_from_offset.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_from_offset.offset=offset;
    gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_from_offset.maxlen=maxlen;
    gecko_cmd_msg->header=(gecko_cmd_gatt_read_characteristic_value_from_offset_id+(((7)&0xff)<<8)+(((7)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_read_characteristic_value_from_offset;
}

/** 
*
* gecko_cmd_gatt_prepare_characteristic_value_reliable_write
*
* Add a characteristic value to the write queue of a remote GATT server and
* verifies whether the value was correctly received by the server. Received
* gatt_procedure_completed event indicates that this GATT procedure was
* successfully completed or failed with an error. Specifically, error code
* 0x0194 (data_corrupted) will be returned if the value received from the GATT
* server's response fails to pass the reliable write verification. At most
* ATT_MTU - 5 amount of data can be sent at one time. Writes are executed or
* canceled with the execute_characteristic_value_write command. Whether the
* writes succeed or not is indicated in the response of the
* execute_characteristic_value_write command. 
*
* @param connection   
* @param characteristic   
* @param offset   Offset of the characteristic value
* @param value_len   Array length
* @param value_data   Value to write into the specified characteristic of the remote GATT database
*
* Events generated
*
* gecko_evt_gatt_procedure_completed - Procedure was successfully completed or failed with an error.
*
**/

static inline struct gecko_msg_gatt_prepare_characteristic_value_reliable_write_rsp_t* gecko_cmd_gatt_prepare_characteristic_value_reliable_write(uint8 connection,uint16 characteristic,uint16 offset,uint8 value_len, const uint8* value_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)value_len > 256 - 6)
    {
        gecko_rsp_msg->data.rsp_gatt_prepare_characteristic_value_reliable_write.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_prepare_characteristic_value_reliable_write;
    }

    
    gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_reliable_write.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_reliable_write.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_reliable_write.offset=offset;
    gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_reliable_write.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_reliable_write.value.data,value_data,value_len);
    gecko_cmd_msg->header=(gecko_cmd_gatt_prepare_characteristic_value_reliable_write_id+(((6+value_len)&0xff)<<8)+(((6+value_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_prepare_characteristic_value_reliable_write;
}

/** 
*
* gecko_cmd_gatt_server_read_attribute_value
*
* Read the value of an attribute from a local GATT database. Only (maximum BGAPI
* payload size - 3) amount of data can be read at once. The application can
* continue reading with increased offset value if it receives (maximum BGAPI
* payload size - 3) amount of data. 
*
* @param attribute   Attribute handle
* @param offset   Value offset
*
**/

static inline struct gecko_msg_gatt_server_read_attribute_value_rsp_t* gecko_cmd_gatt_server_read_attribute_value(uint16 attribute,uint16 offset)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_server_read_attribute_value.attribute=attribute;
    gecko_cmd_msg->data.cmd_gatt_server_read_attribute_value.offset=offset;
    gecko_cmd_msg->header=(gecko_cmd_gatt_server_read_attribute_value_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_server_read_attribute_value;
}

/** 
*
* gecko_cmd_gatt_server_read_attribute_type
*
* Read the type of an attribute from a local GATT database. The type is a UUID,
* usually 16 or 128 bits long in little endian format. 
*
* @param attribute   Attribute handle
*
**/

static inline struct gecko_msg_gatt_server_read_attribute_type_rsp_t* gecko_cmd_gatt_server_read_attribute_type(uint16 attribute)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_server_read_attribute_type.attribute=attribute;
    gecko_cmd_msg->header=(gecko_cmd_gatt_server_read_attribute_type_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_server_read_attribute_type;
}

/** 
*
* gecko_cmd_gatt_server_write_attribute_value
*
* Write the value of an attribute in the local GATT database. Writing the value
* of a characteristic of the local GATT database will not trigger notifications
* or indications to the remote GATT client if the characteristic has a property
* to indicate or notify and the client has enabled notification or indication.
* Notifications and indications are sent to the remote GATT client using
* gatt_server_send_characteristic_notification command. 
*
* @param attribute   Attribute handle
* @param offset   Value offset
* @param value_len   Array length
* @param value_data   Value
*
**/

static inline struct gecko_msg_gatt_server_write_attribute_value_rsp_t* gecko_cmd_gatt_server_write_attribute_value(uint16 attribute,uint16 offset,uint8 value_len, const uint8* value_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)value_len > 256 - 5)
    {
        gecko_rsp_msg->data.rsp_gatt_server_write_attribute_value.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_server_write_attribute_value;
    }

    
    gecko_cmd_msg->data.cmd_gatt_server_write_attribute_value.attribute=attribute;
    gecko_cmd_msg->data.cmd_gatt_server_write_attribute_value.offset=offset;
    gecko_cmd_msg->data.cmd_gatt_server_write_attribute_value.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_server_write_attribute_value.value.data,value_data,value_len);
    gecko_cmd_msg->header=(gecko_cmd_gatt_server_write_attribute_value_id+(((5+value_len)&0xff)<<8)+(((5+value_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_server_write_attribute_value;
}

/** 
*
* gecko_cmd_gatt_server_send_user_read_response
*
* Send a response to a user_read_request event. The response needs to be sent
* within 30 seconds, otherwise no more GATT transactions are allowed by the
* remote side. If attr_errorcode is set to 0, the characteristic value is sent
* to the remote GATT client in the standard way. Other attr_errorcode values
* will cause the local GATT server to send an attribute protocol error response
* instead of the actual data. At most ATT_MTU - 1 amount of data can be sent at
* one time. The client will continue reading by sending new read request with an
* increased offset value if it receives ATT_MTU - 1 amount of data. 
*
* @param connection   
* @param characteristic   
* @param att_errorcode   
* @param value_len   Array length
* @param value_data   Characteristic value to send to the GATT client. Ignored if att_errorcode is
*  not 0.
*
**/

static inline struct gecko_msg_gatt_server_send_user_read_response_rsp_t* gecko_cmd_gatt_server_send_user_read_response(uint8 connection,uint16 characteristic,uint8 att_errorcode,uint8 value_len, const uint8* value_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)value_len > 256 - 5)
    {
        gecko_rsp_msg->data.rsp_gatt_server_send_user_read_response.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_server_send_user_read_response;
    }

    
    gecko_cmd_msg->data.cmd_gatt_server_send_user_read_response.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_server_send_user_read_response.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_gatt_server_send_user_read_response.att_errorcode=att_errorcode;
    gecko_cmd_msg->data.cmd_gatt_server_send_user_read_response.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_server_send_user_read_response.value.data,value_data,value_len);
    gecko_cmd_msg->header=(gecko_cmd_gatt_server_send_user_read_response_id+(((5+value_len)&0xff)<<8)+(((5+value_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_server_send_user_read_response;
}

/** 
*
* gecko_cmd_gatt_server_send_user_write_response
*
* Send a response to a gatt_server_user_write_request event when parameter
* att_opcode in the event is Write Request (see att_opcode). The response needs
* to be sent within 30 seconds, otherwise no more GATT transactions are allowed
* by the remote side. If attr_errorcode is set to 0, the ATT protocol's write
* response is sent to indicate to the remote GATT client that the write
* operation was processed successfully. Other values will cause the local GATT
* server to send an ATT protocol error response. 
*
* @param connection   
* @param characteristic   
* @param att_errorcode   
*
**/

static inline struct gecko_msg_gatt_server_send_user_write_response_rsp_t* gecko_cmd_gatt_server_send_user_write_response(uint8 connection,uint16 characteristic,uint8 att_errorcode)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_server_send_user_write_response.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_server_send_user_write_response.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_gatt_server_send_user_write_response.att_errorcode=att_errorcode;
    gecko_cmd_msg->header=(gecko_cmd_gatt_server_send_user_write_response_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_server_send_user_write_response;
}

/** 
*
* gecko_cmd_gatt_server_send_characteristic_notification
*
* Send notifications or indications to one or more remote GATT clients. At most
* ATT_MTU - 3 amount of data can be sent one time.
* 
* A notification or indication is sent only if the client has enabled it by
* setting the corresponding flag to the Client Characteristic Configuration
* descriptor. If the Client Characteristic Configuration descriptor supports
* both notifications and indications, the stack will always send a notification
* even when the client has enabled both.
* 
* A new indication to a GATT client can't be sent until an outstanding
* indication procedure with the same client has completed. The procedure is
* completed when a confirmation from the client is received. The confirmation is
* indicated by gatt_server_characteristic_status event.
* 
* Error bg_err_wrong_state is returned if the characteristic does not have the
* notification property, or if the client has not enabled the notification. The
* same applies to the indication property, and in addition, bg_err_wrong_state
* is returned if an indication procedure with the same client is outstanding.
* Always check the response for this command for errors before trying to send
* more data. 
*
* @param connection   A handle of the connection over which the notification or indication is sent.
*  Values:
*  
*      0xff: Sends notification or indication to all connected devices.
*       Other: Connection handle
* @param characteristic   Characteristic handle
* @param value_len   Array length
* @param value_data   Value to be notified or indicated
*
**/

static inline struct gecko_msg_gatt_server_send_characteristic_notification_rsp_t* gecko_cmd_gatt_server_send_characteristic_notification(uint8 connection,uint16 characteristic,uint8 value_len, const uint8* value_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)value_len > 256 - 4)
    {
        gecko_rsp_msg->data.rsp_gatt_server_send_characteristic_notification.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_server_send_characteristic_notification;
    }

    
    gecko_cmd_msg->data.cmd_gatt_server_send_characteristic_notification.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_server_send_characteristic_notification.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_gatt_server_send_characteristic_notification.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_server_send_characteristic_notification.value.data,value_data,value_len);
    gecko_cmd_msg->header=(gecko_cmd_gatt_server_send_characteristic_notification_id+(((4+value_len)&0xff)<<8)+(((4+value_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_server_send_characteristic_notification;
}

/** 
*
* gecko_cmd_gatt_server_find_attribute
*
* Find attributes of a certain type from a local GATT database. The type is
* usually given as a 16-bit or 128-bit UUID in little endian format. 
*
* @param start   Search start handle
* @param type_len   Array length
* @param type_data   
*
**/

static inline struct gecko_msg_gatt_server_find_attribute_rsp_t* gecko_cmd_gatt_server_find_attribute(uint16 start,uint8 type_len, const uint8* type_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)type_len > 256 - 3)
    {
        gecko_rsp_msg->data.rsp_gatt_server_find_attribute.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_server_find_attribute;
    }

    
    gecko_cmd_msg->data.cmd_gatt_server_find_attribute.start=start;
    gecko_cmd_msg->data.cmd_gatt_server_find_attribute.type.len=type_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_server_find_attribute.type.data,type_data,type_len);
    gecko_cmd_msg->header=(gecko_cmd_gatt_server_find_attribute_id+(((3+type_len)&0xff)<<8)+(((3+type_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_server_find_attribute;
}

/** 
*
* gecko_cmd_gatt_server_set_capabilities
*
* Reset capabilities that should be enabled by the GATT database. A service is
* visible to remote GATT clients if at least one of its capabilities is enabled.
* The same applies to a characteristic and its attributes. Capability
* identifiers and their corresponding bit flag values can be found in the auto-
* generated database header file. See UG118: Blue Gecko Bluetooth Profile
* Toolkit Developer's Guide for how to declare capabilities in the GATT
* database.
* 
* Changing the capabilities of a database effectively causes a database change
* (attributes being added or removed) from a remote GATT client point of view.
* If the database has a Generic Attribute service and Service Changed
* characteristic, the stack will monitor the local database change status and
* manage service changed indications for a GATT client that has enabled the
* indication configuration of the Service Changed characteristic. 
*
* @param caps   Bit flags of capabilities to reset. Value 0 sets the default database
*  capabilities.
* @param reserved   Use the value 0 on this reserved field. Do not use none-zero values because
*  they are reserved for future use.
*
**/

static inline struct gecko_msg_gatt_server_set_capabilities_rsp_t* gecko_cmd_gatt_server_set_capabilities(uint32 caps,uint32 reserved)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_server_set_capabilities.caps=caps;
    gecko_cmd_msg->data.cmd_gatt_server_set_capabilities.reserved=reserved;
    gecko_cmd_msg->header=(gecko_cmd_gatt_server_set_capabilities_id+(((8)&0xff)<<8)+(((8)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_server_set_capabilities;
}

/** 
*
* gecko_cmd_gatt_server_set_max_mtu
*
* Set the maximum size of ATT Message Transfer Units (MTU). The functionality is
* the same as gatt_set_max_mtu and this setting applies to both GATT client and
* server. If the given value is too large according to the maximum BGAPI payload
* size, the system will select the maximum possible value as the maximum
* ATT_MTU. If the maximum ATT_MTU is larger than 23, the GATT client in the
* stack will automatically send an MTU exchange request after a Bluetooth
* connection was established. 
*
* @param max_mtu   Maximum size of Message Transfer Units (MTU) allowed
*  
*      Range: 23 to 250
*  
*  Default: 247
*
**/

static inline struct gecko_msg_gatt_server_set_max_mtu_rsp_t* gecko_cmd_gatt_server_set_max_mtu(uint16 max_mtu)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_server_set_max_mtu.max_mtu=max_mtu;
    gecko_cmd_msg->header=(gecko_cmd_gatt_server_set_max_mtu_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_server_set_max_mtu;
}

/** 
*
* gecko_cmd_gatt_server_get_mtu
*
* Get the size of ATT Message Transfer Units (MTU) for a connection. 
*
* @param connection   
*
**/

static inline struct gecko_msg_gatt_server_get_mtu_rsp_t* gecko_cmd_gatt_server_get_mtu(uint8 connection)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_server_get_mtu.connection=connection;
    gecko_cmd_msg->header=(gecko_cmd_gatt_server_get_mtu_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_server_get_mtu;
}

/** 
*
* gecko_cmd_gatt_server_enable_capabilities
*
* Enable additional capabilities in the local GATT database. Already enabled
* capabilities keep unchanged after this command. See
* gatt_server_set_capabilities for more formation. 
*
* @param caps   Capabilities to enable
*
**/

static inline struct gecko_msg_gatt_server_enable_capabilities_rsp_t* gecko_cmd_gatt_server_enable_capabilities(uint32 caps)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_server_enable_capabilities.caps=caps;
    gecko_cmd_msg->header=(gecko_cmd_gatt_server_enable_capabilities_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_server_enable_capabilities;
}

/** 
*
* gecko_cmd_gatt_server_disable_capabilities
*
* Disable the given capabilities in the local GATT database. See
* gatt_server_set_capabilities for more formation. 
*
* @param caps   Capabilities to disable
*
**/

static inline struct gecko_msg_gatt_server_disable_capabilities_rsp_t* gecko_cmd_gatt_server_disable_capabilities(uint32 caps)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_server_disable_capabilities.caps=caps;
    gecko_cmd_msg->header=(gecko_cmd_gatt_server_disable_capabilities_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_server_disable_capabilities;
}

/** 
*
* gecko_cmd_gatt_server_get_enabled_capabilities
*
* Get capabilities currently enabled in the local GATT database. 
*
*
**/

static inline struct gecko_msg_gatt_server_get_enabled_capabilities_rsp_t* gecko_cmd_gatt_server_get_enabled_capabilities()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_gatt_server_get_enabled_capabilities_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_server_get_enabled_capabilities;
}

/** 
*
* gecko_cmd_hardware_set_soft_timer
*
* Start a software timer. Multiple concurrent timers can be running
* simultaneously. 256 unique timer handles (IDs) are available. The maximum
* number of concurrent timers is configurable at device initialization. Up to 16
* concurrent timers can be configured. The default configuration is 4. As the
* RAM for storing timer data is pre-allocated at initialization, an application
* should not configure the amount more than it needs for minimizing RAM usage. 
*
* @param time   Frequency interval of events, which indicates how often to send events in
*  hardware clock ticks (1 second is equal to 32768 ticks).
*  
*  The smallest interval value supported is 328, which is around 10 milliseconds.
*  Any parameters between 0 and 328 will be rounded up to 328. The maximum value
*  is 2147483647, which corresponds to about 18.2 hours.
*  
*  If time is 0, removes the scheduled timer with the same handle.
* @param handle   Timer handle to use, which is returned in timeout event
* @param single_shot   Timer mode. Values:
*  
*      0: false (timer is repeating)
*       1: true (timer runs only once)
*
* Events generated
*
* gecko_evt_hardware_soft_timer - Sent after this timer has lapsed.
*
**/

static inline struct gecko_msg_hardware_set_soft_timer_rsp_t* gecko_cmd_hardware_set_soft_timer(uint32 time,uint8 handle,uint8 single_shot)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_hardware_set_soft_timer.time=time;
    gecko_cmd_msg->data.cmd_hardware_set_soft_timer.handle=handle;
    gecko_cmd_msg->data.cmd_hardware_set_soft_timer.single_shot=single_shot;
    gecko_cmd_msg->header=(gecko_cmd_hardware_set_soft_timer_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_hardware_set_soft_timer;
}

/** 
*
* gecko_cmd_hardware_get_time
*
* Deprecated. Use Sleep Timer component (sl_sleeptimer.h) for the same
* functionality. Call sl_sleeptimer_get_tick_count64 to get current tick count.
* Sleep Timer provides APIs for conversions between ticks and milliseconds.
* 
* Get elapsed time since last reset. 
*
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_hardware_get_time_rsp_t* gecko_cmd_hardware_get_time()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_hardware_get_time_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_hardware_get_time;
}

/** 
*
* gecko_cmd_hardware_set_lazy_soft_timer
*
* Start a software timer with slack. The slack parameter allows the stack to
* optimize wakeups and save power. The timer event is triggered between time and
* time + slack. See also description of hardware_set_soft_timer command. 
*
* @param time   Interval between how often to send events in hardware clock ticks (1 second is
*  equal to 32768 ticks).
*  
*  The smallest interval value supported is 328, which is around 10 milliseconds.
*  Any parameters between 0 and 328 will be rounded up to 328. The maximum value
*  is 2147483647, which corresponds to about 18.2 hours.
*  
*  If time is 0, removes the scheduled timer with the same handle.
* @param slack   Slack time in hardware clock ticks
* @param handle   Timer handle to use, which is returned in timeout event
* @param single_shot   Timer mode. Values:
*  
*      0: false (timer is repeating)
*       1: true (timer runs only once)
*
* Events generated
*
* gecko_evt_hardware_soft_timer - Sent after this timer has lapsed.
*
**/

static inline struct gecko_msg_hardware_set_lazy_soft_timer_rsp_t* gecko_cmd_hardware_set_lazy_soft_timer(uint32 time,uint32 slack,uint8 handle,uint8 single_shot)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_hardware_set_lazy_soft_timer.time=time;
    gecko_cmd_msg->data.cmd_hardware_set_lazy_soft_timer.slack=slack;
    gecko_cmd_msg->data.cmd_hardware_set_lazy_soft_timer.handle=handle;
    gecko_cmd_msg->data.cmd_hardware_set_lazy_soft_timer.single_shot=single_shot;
    gecko_cmd_msg->header=(gecko_cmd_hardware_set_lazy_soft_timer_id+(((10)&0xff)<<8)+(((10)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_hardware_set_lazy_soft_timer;
}

/** 
*
* gecko_cmd_flash_ps_erase_all
*
* Delete all PS keys and their corresponding values. 
*
*
**/

static inline struct gecko_msg_flash_ps_erase_all_rsp_t* gecko_cmd_flash_ps_erase_all()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_flash_ps_erase_all_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_flash_ps_erase_all;
}

/** 
*
* gecko_cmd_flash_ps_save
*
* Store a value into the specified PS key. Allowed PS keys are in range from
* 0x4000 to 0x407F. At most, 56 bytes user data can be stored in one PS key.
* Error code 0x018a (command_too_long) is returned if the value data is more
* than 56 bytes. 
*
* @param key   PS key
* @param value_len   Array length
* @param value_data   Value to store into the specified PS key
*
**/

static inline struct gecko_msg_flash_ps_save_rsp_t* gecko_cmd_flash_ps_save(uint16 key,uint8 value_len, const uint8* value_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)value_len > 256 - 3)
    {
        gecko_rsp_msg->data.rsp_flash_ps_save.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_flash_ps_save;
    }

    
    gecko_cmd_msg->data.cmd_flash_ps_save.key=key;
    gecko_cmd_msg->data.cmd_flash_ps_save.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_flash_ps_save.value.data,value_data,value_len);
    gecko_cmd_msg->header=(gecko_cmd_flash_ps_save_id+(((3+value_len)&0xff)<<8)+(((3+value_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_flash_ps_save;
}

/** 
*
* gecko_cmd_flash_ps_load
*
* Retrieve the value of the specified PS key. 
*
* @param key   PS key of the value to be retrieved
*
**/

static inline struct gecko_msg_flash_ps_load_rsp_t* gecko_cmd_flash_ps_load(uint16 key)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_flash_ps_load.key=key;
    gecko_cmd_msg->header=(gecko_cmd_flash_ps_load_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_flash_ps_load;
}

/** 
*
* gecko_cmd_flash_ps_erase
*
* Delete a single PS key and its value from the persistent store. 
*
* @param key   PS key to delete
*
**/

static inline struct gecko_msg_flash_ps_erase_rsp_t* gecko_cmd_flash_ps_erase(uint16 key)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_flash_ps_erase.key=key;
    gecko_cmd_msg->header=(gecko_cmd_flash_ps_erase_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_flash_ps_erase;
}

/** 
*
* gecko_cmd_test_dtm_tx
*
* Start a transmitter test against a separate Bluetooth tester device. When the
* command is processed by the radio, a test_dtm_completed event is triggered.
* This event indicates whether the test started successfully.
* 
* In the transmitter test, the device sends packets continuously with a fixed
* interval. The type and length of each packet is set by packet_type and length
* parameters. The parameter phy specifies which PHY is used to transmit the
* packets. All devices support at least 1M PHY. A special packet type,
* test_pkt_carrier , can be used to transmit continuous unmodulated carrier. The
* length field is ignored in this mode.
* 
* The test may be stopped using the test_dtm_end command. 
*
* @param packet_type   Packet type to transmit
* @param length   Packet length in bytes
*  
*   Range: 0-255
* @param channel   Bluetooth channel
*  
*   Range: 0-39
*  
*  Channel is (F - 2402) / 2,
*  
*  where F is frequency in MHz
* @param phy   PHY to use
*
* Events generated
*
* gecko_evt_test_dtm_completed - This event is received when the command is processed.
*
**/

static inline struct gecko_msg_test_dtm_tx_rsp_t* gecko_cmd_test_dtm_tx(uint8 packet_type,uint8 length,uint8 channel,uint8 phy)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_test_dtm_tx.packet_type=packet_type;
    gecko_cmd_msg->data.cmd_test_dtm_tx.length=length;
    gecko_cmd_msg->data.cmd_test_dtm_tx.channel=channel;
    gecko_cmd_msg->data.cmd_test_dtm_tx.phy=phy;
    gecko_cmd_msg->header=(gecko_cmd_test_dtm_tx_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_test_dtm_tx;
}

/** 
*
* gecko_cmd_test_dtm_rx
*
* Start a receiver test against a separate Bluetooth tester device. When the
* command is processed by the radio, a test_dtm_completed event is triggered.
* This event indicates whether the test started successfully.
* 
* Parameter phy specifies which PHY is used to receive the packets. All devices
* support at least 1M PHY.
* 
* The test may be stopped using the test_dtm_end command. This will trigger
* another test_dtm_completed event, which carries the number of packets received
* during the test. 
*
* @param channel   Bluetooth channel
*  
*   Range: 0-39
*  
*  Channel is (F - 2402) / 2,
*  
*  where F is frequency in MHz
* @param phy   PHY to use
*
* Events generated
*
* gecko_evt_test_dtm_completed - This event is received when the command is processed.
*
**/

static inline struct gecko_msg_test_dtm_rx_rsp_t* gecko_cmd_test_dtm_rx(uint8 channel,uint8 phy)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_test_dtm_rx.channel=channel;
    gecko_cmd_msg->data.cmd_test_dtm_rx.phy=phy;
    gecko_cmd_msg->header=(gecko_cmd_test_dtm_rx_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_test_dtm_rx;
}

/** 
*
* gecko_cmd_test_dtm_end
*
* End a transmitter or a receiver test. When the command is processed by the
* radio and the test has ended, a test_dtm_completed event is triggered. 
*
*
* Events generated
*
* gecko_evt_test_dtm_completed - Received when the command is processed by the radio and the test has ended.
*
**/

static inline struct gecko_msg_test_dtm_end_rsp_t* gecko_cmd_test_dtm_end()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_test_dtm_end_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_test_dtm_end;
}

/** 
*
* gecko_cmd_sm_set_bondable_mode
*
* Set whether the device should accept new bondings. By default, the device does
* not accept new bondings. 
*
* @param bondable   Bondable mode. Values:
*  
*      0: New bondings not accepted
*      1: Bondings allowed
*  
*  Default value: 0
*
**/

static inline struct gecko_msg_sm_set_bondable_mode_rsp_t* gecko_cmd_sm_set_bondable_mode(uint8 bondable)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_sm_set_bondable_mode.bondable=bondable;
    gecko_cmd_msg->header=(gecko_cmd_sm_set_bondable_mode_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_set_bondable_mode;
}

/** 
*
* gecko_cmd_sm_configure
*
* Configure security requirements and I/O capabilities of the system. 
*
* @param flags   Security requirement bitmask.
*  
*  Bit 0:
*  
*      0: Allow bonding without MITM protection
*      1: Bonding requires MITM protection
*  
*  Bit 1:
*  
*      0: Allow encryption without bonding
*      1: Encryption requires bonding. Note that this setting will also enable bonding.
*  
*  Bit 2:
*  
*      0: Allow bonding with legacy pairing
*      1: Secure connections only
*  
*  Bit 3:
*  
*      0: Bonding request does not need to be confirmed
*      1: Bonding requests need to be confirmed. Received bonding requests are notified by sm_confirm_bonding events.
*  
*  Bit 4:
*  
*      0: Allow all connections
*      1: Allow connections only from bonded devices
*  
*  Bit 5 to 7: Reserved
*  
*  Default value: 0x00
* @param io_capabilities   I/O Capabilities. See link.
*
**/

static inline struct gecko_msg_sm_configure_rsp_t* gecko_cmd_sm_configure(uint8 flags,uint8 io_capabilities)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_sm_configure.flags=flags;
    gecko_cmd_msg->data.cmd_sm_configure.io_capabilities=io_capabilities;
    gecko_cmd_msg->header=(gecko_cmd_sm_configure_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_configure;
}

/** 
*
* gecko_cmd_sm_store_bonding_configuration
*
* Set the maximum allowed bonding count and bonding policy. The maximum number
* of bondings that can be supported depends on how much user data is stored in
* the NVM and the NVM size. When bond policy value 1 or 2 is selected the stack
* will automatically write the new bond, as per the policy, only if the maximum
* allowed bonding count has been reached. If the stack is not able to write a
* new bond for any other reason (e.g. nvm full) then an error will be thrown
* through the bonding_failed event indicating why the bonding could not be
* written. It is left up to the application to manually release space from the
* nvm (e.g. by deleting one of the existing bonds or application data) so that a
* new bond can be saved. The default value is 13. 
*
* @param max_bonding_count   Maximum allowed bonding count. Range: 1 to 32
* @param policy_flags   Bonding policy. Values:
*  
*      0: If database is full, new bonding attempts will fail
*      1: New bonding will overwrite the oldest existing bonding
*      2: New bonding will overwrite the existing bonding that was used the longest time ago
*  
*  Default: 0
*
**/

static inline struct gecko_msg_sm_store_bonding_configuration_rsp_t* gecko_cmd_sm_store_bonding_configuration(uint8 max_bonding_count,uint8 policy_flags)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_sm_store_bonding_configuration.max_bonding_count=max_bonding_count;
    gecko_cmd_msg->data.cmd_sm_store_bonding_configuration.policy_flags=policy_flags;
    gecko_cmd_msg->header=(gecko_cmd_sm_store_bonding_configuration_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_store_bonding_configuration;
}

/** 
*
* gecko_cmd_sm_increase_security
*
* Enhance the security of a connection to current security requirements. On an
* unencrypted connection, it will encrypt the connection and will also perform
* bonding if requested by both devices. On an encrypted connection, it will
* cause the connection to be re-encrypted. 
*
* @param connection   Connection handle
*
* Events generated
*
* gecko_evt_le_connection_parameters - Triggered after increasing security has been completed successfully and
*  indicates the latest security mode of the connection.
* gecko_evt_sm_bonded - Triggered if pairing or bonding was performed in this operation and the result
*  is successful.
* gecko_evt_sm_bonding_failed - Triggered if pairing or bonding was performed in this operation and the result
*  has failed.
*
**/

static inline struct gecko_msg_sm_increase_security_rsp_t* gecko_cmd_sm_increase_security(uint8 connection)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_sm_increase_security.connection=connection;
    gecko_cmd_msg->header=(gecko_cmd_sm_increase_security_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_increase_security;
}

/** 
*
* gecko_cmd_sm_delete_bonding
*
* Delete specified bonding information or whitelist from the persistent store. 
*
* @param bonding   Bonding handle
*
**/

static inline struct gecko_msg_sm_delete_bonding_rsp_t* gecko_cmd_sm_delete_bonding(uint8 bonding)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_sm_delete_bonding.bonding=bonding;
    gecko_cmd_msg->header=(gecko_cmd_sm_delete_bonding_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_delete_bonding;
}

/** 
*
* gecko_cmd_sm_delete_bondings
*
* Delete all bonding information and whitelist from the persistent store. 
*
*
**/

static inline struct gecko_msg_sm_delete_bondings_rsp_t* gecko_cmd_sm_delete_bondings()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_sm_delete_bondings_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_delete_bondings;
}

/** 
*
* gecko_cmd_sm_enter_passkey
*
* Enter a passkey after receiving a passkey request event. 
*
* @param connection   Connection handle
* @param passkey   Passkey. Valid range: 0-999999. Set -1 to cancel pairing.
*
**/

static inline struct gecko_msg_sm_enter_passkey_rsp_t* gecko_cmd_sm_enter_passkey(uint8 connection,int32 passkey)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_sm_enter_passkey.connection=connection;
    gecko_cmd_msg->data.cmd_sm_enter_passkey.passkey=passkey;
    gecko_cmd_msg->header=(gecko_cmd_sm_enter_passkey_id+(((5)&0xff)<<8)+(((5)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_enter_passkey;
}

/** 
*
* gecko_cmd_sm_passkey_confirm
*
* Accept or reject the reported passkey confirm value. 
*
* @param connection   Connection handle
* @param confirm   Acceptance. Values:
*  
*       0: Reject
*       1: Accept confirm value
*
**/

static inline struct gecko_msg_sm_passkey_confirm_rsp_t* gecko_cmd_sm_passkey_confirm(uint8 connection,uint8 confirm)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_sm_passkey_confirm.connection=connection;
    gecko_cmd_msg->data.cmd_sm_passkey_confirm.confirm=confirm;
    gecko_cmd_msg->header=(gecko_cmd_sm_passkey_confirm_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_passkey_confirm;
}

/** 
*
* gecko_cmd_sm_set_oob_data
*
* Set OOB data (out-of-band encryption data) for legacy pairing for a device.
* OOB data may be, for example, a PIN code exchanged over an alternate path,
* such as NFC. The device will not allow any other bonding if OOB data is set.
* OOB data can't be set simultaneously with secure connections OOB data. 
*
* @param oob_data_len   Array length
* @param oob_data_data   OOB data. To set OOB data, send a 16-byte array. To clear OOB data, send a
*  zero-length array.
*
**/

static inline struct gecko_msg_sm_set_oob_data_rsp_t* gecko_cmd_sm_set_oob_data(uint8 oob_data_len, const uint8* oob_data_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)oob_data_len > 256 - 1)
    {
        gecko_rsp_msg->data.rsp_sm_set_oob_data.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_sm_set_oob_data;
    }

    
    gecko_cmd_msg->data.cmd_sm_set_oob_data.oob_data.len=oob_data_len;
    memcpy(gecko_cmd_msg->data.cmd_sm_set_oob_data.oob_data.data,oob_data_data,oob_data_len);
    gecko_cmd_msg->header=(gecko_cmd_sm_set_oob_data_id+(((1+oob_data_len)&0xff)<<8)+(((1+oob_data_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_set_oob_data;
}

/** 
*
* gecko_cmd_sm_list_all_bondings
*
* List all bondings stored in the bonding database. Bondings are reported by the
* sm_list_bonding_entry event for each bonding and the report is ended with
* sm_list_all_bondings_complete event. Use only for debugging purposes because
* reading from the persistent store is relatively slow. 
*
*
* Events generated
*
* gecko_evt_sm_list_bonding_entry - 
* gecko_evt_sm_list_all_bondings_complete - 
*
**/

static inline struct gecko_msg_sm_list_all_bondings_rsp_t* gecko_cmd_sm_list_all_bondings()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_sm_list_all_bondings_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_list_all_bondings;
}

/** 
*
* gecko_cmd_sm_bonding_confirm
*
* Accept or reject the bonding request. 
*
* @param connection   Connection handle
* @param confirm   Acceptance. Values:
*  
*       0: Reject
*       1: Accept bonding request
*
**/

static inline struct gecko_msg_sm_bonding_confirm_rsp_t* gecko_cmd_sm_bonding_confirm(uint8 connection,uint8 confirm)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_sm_bonding_confirm.connection=connection;
    gecko_cmd_msg->data.cmd_sm_bonding_confirm.confirm=confirm;
    gecko_cmd_msg->header=(gecko_cmd_sm_bonding_confirm_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_bonding_confirm;
}

/** 
*
* gecko_cmd_sm_set_debug_mode
*
* Set Security Manager in debug mode. In this mode, the secure connections
* bonding uses known debug keys, so that the encrypted packet can be opened by
* Bluetooth protocol analyzer. To disable the debug mode, restart the device.
* 
* Bondings made in debug mode are unsecure. 
*
*
**/

static inline struct gecko_msg_sm_set_debug_mode_rsp_t* gecko_cmd_sm_set_debug_mode()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_sm_set_debug_mode_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_set_debug_mode;
}

/** 
*
* gecko_cmd_sm_set_passkey
*
* Enter a fixed passkey, which will be used in the sm_passkey_display event. 
*
* @param passkey   Passkey. Valid range: 0-999999. Set -1 to disable and start using random
*  passkeys.
*
**/

static inline struct gecko_msg_sm_set_passkey_rsp_t* gecko_cmd_sm_set_passkey(int32 passkey)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_sm_set_passkey.passkey=passkey;
    gecko_cmd_msg->header=(gecko_cmd_sm_set_passkey_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_set_passkey;
}

/** 
*
* gecko_cmd_sm_use_sc_oob
*
* Enable the use of OOB data (out-of-band encryption data) for a device for
* secure connections pairing. Enabling will generate new OOB data and confirm
* values, which can be sent to the remote device. After enabling the secure
* connections OOB data, the remote devices OOB data can be set with
* sm_set_sc_remote_oob_data. Calling this function will erase any set remote
* device OOB data and confirm values. The device will not allow any other
* bonding if OOB data is set. The secure connections OOB data cannot be enabled
* simultaneously with legacy pairing OOB data. 
*
* @param enable   Enable OOB with secure connections pairing. Values:
*  
*      0: disable
*       1: enable
*
**/

static inline struct gecko_msg_sm_use_sc_oob_rsp_t* gecko_cmd_sm_use_sc_oob(uint8 enable)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_sm_use_sc_oob.enable=enable;
    gecko_cmd_msg->header=(gecko_cmd_sm_use_sc_oob_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_use_sc_oob;
}

/** 
*
* gecko_cmd_sm_set_sc_remote_oob_data
*
* Set OOB data and confirm values (out-of-band encryption) received from the
* remote device for secure connections pairing. OOB data must be enabled with
* sm_use_sc_oob before setting the remote device OOB data. 
*
* @param oob_data_len   Array length
* @param oob_data_data   Remote device OOB data and confirm values. To set OOB data, send a 32-byte
*  array. First 16-bytes is OOB data and last 16-bytes the confirm value. To
*  clear OOB data, send a zero-length array.
*
**/

static inline struct gecko_msg_sm_set_sc_remote_oob_data_rsp_t* gecko_cmd_sm_set_sc_remote_oob_data(uint8 oob_data_len, const uint8* oob_data_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)oob_data_len > 256 - 1)
    {
        gecko_rsp_msg->data.rsp_sm_set_sc_remote_oob_data.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_sm_set_sc_remote_oob_data;
    }

    
    gecko_cmd_msg->data.cmd_sm_set_sc_remote_oob_data.oob_data.len=oob_data_len;
    memcpy(gecko_cmd_msg->data.cmd_sm_set_sc_remote_oob_data.oob_data.data,oob_data_data,oob_data_len);
    gecko_cmd_msg->header=(gecko_cmd_sm_set_sc_remote_oob_data_id+(((1+oob_data_len)&0xff)<<8)+(((1+oob_data_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_set_sc_remote_oob_data;
}

/** 
*
* gecko_cmd_sm_add_to_whitelist
*
* Add device to whitelist, which can be enabled with le_gap_enable_whitelisting. 
*
* @param address   Address of the device added to whitelist
* @param address_type   Address type of the device added to whitelist
*
**/

static inline struct gecko_msg_sm_add_to_whitelist_rsp_t* gecko_cmd_sm_add_to_whitelist(bd_addr address,uint8 address_type)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    memcpy(&gecko_cmd_msg->data.cmd_sm_add_to_whitelist.address,&address,sizeof(bd_addr));
    gecko_cmd_msg->data.cmd_sm_add_to_whitelist.address_type=address_type;
    gecko_cmd_msg->header=(gecko_cmd_sm_add_to_whitelist_id+(((7)&0xff)<<8)+(((7)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_add_to_whitelist;
}

/** 
*
* gecko_cmd_sm_set_minimum_key_size
*
* Set the minimum allowed key size used for bonding. The default value is 16
* bytes. 
*
* @param minimum_key_size   Minimum allowed key size for bonding. Range: 7 to 16
*
**/

static inline struct gecko_msg_sm_set_minimum_key_size_rsp_t* gecko_cmd_sm_set_minimum_key_size(uint8 minimum_key_size)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_sm_set_minimum_key_size.minimum_key_size=minimum_key_size;
    gecko_cmd_msg->header=(gecko_cmd_sm_set_minimum_key_size_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_set_minimum_key_size;
}

/** 
*
* gecko_cmd_homekit_configure
*
* Configure the Apple HomeKit accessory and its settings. The configuration can
* be reinitialized at run time. New fast advertising parameters will be used for
* next fast advertising. 
*
* @param i2c_address   I2C address of Apple authentication coprocessor
* @param support_display   A flag to indicate that the display support is enabled in the accessory.  
*  A pin code will be randomly generated during the pairing process and
*  homekit_setupcode_display event will be triggered to ensure that the pin code
*  can be displayed.
*  
*      0: Display support disabled
*      1: Display support enabled
* @param hap_attribute_features   The value of Apple HomeKit pairing features supported in pairing service
*  feature characteristic.
*  
*      0x01: Supports Apple Authentication Coprocessor
*      0x02: Supports Software Authentication
*      0x00: Only for testing purposes when authentication methods are not available. The accessory will be discovered as non-authenticated
*      other: Reserved
* @param category   Apple HomeKit accessory category
* @param configuration_number   Apple HomeKit configuration number  
*  By default, this starts at 1. Accessories must increment this value after a
*  firmware update. This value must be managed by the application.
* @param fast_advert_interval   Fast advertising interval.  
*  The interval is used during fast advertising in disconnected state after
*  calling command homekit_event_notification when broadcast events advertising
*  is complete.
* @param fast_advert_timeout   Fast advertising timeout.  
*  The timeout is used during fast advertising in disconnected state after
*  calling command homekit_event_notification when broadcast events advertising
*  is complete.
*  
*      Time = Value x 100 ms
* @param flag   Apple HomeKit library configuration flag.
*  
*      0x00000001: Manual Bluetooth disconnection in HomeKit error case. When enabled, a homekit_disconnection_required event will be produced when a HomeKit error occurs.
*      0x00000002: Manual set of scan response data. When enabled, use le_gap_bt5_set_adv_data command to set custom scan response data. Also, HomeKit library uses it to set the accessory local name. 
*      other: Reserved. Must be 0.
* @param broadcast_advert_timeout   Broadcast events advertising timeout.  
*  The timeout is used during broadcast events advertising in disconnected state
*  after calling command homekit_event_notification
*  
*      Time = Value x 100 ms
* @param model_name_len   Array length
* @param model_name_data   Model Name characteristic value from HomeKit Accessory Information service.
*  Mandatory for HomeKit software authentication usage.
*
**/

static inline struct gecko_msg_homekit_configure_rsp_t* gecko_cmd_homekit_configure(uint8 i2c_address,uint8 support_display,uint8 hap_attribute_features,uint16 category,uint8 configuration_number,uint16 fast_advert_interval,uint16 fast_advert_timeout,uint32 flag,uint16 broadcast_advert_timeout,uint8 model_name_len, const uint8* model_name_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)model_name_len > 256 - 17)
    {
        gecko_rsp_msg->data.rsp_homekit_configure.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_homekit_configure;
    }

    
    gecko_cmd_msg->data.cmd_homekit_configure.i2c_address=i2c_address;
    gecko_cmd_msg->data.cmd_homekit_configure.support_display=support_display;
    gecko_cmd_msg->data.cmd_homekit_configure.hap_attribute_features=hap_attribute_features;
    gecko_cmd_msg->data.cmd_homekit_configure.category=category;
    gecko_cmd_msg->data.cmd_homekit_configure.configuration_number=configuration_number;
    gecko_cmd_msg->data.cmd_homekit_configure.fast_advert_interval=fast_advert_interval;
    gecko_cmd_msg->data.cmd_homekit_configure.fast_advert_timeout=fast_advert_timeout;
    gecko_cmd_msg->data.cmd_homekit_configure.flag=flag;
    gecko_cmd_msg->data.cmd_homekit_configure.broadcast_advert_timeout=broadcast_advert_timeout;
    gecko_cmd_msg->data.cmd_homekit_configure.model_name.len=model_name_len;
    memcpy(gecko_cmd_msg->data.cmd_homekit_configure.model_name.data,model_name_data,model_name_len);
    gecko_cmd_msg->header=(gecko_cmd_homekit_configure_id+(((17+model_name_len)&0xff)<<8)+(((17+model_name_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_homekit_configure;
}

/** 
*
* gecko_cmd_homekit_advertise
*
* Start or stop Apple HomeKit accessory advertising. The command and parameters
* will take effect immediately. If the given parameters can't be used in the
* currently active mode, an error is returned. 
*
* @param enable   A flag to enable or disable Apple HomeKit advertising
*  
*      1: Enable advertising
*      0: Disable advertising
* @param interval_min   Minimum advertising interval. See GAP command le_gap_set_adv_parameters
* @param interval_max   Maximum advertising interval. See GAP command le_gap_set_adv_parameters
* @param channel_map   Advertising channel map. See GAP command le_gap_set_adv_parameters
*
**/

static inline struct gecko_msg_homekit_advertise_rsp_t* gecko_cmd_homekit_advertise(uint8 enable,uint16 interval_min,uint16 interval_max,uint8 channel_map)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_homekit_advertise.enable=enable;
    gecko_cmd_msg->data.cmd_homekit_advertise.interval_min=interval_min;
    gecko_cmd_msg->data.cmd_homekit_advertise.interval_max=interval_max;
    gecko_cmd_msg->data.cmd_homekit_advertise.channel_map=channel_map;
    gecko_cmd_msg->header=(gecko_cmd_homekit_advertise_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_homekit_advertise;
}

/** 
*
* gecko_cmd_homekit_delete_pairings
*
* Delete all Apple HomeKit pairing data. Additionally, it resets all required
* HomeKit settings to factory state, e.g., it resets GSN value and generates a
* new Device ID. 
*
*
**/

static inline struct gecko_msg_homekit_delete_pairings_rsp_t* gecko_cmd_homekit_delete_pairings()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_homekit_delete_pairings_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_homekit_delete_pairings;
}

/** 
*
* gecko_cmd_homekit_check_authcp
*
* Create an I2C test connection with Apple authentication co-processor and
* return an error if communication fails. 
*
*
**/

static inline struct gecko_msg_homekit_check_authcp_rsp_t* gecko_cmd_homekit_check_authcp()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_homekit_check_authcp_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_homekit_check_authcp;
}

/** 
*
* gecko_cmd_homekit_get_pairing_id
*
* Get pairing ID of the connected iOS device. 
*
* @param connection   
*
**/

static inline struct gecko_msg_homekit_get_pairing_id_rsp_t* gecko_cmd_homekit_get_pairing_id(uint8 connection)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_homekit_get_pairing_id.connection=connection;
    gecko_cmd_msg->header=(gecko_cmd_homekit_get_pairing_id_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_homekit_get_pairing_id;
}

/** 
*
* gecko_cmd_homekit_send_write_response
*
* Send a response to a homekit_write_request event. The response needs to be
* sent within 30 seconds, otherwise additional GATT transactions are not allowed
* by the remote side.  
*   
* If the status_code is set to 0, the HAP will send a response informing that
* the write operation was processed successfully and other values will cause the
* HAP to send a HAP error status response. 
*
* @param connection   
* @param characteristic   
* @param status_code   HomeKit status code.
*
**/

static inline struct gecko_msg_homekit_send_write_response_rsp_t* gecko_cmd_homekit_send_write_response(uint8 connection,uint16 characteristic,uint8 status_code)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_homekit_send_write_response.connection=connection;
    gecko_cmd_msg->data.cmd_homekit_send_write_response.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_homekit_send_write_response.status_code=status_code;
    gecko_cmd_msg->header=(gecko_cmd_homekit_send_write_response_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_homekit_send_write_response;
}

/** 
*
* gecko_cmd_homekit_send_read_response
*
* Send a response to a homekit_read_request event. The response needs to be sent
* within 30 seconds, otherwise further GATT transactions are not allowed by the
* remote side.  
*   
* If status_code is set to 0, the characteristic value is sent to the remote
* GATT client through HomeKit library in a standard way. Other status_code
* values cause a HAP error status response instead of sending data.  
*   
* If the value data size is less than attribute_size, the Apple HomeKit library
* will send new homekit_read_request event with a suitable offset. The Apple
* HomeKit library provides automatic formatting for both the frame and
* encryption. 
*
* @param connection   
* @param characteristic   
* @param status_code   HomeKit Status Code
* @param attribute_size   Size of attribute value
* @param value_len   Array length
* @param value_data   Characteristic value to send to the GATT client through the HomeKit library.
*  This is ignored if status_code is not set to 0.
*
**/

static inline struct gecko_msg_homekit_send_read_response_rsp_t* gecko_cmd_homekit_send_read_response(uint8 connection,uint16 characteristic,uint8 status_code,uint16 attribute_size,uint8 value_len, const uint8* value_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)value_len > 256 - 7)
    {
        gecko_rsp_msg->data.rsp_homekit_send_read_response.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_homekit_send_read_response;
    }

    
    gecko_cmd_msg->data.cmd_homekit_send_read_response.connection=connection;
    gecko_cmd_msg->data.cmd_homekit_send_read_response.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_homekit_send_read_response.status_code=status_code;
    gecko_cmd_msg->data.cmd_homekit_send_read_response.attribute_size=attribute_size;
    gecko_cmd_msg->data.cmd_homekit_send_read_response.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_homekit_send_read_response.value.data,value_data,value_len);
    gecko_cmd_msg->header=(gecko_cmd_homekit_send_read_response_id+(((7+value_len)&0xff)<<8)+(((7+value_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_homekit_send_read_response;
}

/** 
*
* gecko_cmd_homekit_gsn_action
*
* Reset or store the GSN (Global State Number) value. 
*
* @param action   Actions:
*  
*      0: Reset GSN value to default state
*      1: Store GSN value to a PS-key (flash)
*
**/

static inline struct gecko_msg_homekit_gsn_action_rsp_t* gecko_cmd_homekit_gsn_action(uint8 action)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_homekit_gsn_action.action=action;
    gecko_cmd_msg->header=(gecko_cmd_homekit_gsn_action_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_homekit_gsn_action;
}

/** 
*
* gecko_cmd_homekit_event_notification
*
* Take an appropriate action according to connection state and the originator of
* the change. When device is connected and a local change occurs, it sends an
* empty indication to the controller. When device is disconnected, it starts
* broadcast events advertising. After timeout, it starts fast advertising.
* Broadcast and fast advertising parameters are set in homekit_configure. After
* fast advertising timeout, it reverts to previous advertising settings. For
* both states, it sets the appropriate Global State Number value according to
* HomeKit specification rules. 
*
* @param connection   Connection handle. Ignored for disconnected state.
* @param characteristic   
* @param change_originator   Origin of the characteristic value change:
*  
*      0: Remote change (from controller)
*      1: Local change (from accessory)
* @param value_len   Array length
* @param value_data   Broadcast notify value.
*
**/

static inline struct gecko_msg_homekit_event_notification_rsp_t* gecko_cmd_homekit_event_notification(uint8 connection,uint16 characteristic,uint8 change_originator,uint8 value_len, const uint8* value_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)value_len > 256 - 5)
    {
        gecko_rsp_msg->data.rsp_homekit_event_notification.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_homekit_event_notification;
    }

    
    gecko_cmd_msg->data.cmd_homekit_event_notification.connection=connection;
    gecko_cmd_msg->data.cmd_homekit_event_notification.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_homekit_event_notification.change_originator=change_originator;
    gecko_cmd_msg->data.cmd_homekit_event_notification.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_homekit_event_notification.value.data,value_data,value_len);
    gecko_cmd_msg->header=(gecko_cmd_homekit_event_notification_id+(((5+value_len)&0xff)<<8)+(((5+value_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_homekit_event_notification;
}

/** 
*
* gecko_cmd_homekit_broadcast_action
*
* Delete or store broadcast advertising data, as shown below. 
*
* @param action   Actions:
*  
*      0x00: Delete broadcast advertising data. No additional parameters are required
*      0x01: Store broadcast advertising data (key, characteristics configuration) to non volatile memory. No additional parameters are required
*      other: Reserved
* @param params_len   Array length
* @param params_data   Additional parameters for action.
*
**/

static inline struct gecko_msg_homekit_broadcast_action_rsp_t* gecko_cmd_homekit_broadcast_action(uint8 action,uint8 params_len, const uint8* params_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)params_len > 256 - 2)
    {
        gecko_rsp_msg->data.rsp_homekit_broadcast_action.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_homekit_broadcast_action;
    }

    
    gecko_cmd_msg->data.cmd_homekit_broadcast_action.action=action;
    gecko_cmd_msg->data.cmd_homekit_broadcast_action.params.len=params_len;
    memcpy(gecko_cmd_msg->data.cmd_homekit_broadcast_action.params.data,params_data,params_len);
    gecko_cmd_msg->header=(gecko_cmd_homekit_broadcast_action_id+(((2+params_len)&0xff)<<8)+(((2+params_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_homekit_broadcast_action;
}

/** 
*
* gecko_cmd_homekit_configure_product_data
*
* Configure the Apple HomeKit library. This is additional configuration
* introduced in HAP revision R15. 
*
* @param product_data_len   Array length
* @param product_data_data   Product Data characteristic value from HomeKit Accessory Information service.
*  Mandatory (HAP revision R15 and later).
*
**/

static inline struct gecko_msg_homekit_configure_product_data_rsp_t* gecko_cmd_homekit_configure_product_data(uint8 product_data_len, const uint8* product_data_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)product_data_len > 256 - 1)
    {
        gecko_rsp_msg->data.rsp_homekit_configure_product_data.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_homekit_configure_product_data;
    }

    
    gecko_cmd_msg->data.cmd_homekit_configure_product_data.product_data.len=product_data_len;
    memcpy(gecko_cmd_msg->data.cmd_homekit_configure_product_data.product_data.data,product_data_data,product_data_len);
    gecko_cmd_msg->header=(gecko_cmd_homekit_configure_product_data_id+(((1+product_data_len)&0xff)<<8)+(((1+product_data_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_homekit_configure_product_data;
}

/** 
*
* gecko_cmd_mesh_node_init
*
* Initializes the Bluetooth mesh stack in Node role. When initialization is
* complete, a node initialized event will be generated.
* 
* This command must be issued before any other Bluetooth Mesh commands, except
* for  set node UUID command.
* 
* Note that you may initialize a device either in the Provisioner or the Node
* role, but not both. 
*
*
* Events generated
*
* gecko_evt_mesh_node_initialized - 
*
**/

static inline struct gecko_msg_mesh_node_init_rsp_t* gecko_cmd_mesh_node_init()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_node_init_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_node_init;
}

/** 
*
* gecko_cmd_mesh_node_start_unprov_beaconing
*
* Start sending Unprovisioned Device Beacons.
* 
* This command makes an unprovisioned device available for provisioning. The
* device will start sending periodic unprovisioned device beacons containing
* device UUID. It will also start listening for incoming Provisioner connection
* attempts on the specified bearers (PB-ADV, PB-GATT, or both). For PB-GATT, the
* device will also begin advertising its provisioning GATT service.
* 
* At the beginning of a provisioning process, a provisioning started event will
* be generated. When the device receives provisioning data from the Provisioner,
* a node provisioned event will be generated. If provisioning fails with an
* error, a  provisioning failed event will be generated.
* 
* After it is provisioned, addresses are allocated for the node elements and a
* network key is deployed to the node, making the node ready for further
* configuration by the Provisioner. Note that at this point the node is not yet
* fully ready to communicate with other nodes on the network. 
*
* @param bearer   Bit mask for which bearer to use. Values are as follows:  
*  
*      1 (bit 0): PB-ADV
*      2 (bit 1): PB-GATT
*  
*  Other bits are reserved and must not be used.
*
* Events generated
*
* gecko_evt_mesh_node_provisioning_started - 
* gecko_evt_mesh_node_provisioned - 
* gecko_evt_mesh_node_provisioning_failed - 
*
**/

static inline struct gecko_msg_mesh_node_start_unprov_beaconing_rsp_t* gecko_cmd_mesh_node_start_unprov_beaconing(uint8 bearer)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_node_start_unprov_beaconing.bearer=bearer;
    gecko_cmd_msg->header=(gecko_cmd_mesh_node_start_unprov_beaconing_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_node_start_unprov_beaconing;
}

/** 
*
* gecko_cmd_mesh_node_stop_unprov_beaconing
*
* Stop sending Unprovisioned Device Beacons. 
*
*
**/

static inline struct gecko_msg_mesh_node_stop_unprov_beaconing_rsp_t* gecko_cmd_mesh_node_stop_unprov_beaconing()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_node_stop_unprov_beaconing_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_node_stop_unprov_beaconing;
}

/** 
*
* gecko_cmd_mesh_node_rssi
*
* Get the latest RSSI value of a provisioned Bluetooth device.
* 
* The value indicates the best signal strength received from any node within the
* network. The value is cleared after calling this function meaning the next
* call will fail if no new RSSI value is received. 
*
*
**/

static inline struct gecko_msg_mesh_node_rssi_rsp_t* gecko_cmd_mesh_node_rssi()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_node_rssi_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_node_rssi;
}

/** 
*
* gecko_cmd_mesh_node_input_oob_request_rsp
*
* Provide the stack with the input out-of-band authentication data which the
* Provisioner is displaying. 
*
* @param data_len   Array length
* @param data_data   Raw 16-byte array containing the authentication data.
*
**/

static inline struct gecko_msg_mesh_node_input_oob_request_rsp_rsp_t* gecko_cmd_mesh_node_input_oob_request_rsp(uint8 data_len, const uint8* data_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)data_len > 256 - 1)
    {
        gecko_rsp_msg->data.rsp_mesh_node_input_oob_request_rsp.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_node_input_oob_request_rsp;
    }

    
    gecko_cmd_msg->data.cmd_mesh_node_input_oob_request_rsp.data.len=data_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_node_input_oob_request_rsp.data.data,data_data,data_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_node_input_oob_request_rsp_id+(((1+data_len)&0xff)<<8)+(((1+data_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_node_input_oob_request_rsp;
}

/** 
*
* gecko_cmd_mesh_node_get_uuid
*
* Get the device UUID.
* 
* Every mesh device has a 128-bit UUID identifying the device. It is used
* primarily during provisioning, because it is broadcast in Unprovisioned Device
* Beacons to indicate that the device is ready to be provisioned.
* 
* This command can be used for debugging purposes. During provisioning the stack
* automatically uses the UUID of the device and it does not need to be
* explicitly specified when unprovisioned device beaconing is started. 
*
*
**/

static inline struct gecko_msg_mesh_node_get_uuid_rsp_t* gecko_cmd_mesh_node_get_uuid()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_node_get_uuid_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_node_get_uuid;
}

/** 
*
* gecko_cmd_mesh_node_set_provisioning_data
*
* Provision devices completely out-of-band. Populate the Provisioner's device
* database with the corresponding values to make the device reachable and
* configurable in the Provisioner's network.
* 
* See also the Provisioner command for adding a device to Provisioner's device
* database.
* 
* NOTE : The device must be reset after this command has been issued. 
*
* @param device_key   Device Key for this Device, shared by the Provisioner
* @param network_key   Network key that the Provisioner has selected for this device
* @param netkey_index   Index of the Network Key the Provisioner has selected for this device
* @param iv_index   Current IV Index used in the network
* @param address   Address the Provisioner has allocated for this device's primary element
* @param kr_in_progress   Set to 1 if key refresh is currently in progress, otherwise 0.
*
**/

static inline struct gecko_msg_mesh_node_set_provisioning_data_rsp_t* gecko_cmd_mesh_node_set_provisioning_data(aes_key_128 device_key,aes_key_128 network_key,uint16 netkey_index,uint32 iv_index,uint16 address,uint8 kr_in_progress)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_node_set_provisioning_data.device_key=device_key;
    gecko_cmd_msg->data.cmd_mesh_node_set_provisioning_data.network_key=network_key;
    gecko_cmd_msg->data.cmd_mesh_node_set_provisioning_data.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_node_set_provisioning_data.iv_index=iv_index;
    gecko_cmd_msg->data.cmd_mesh_node_set_provisioning_data.address=address;
    gecko_cmd_msg->data.cmd_mesh_node_set_provisioning_data.kr_in_progress=kr_in_progress;
    gecko_cmd_msg->header=(gecko_cmd_mesh_node_set_provisioning_data_id+(((41)&0xff)<<8)+(((41)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_node_set_provisioning_data;
}

/** 
*
* gecko_cmd_mesh_node_init_oob
*
* Initialize the Bluetooth mesh stack in the Node role. When initialization is
* complete, a node initialized event is generated.
* 
* This command is the same as the node initialization command except for
* parameters defining whether OOB authentication data stored on the device can
* be used during provisioning.
* 
* This command must be issued before any other Bluetooth mesh commands, except
* for  set node UUID command.
* 
* Note that you may initialize a device either in the Provisioner or the Node
* role, but not both. 
*
* @param public_key   If non-zero, use the ECC key stored in the persistent store during
*  provisioning instead of an ephemeral key.
* @param auth_methods   Allowed OOB authentication methods. The value is a bitmap so that multiple
*  methods can be supported.
* @param output_actions   Allowed OOB Output Action types
* @param output_size   Maximum Output OOB size Valid values range from 0 (feature not supported) to
*  8.
* @param input_actions   Allowed OOB Input Action types
* @param input_size   Maximum Input OOB size. Valid values range from 0 (feature not supported) to
*  8.
* @param oob_location   Defines the OOB data location bitmask.
*
* Events generated
*
* gecko_evt_mesh_node_initialized - 
*
**/

static inline struct gecko_msg_mesh_node_init_oob_rsp_t* gecko_cmd_mesh_node_init_oob(uint8 public_key,uint8 auth_methods,uint16 output_actions,uint8 output_size,uint16 input_actions,uint8 input_size,uint16 oob_location)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_node_init_oob.public_key=public_key;
    gecko_cmd_msg->data.cmd_mesh_node_init_oob.auth_methods=auth_methods;
    gecko_cmd_msg->data.cmd_mesh_node_init_oob.output_actions=output_actions;
    gecko_cmd_msg->data.cmd_mesh_node_init_oob.output_size=output_size;
    gecko_cmd_msg->data.cmd_mesh_node_init_oob.input_actions=input_actions;
    gecko_cmd_msg->data.cmd_mesh_node_init_oob.input_size=input_size;
    gecko_cmd_msg->data.cmd_mesh_node_init_oob.oob_location=oob_location;
    gecko_cmd_msg->header=(gecko_cmd_mesh_node_init_oob_id+(((10)&0xff)<<8)+(((10)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_node_init_oob;
}

/** 
*
* gecko_cmd_mesh_node_set_ivrecovery_mode
*
* Enable/disable IV index recovery mode.
* 
* If the node has not been in communication with the network for a long time
* (e.g., because it was turned off), it may have missed IV index updates and
* isn't able to communicate with other nodes. In this case, enable the IV index
* recovery mode. 
*
* @param mode   Zero to disable; non-zero to enable
*
**/

static inline struct gecko_msg_mesh_node_set_ivrecovery_mode_rsp_t* gecko_cmd_mesh_node_set_ivrecovery_mode(uint8 mode)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_node_set_ivrecovery_mode.mode=mode;
    gecko_cmd_msg->header=(gecko_cmd_mesh_node_set_ivrecovery_mode_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_node_set_ivrecovery_mode;
}

/** 
*
* gecko_cmd_mesh_node_get_ivrecovery_mode
*
* Get current IV index recovery mode state. See set IV index recovery mode for
* details. 
*
*
**/

static inline struct gecko_msg_mesh_node_get_ivrecovery_mode_rsp_t* gecko_cmd_mesh_node_get_ivrecovery_mode()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_node_get_ivrecovery_mode_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_node_get_ivrecovery_mode;
}

/** 
*
* gecko_cmd_mesh_node_set_adv_event_filter
*
* Set filter for received advertising packet events.
* 
* As Mesh data traffic is carried over advertising events and the Bluetooth mesh
* stack is scanning continuously when the Bluetooth mesh stack is active, by
* default, the Bluetooth mesh stack filters out advertising events so that the
* application is not burdened by them.
* 
* If the application needs to process advertising events, it can use this
* command to unblock particular types of events. 
*
* @param mask   Enabled advertising packet type
*  
*      0x01: Connectable undirected advertising
*      0x02: Scannable undirected advertising
*      0x04: Non connectable undirected advertising
*      0x08: Scan Response
*      0x8000: Use GAP data type. Don't use with other values
* @param gap_data_type_len   Array length
* @param gap_data_type_data   Used when the type is set to 0x8000. Events are generated when advertising
*  packets contain any of the AD data types specified by this parameter. Type
*  values are defined in the Bluetooth SIG Data Types Specification.  
*  Values must be set as a two digit hexadecimal number, maximum 8 items.
*
**/

static inline struct gecko_msg_mesh_node_set_adv_event_filter_rsp_t* gecko_cmd_mesh_node_set_adv_event_filter(uint16 mask,uint8 gap_data_type_len, const uint8* gap_data_type_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)gap_data_type_len > 256 - 3)
    {
        gecko_rsp_msg->data.rsp_mesh_node_set_adv_event_filter.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_node_set_adv_event_filter;
    }

    
    gecko_cmd_msg->data.cmd_mesh_node_set_adv_event_filter.mask=mask;
    gecko_cmd_msg->data.cmd_mesh_node_set_adv_event_filter.gap_data_type.len=gap_data_type_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_node_set_adv_event_filter.gap_data_type.data,gap_data_type_data,gap_data_type_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_node_set_adv_event_filter_id+(((3+gap_data_type_len)&0xff)<<8)+(((3+gap_data_type_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_node_set_adv_event_filter;
}

/** 
*
* gecko_cmd_mesh_node_get_statistics
*
*  
*
*
**/

static inline struct gecko_msg_mesh_node_get_statistics_rsp_t* gecko_cmd_mesh_node_get_statistics()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_node_get_statistics_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_node_get_statistics;
}

/** 
*
* gecko_cmd_mesh_node_clear_statistics
*
*  
*
*
**/

static inline struct gecko_msg_mesh_node_clear_statistics_rsp_t* gecko_cmd_mesh_node_clear_statistics()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_node_clear_statistics_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_node_clear_statistics;
}

/** 
*
* gecko_cmd_mesh_node_set_net_relay_delay
*
* Set network relay delay interval.
* 
* This parameter determines the time a relay waits until it relays a network
* PDU. The value used is a random number within the specified interval.
* 
* Note that this value affects the first instance of the relayed network PDU. If
* relay retransmissions are enabled, the interval between retransmissions is
* defined by the relay state, set by the Provisioner of the network or by set
* local relay state test command. 
*
* @param min   Minimum interval, in milliseconds
* @param max   Maximum interval, in milliseconds, which must be equal to or greater than the
*  minimum.
*
**/

static inline struct gecko_msg_mesh_node_set_net_relay_delay_rsp_t* gecko_cmd_mesh_node_set_net_relay_delay(uint8 min,uint8 max)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_node_set_net_relay_delay.min=min;
    gecko_cmd_msg->data.cmd_mesh_node_set_net_relay_delay.max=max;
    gecko_cmd_msg->header=(gecko_cmd_mesh_node_set_net_relay_delay_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_node_set_net_relay_delay;
}

/** 
*
* gecko_cmd_mesh_node_get_net_relay_delay
*
* Get network relay delay interval. See set network relay delay command for
* details. 
*
*
**/

static inline struct gecko_msg_mesh_node_get_net_relay_delay_rsp_t* gecko_cmd_mesh_node_get_net_relay_delay()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_node_get_net_relay_delay_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_node_get_net_relay_delay;
}

/** 
*
* gecko_cmd_mesh_node_get_ivupdate_state
*
* Get the current IV index update state in the network. 
*
*
**/

static inline struct gecko_msg_mesh_node_get_ivupdate_state_rsp_t* gecko_cmd_mesh_node_get_ivupdate_state()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_node_get_ivupdate_state_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_node_get_ivupdate_state;
}

/** 
*
* gecko_cmd_mesh_node_request_ivupdate
*
* Attempt to request an IV index update in the network.
* 
* Each network layer PDU that a node sends has a 24-bit sequence number attached
* to it. Each node element keeps a sequence number counter, which is incremented
* for every PDU sent out to the network. Repeating sequence numbers for a given
* IV index value is not allowed. As a result, if a node determines it is about
* to exhaust the available sequence numbers in one of its elements, it needs to
* request an IV index update by issuing this command.
* 
* Determining when a node may run out of sequence numbers has to be done at the
* application level because the stack can't determine how often the application
* plans to transmit to the network, i.e., how long the remaining sequence
* numbers might last.
* 
* See also the get remaining sequence numbers command.
* 
* Note that the call may fail for various reasons, for example if an IV index
* update is already ongoing, or if not enough time has passed since the previous
* IV index update. 
*
*
**/

static inline struct gecko_msg_mesh_node_request_ivupdate_rsp_t* gecko_cmd_mesh_node_request_ivupdate()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_node_request_ivupdate_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_node_request_ivupdate;
}

/** 
*
* gecko_cmd_mesh_node_get_seq_remaining
*
* Get the number of sequence numbers remaining on an element (before sequence
* numbers are exhausted). Note that every node element keeps a separate sequence
* number counter. 
*
* @param elem_index   The index of queried element
*
**/

static inline struct gecko_msg_mesh_node_get_seq_remaining_rsp_t* gecko_cmd_mesh_node_get_seq_remaining(uint16 elem_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_node_get_seq_remaining.elem_index=elem_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_node_get_seq_remaining_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_node_get_seq_remaining;
}

/** 
*
* gecko_cmd_mesh_node_save_replay_protection_list
*
* Save the current replay protection list to the persistent store.
* 
* The replay protection list keeps track of the packet sequence numbers from
* different sources received by the node. The node will not process messages
* associated with already used sequence numbers and is therefore protected from
* replay attacks using previously recorded messages.
* 
* The replay protection list is kept in RAM during runtime. It needs to be saved
* to the persistent store periodically and always before the device powers off.
* Because the stack is not aware when this will happen, the application has to
* call this method while the node is getting ready to power down but is still
* running. 
*
*
**/

static inline struct gecko_msg_mesh_node_save_replay_protection_list_rsp_t* gecko_cmd_mesh_node_save_replay_protection_list()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_node_save_replay_protection_list_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_node_save_replay_protection_list;
}

/** 
*
* gecko_cmd_mesh_node_set_uuid
*
* Write device UUID into the persistent store. This command must be called
* before initializing the Bluetooth mesh stack (before mesh_node_init or
* mesh_node_init_oob, otherwise the change will not take effect before a reboot.
* 
* Ensure that the UUID conforms to the format defined in RFC 4122
* 
* Note that UUID must not be changed when the device is provisioned to a
* network.
* 
* Furthermore, ensure that the UUID remains constant if a device has received a
* firmware update, which requires reprovisioning of the device after the update
* has been applied (e.g., new elements are added by the update). 
*
* @param uuid   UUID to set
*
**/

static inline struct gecko_msg_mesh_node_set_uuid_rsp_t* gecko_cmd_mesh_node_set_uuid(uuid_128 uuid)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_node_set_uuid.uuid=uuid;
    gecko_cmd_msg->header=(gecko_cmd_mesh_node_set_uuid_id+(((16)&0xff)<<8)+(((16)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_node_set_uuid;
}

/** 
*
* gecko_cmd_mesh_node_get_element_address
*
* Get the unicast address configured to an element. 
*
* @param elem_index   The index of the target element, 0 is the primary element
*
**/

static inline struct gecko_msg_mesh_node_get_element_address_rsp_t* gecko_cmd_mesh_node_get_element_address(uint16 elem_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_node_get_element_address.elem_index=elem_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_node_get_element_address_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_node_get_element_address;
}

/** 
*
* gecko_cmd_mesh_node_static_oob_request_rsp
*
* Provide the stack with static out-of-band authentication data which the stack
* requested. 
*
* @param data_len   Array length
* @param data_data   Raw 16-byte array containing the authentication data
*
**/

static inline struct gecko_msg_mesh_node_static_oob_request_rsp_rsp_t* gecko_cmd_mesh_node_static_oob_request_rsp(uint8 data_len, const uint8* data_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)data_len > 256 - 1)
    {
        gecko_rsp_msg->data.rsp_mesh_node_static_oob_request_rsp.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_node_static_oob_request_rsp;
    }

    
    gecko_cmd_msg->data.cmd_mesh_node_static_oob_request_rsp.data.len=data_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_node_static_oob_request_rsp.data.data,data_data,data_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_node_static_oob_request_rsp_id+(((1+data_len)&0xff)<<8)+(((1+data_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_node_static_oob_request_rsp;
}

/** 
*
* gecko_cmd_mesh_node_reset
*
* Factory reset of the mesh node.
* 
* To complete procedure, the application should do its own cleanup duties and
* reset the hardware. 
*
*
**/

static inline struct gecko_msg_mesh_node_reset_rsp_t* gecko_cmd_mesh_node_reset()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_node_reset_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_node_reset;
}

/** 
*
* gecko_cmd_mesh_node_set_beacon_reporting
*
* Set secure network beaconing on or off. When on, every received secure network
* beacon will generate a  beacon received event. 
*
* @param report   Turn reporting on (nonzero) or off (zero).
*
**/

static inline struct gecko_msg_mesh_node_set_beacon_reporting_rsp_t* gecko_cmd_mesh_node_set_beacon_reporting(uint8 report)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_node_set_beacon_reporting.report=report;
    gecko_cmd_msg->header=(gecko_cmd_mesh_node_set_beacon_reporting_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_node_set_beacon_reporting;
}

/** 
*
* gecko_cmd_mesh_node_set_iv_update_age
*
* Set time since last IV update. After reboot the node does not know the time
* since the last IV update and assumes that it happend at the time of the
* reboot. 
*
* @param age_s   Seconds since last IV update. Values from 0 to 345600 (96h)
*
**/

static inline struct gecko_msg_mesh_node_set_iv_update_age_rsp_t* gecko_cmd_mesh_node_set_iv_update_age(uint32 age_s)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_node_set_iv_update_age.age_s=age_s;
    gecko_cmd_msg->header=(gecko_cmd_mesh_node_set_iv_update_age_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_node_set_iv_update_age;
}

/** 
*
* gecko_cmd_mesh_prov_init
*
* Initialize the Bluetooth mesh stack in Provisioner role. When initialization
* is complete, a provisioner initialized event will be generated.
* 
* This command must be issued before any other Bluetooth mesh stack commands.
* Note that the Bluetooth mesh stack can be initialized either in the
* Provisioner or the Node role, but not both. 
*
*
* Events generated
*
* gecko_evt_mesh_prov_initialized - 
*
**/

static inline struct gecko_msg_mesh_prov_init_rsp_t* gecko_cmd_mesh_prov_init()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_init_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_init;
}

/** 
*
* gecko_cmd_mesh_prov_scan_unprov_beacons
*
* Start scanning for unprovisioned device beacons.
* 
* Unprovisioned devices send out beacons containing their UUID. An unprovisioned
* beacon event will be generated for each beacon seen. Once the UUID of a device
* is known, the Provisioner may start provisioning the device by issuing either
* the  provision device over PB-ADV or provision device over PB-GATT command. 
*
*
* Events generated
*
* gecko_evt_mesh_prov_unprov_beacon - 
*
**/

static inline struct gecko_msg_mesh_prov_scan_unprov_beacons_rsp_t* gecko_cmd_mesh_prov_scan_unprov_beacons()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_scan_unprov_beacons_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_scan_unprov_beacons;
}

/** 
*
* gecko_cmd_mesh_prov_provision_device
*
* Provision a device into a network using the advertisement bearer (PB-ADV).
* 
* Issuing this command starts the provisioning process for the specified device.
* After the process completes successfully, a device provisioned event is
* generated. If provisioning fails, a  provisioning failed event will be
* generated instead. 
*
* @param network_id   Index of the initial network key, which is sent to the device during
*  provisioning
* @param uuid_len   Array length
* @param uuid_data   UUID of the device to provision
*
* Events generated
*
* gecko_evt_mesh_prov_device_provisioned - 
* gecko_evt_mesh_prov_provisioning_failed - 
*
**/

static inline struct gecko_msg_mesh_prov_provision_device_rsp_t* gecko_cmd_mesh_prov_provision_device(uint8 network_id,uint8 uuid_len, const uint8* uuid_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)uuid_len > 256 - 2)
    {
        gecko_rsp_msg->data.rsp_mesh_prov_provision_device.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_prov_provision_device;
    }

    
    gecko_cmd_msg->data.cmd_mesh_prov_provision_device.network_id=network_id;
    gecko_cmd_msg->data.cmd_mesh_prov_provision_device.uuid.len=uuid_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_prov_provision_device.uuid.data,uuid_data,uuid_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_provision_device_id+(((2+uuid_len)&0xff)<<8)+(((2+uuid_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_provision_device;
}

/** 
*
* gecko_cmd_mesh_prov_create_network
*
* Create a new network key on the Provisioner.
* 
* The created key can be deployed on a node using the add network key command. 
*
* @param key_len   Array length
* @param key_data   Key value to use. Set to zero-length array to generate a random key.
*
**/

static inline struct gecko_msg_mesh_prov_create_network_rsp_t* gecko_cmd_mesh_prov_create_network(uint8 key_len, const uint8* key_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)key_len > 256 - 1)
    {
        gecko_rsp_msg->data.rsp_mesh_prov_create_network.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_prov_create_network;
    }

    
    gecko_cmd_msg->data.cmd_mesh_prov_create_network.key.len=key_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_prov_create_network.key.data,key_data,key_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_create_network_id+(((1+key_len)&0xff)<<8)+(((1+key_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_create_network;
}

/** 
*
* gecko_cmd_mesh_prov_get_dcd
*
* Deprecated and replaced by mesh_config_client_get_dcd command.
* 
* Get the DCD of the device from a remote Configuration Server. If the call
* succeeds, the retrieved DCD will be returned in a DCD status event. 
*
* @param address   Unicast address of the target node's primary element
* @param page   Page number for requested DCD. Use 0xff to get highest existing page.
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_get_dcd_rsp_t* gecko_cmd_mesh_prov_get_dcd(uint16 address,uint8 page)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_get_dcd.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_get_dcd.page=page;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_get_dcd_id+(((3)&0xff)<<8)+(((3)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_get_dcd;
}

/** 
*
* gecko_cmd_mesh_prov_get_config
*
* Deprecated and replaced by the following: mesh_config_client_get_beacon,
* mesh_config_client_get_default_ttl, mesh_config_client_get_friend,
* mesh_config_client_get_gatt_proxy, mesh_config_client_get_identity,
* mesh_config_client_get_lpn_polltimeout, and mesh_config_client_get_relay
* commands.
* 
* Get a configuration state value of a node.
* 
* Node Configuration Server model state contains a number of node-wide values
* (for example, node's default TTL value) which are represented as single bytes
* and can be queried with this command. See the  list of configuration states
* for reference.
* 
* Query the more complex states (for example, model-application key bindings)
* using the commands dedicated for the purpose; see, e.g., get model application
* key bindings command.
* 
* Node response is reported with an configuration status event. 
*
* @param address   Unicast address of the target node's primary element
* @param id   The state to read
* @param netkey_index   Ignored for node-wide states.
*
* Events generated
*
* gecko_evt_mesh_prov_config_status - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_get_config_rsp_t* gecko_cmd_mesh_prov_get_config(uint16 address,uint16 id,uint16 netkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_get_config.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_get_config.id=id;
    gecko_cmd_msg->data.cmd_mesh_prov_get_config.netkey_index=netkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_get_config_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_get_config;
}

/** 
*
* gecko_cmd_mesh_prov_set_config
*
* Deprecated and replaced by the following: mesh_config_client_set_beacon,
* mesh_config_client_set_default_ttl, mesh_config_client_set_friend,
* mesh_config_client_set_gatt_proxy, mesh_config_client_set_identity, and
* mesh_config_client_set_relay commands.
* 
* Set a configuration state value of a node.
* 
* Node Configuration Server model state contains a number of node-wide values
* (for example, node's default TTL value) which are represented as single bytes
* and can be modified with this command. See the  list of configuration states
* for reference.
* 
* Set the more complex states using the commands dedicated for the purpose
* because this command accepts only raw binary data as the value to set.
* 
* Node response is reported with an configuration status event. 
*
* @param address   Unicast address of the target node's primary element
* @param id   State to manipulate
* @param netkey_index   Ignored for node-wide states.
* @param value_len   Array length
* @param value_data   Raw binary value
*
* Events generated
*
* gecko_evt_mesh_prov_config_status - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_set_config_rsp_t* gecko_cmd_mesh_prov_set_config(uint16 address,uint16 id,uint16 netkey_index,uint8 value_len, const uint8* value_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)value_len > 256 - 7)
    {
        gecko_rsp_msg->data.rsp_mesh_prov_set_config.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_prov_set_config;
    }

    
    gecko_cmd_msg->data.cmd_mesh_prov_set_config.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_set_config.id=id;
    gecko_cmd_msg->data.cmd_mesh_prov_set_config.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_set_config.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_prov_set_config.value.data,value_data,value_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_set_config_id+(((7+value_len)&0xff)<<8)+(((7+value_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_set_config;
}

/** 
*
* gecko_cmd_mesh_prov_create_appkey
*
* Creates a new application key on the Provisioner.
* 
* An application key is always bound to a network key. In other words, the
* application key is only valid in the context of a particular network key. The
* selected network key must exist on the Provisioner (see create network key
* command).
* 
* The created application key can be deployed on a node using the add
* application key command. 
*
* @param netkey_index   Index of the network key to which the application key will be bound
* @param key_len   Array length
* @param key_data   Key value to use; set to zero-length array to generate random key.
*
**/

static inline struct gecko_msg_mesh_prov_create_appkey_rsp_t* gecko_cmd_mesh_prov_create_appkey(uint16 netkey_index,uint8 key_len, const uint8* key_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)key_len > 256 - 3)
    {
        gecko_rsp_msg->data.rsp_mesh_prov_create_appkey.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_prov_create_appkey;
    }

    
    gecko_cmd_msg->data.cmd_mesh_prov_create_appkey.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_create_appkey.key.len=key_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_prov_create_appkey.key.data,key_data,key_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_create_appkey_id+(((3+key_len)&0xff)<<8)+(((3+key_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_create_appkey;
}

/** 
*
* gecko_cmd_mesh_prov_oob_pkey_rsp
*
* Respond to prov_oob_pkey_request 
*
* @param pkey_len   Array length
* @param pkey_data   Public Key read out-of-band
*
**/

static inline struct gecko_msg_mesh_prov_oob_pkey_rsp_rsp_t* gecko_cmd_mesh_prov_oob_pkey_rsp(uint8 pkey_len, const uint8* pkey_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)pkey_len > 256 - 1)
    {
        gecko_rsp_msg->data.rsp_mesh_prov_oob_pkey_rsp.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_prov_oob_pkey_rsp;
    }

    
    gecko_cmd_msg->data.cmd_mesh_prov_oob_pkey_rsp.pkey.len=pkey_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_prov_oob_pkey_rsp.pkey.data,pkey_data,pkey_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_oob_pkey_rsp_id+(((1+pkey_len)&0xff)<<8)+(((1+pkey_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_oob_pkey_rsp;
}

/** 
*
* gecko_cmd_mesh_prov_oob_auth_rsp
*
* Respond to prov_oob_auth_request 
*
* @param data_len   Array length
* @param data_data   Output or static OOB data
*
**/

static inline struct gecko_msg_mesh_prov_oob_auth_rsp_rsp_t* gecko_cmd_mesh_prov_oob_auth_rsp(uint8 data_len, const uint8* data_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)data_len > 256 - 1)
    {
        gecko_rsp_msg->data.rsp_mesh_prov_oob_auth_rsp.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_prov_oob_auth_rsp;
    }

    
    gecko_cmd_msg->data.cmd_mesh_prov_oob_auth_rsp.data.len=data_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_prov_oob_auth_rsp.data.data,data_data,data_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_oob_auth_rsp_id+(((1+data_len)&0xff)<<8)+(((1+data_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_oob_auth_rsp;
}

/** 
*
* gecko_cmd_mesh_prov_set_oob_requirements
*
* Set the OOB requirements for devices to be provisioned. 
*
* @param public_key   The public key. Set to zero if the provisioning does not use OOB public Key.
* @param auth_methods   Allowed OOB authentication methods The value is a bitmap so that multiple
*  methods can be supported.
* @param output_actions   Allowed OOB Output Action types
* @param input_actions   Allowed OOB Input Action types
* @param min_size   Minimum input/output OOB size. Values range from 0 (input/output OOB not used)
*  to 8.
* @param max_size   Maximum input/output OOB size. Must be smaller than or equal to the minimum
*  size. Values range from 0 (input/output OOB not used) to 8.
*
**/

static inline struct gecko_msg_mesh_prov_set_oob_requirements_rsp_t* gecko_cmd_mesh_prov_set_oob_requirements(uint8 public_key,uint8 auth_methods,uint16 output_actions,uint16 input_actions,uint8 min_size,uint8 max_size)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_set_oob_requirements.public_key=public_key;
    gecko_cmd_msg->data.cmd_mesh_prov_set_oob_requirements.auth_methods=auth_methods;
    gecko_cmd_msg->data.cmd_mesh_prov_set_oob_requirements.output_actions=output_actions;
    gecko_cmd_msg->data.cmd_mesh_prov_set_oob_requirements.input_actions=input_actions;
    gecko_cmd_msg->data.cmd_mesh_prov_set_oob_requirements.min_size=min_size;
    gecko_cmd_msg->data.cmd_mesh_prov_set_oob_requirements.max_size=max_size;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_set_oob_requirements_id+(((8)&0xff)<<8)+(((8)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_set_oob_requirements;
}

/** 
*
* gecko_cmd_mesh_prov_key_refresh_start
*
* Start a key refresh procedure in the network.
* 
* A key refresh procedure updates a network key and optionally application keys
* associated with it in all nodes of the network except for blacklisted nodes.
* After the refresh procedure is complete, the old keys will be discarded.
* Therefore, the blacklisted nodes, which did not receive new keys will be shut
* out of the network at the completion of the procedure. 
*
* @param netkey_index   Index of the network key to update
* @param num_appkeys   Number of application keys to update; may be zero.
* @param appkey_indices_len   Array length
* @param appkey_indices_data   Indices of the application keys to update, represented as little endian two
*  byte sequences. The array must contain num_appkeys indices and therefore
*  2*num_appkeys bytes total.
*
* Events generated
*
* gecko_evt_mesh_prov_key_refresh_node_update - 
* gecko_evt_mesh_prov_key_refresh_phase_update - 
* gecko_evt_mesh_prov_key_refresh_complete - 
*
**/

static inline struct gecko_msg_mesh_prov_key_refresh_start_rsp_t* gecko_cmd_mesh_prov_key_refresh_start(uint16 netkey_index,uint8 num_appkeys,uint8 appkey_indices_len, const uint8* appkey_indices_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)appkey_indices_len > 256 - 4)
    {
        gecko_rsp_msg->data.rsp_mesh_prov_key_refresh_start.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_prov_key_refresh_start;
    }

    
    gecko_cmd_msg->data.cmd_mesh_prov_key_refresh_start.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_key_refresh_start.num_appkeys=num_appkeys;
    gecko_cmd_msg->data.cmd_mesh_prov_key_refresh_start.appkey_indices.len=appkey_indices_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_prov_key_refresh_start.appkey_indices.data,appkey_indices_data,appkey_indices_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_key_refresh_start_id+(((4+appkey_indices_len)&0xff)<<8)+(((4+appkey_indices_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_key_refresh_start;
}

/** 
*
* gecko_cmd_mesh_prov_get_key_refresh_blacklist
*
* Check the key refresh blacklist status of a node. Blacklisted nodes do not
* participate in the key refresh procedure and can therefore be shut out of the
* network. 
*
* @param key   Network key index
* @param uuid_len   Array length
* @param uuid_data   UUID of the Device
*
**/

static inline struct gecko_msg_mesh_prov_get_key_refresh_blacklist_rsp_t* gecko_cmd_mesh_prov_get_key_refresh_blacklist(uint16 key,uint8 uuid_len, const uint8* uuid_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)uuid_len > 256 - 3)
    {
        gecko_rsp_msg->data.rsp_mesh_prov_get_key_refresh_blacklist.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_prov_get_key_refresh_blacklist;
    }

    
    gecko_cmd_msg->data.cmd_mesh_prov_get_key_refresh_blacklist.key=key;
    gecko_cmd_msg->data.cmd_mesh_prov_get_key_refresh_blacklist.uuid.len=uuid_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_prov_get_key_refresh_blacklist.uuid.data,uuid_data,uuid_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_get_key_refresh_blacklist_id+(((3+uuid_len)&0xff)<<8)+(((3+uuid_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_get_key_refresh_blacklist;
}

/** 
*
* gecko_cmd_mesh_prov_set_key_refresh_blacklist
*
* Set the key refresh blacklist status of a node. Blacklisted nodes do not
* participate in the key refresh procedure and can therefore be shut out of the
* network. 
*
* @param key   Network key index
* @param status   Non-zero for blacklisted node
* @param uuid_len   Array length
* @param uuid_data   UUID of the Device
*
**/

static inline struct gecko_msg_mesh_prov_set_key_refresh_blacklist_rsp_t* gecko_cmd_mesh_prov_set_key_refresh_blacklist(uint16 key,uint8 status,uint8 uuid_len, const uint8* uuid_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)uuid_len > 256 - 4)
    {
        gecko_rsp_msg->data.rsp_mesh_prov_set_key_refresh_blacklist.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_prov_set_key_refresh_blacklist;
    }

    
    gecko_cmd_msg->data.cmd_mesh_prov_set_key_refresh_blacklist.key=key;
    gecko_cmd_msg->data.cmd_mesh_prov_set_key_refresh_blacklist.status=status;
    gecko_cmd_msg->data.cmd_mesh_prov_set_key_refresh_blacklist.uuid.len=uuid_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_prov_set_key_refresh_blacklist.uuid.data,uuid_data,uuid_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_set_key_refresh_blacklist_id+(((4+uuid_len)&0xff)<<8)+(((4+uuid_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_set_key_refresh_blacklist;
}

/** 
*
* gecko_cmd_mesh_prov_appkey_add
*
* Deprecated and replaced by mesh_config_client_add_appkey command.
* 
* Push an application key to a node. The key must exist on the Provisioner (see
* create application key command).
* 
* An application key is always bound to a network key. In other words, the
* application key is only valid in the context of a particular network key. The
* selected network key must exist on the Provisioner (see create network key
* command) and must have been deployed on the node prior to this command (either
* during provisioning or with an add network key command).
* 
* Node response is reported with an configuration status event. 
*
* @param address   Unicast address of the target node's primary element
* @param netkey_index   The network key index to which the application key is bound
* @param appkey_index   The index of the application key to push to the node
*
* Events generated
*
* gecko_evt_mesh_prov_config_status - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_appkey_add_rsp_t* gecko_cmd_mesh_prov_appkey_add(uint16 address,uint16 netkey_index,uint16 appkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_appkey_add.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_appkey_add.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_appkey_add.appkey_index=appkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_appkey_add_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_appkey_add;
}

/** 
*
* gecko_cmd_mesh_prov_appkey_delete
*
* Deprecated and replaced by mesh_config_client_remove_appkey command.
* 
* Delete an application key on a node.
* 
* Note that the deleted key will be removed from any model bindings on the node
* at the same time automatically. There is no need to explicitly delete them
* using model-application key unbind command.
* 
* Node response is reported with an configuration status event. 
*
* @param address   Unicast address of the target node's primary element
* @param netkey_index   Index of the network key to which the application key is bound on the node
* @param appkey_index   Index of the application key to delete
*
* Events generated
*
* gecko_evt_mesh_prov_config_status - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_appkey_delete_rsp_t* gecko_cmd_mesh_prov_appkey_delete(uint16 address,uint16 netkey_index,uint16 appkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_appkey_delete.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_appkey_delete.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_appkey_delete.appkey_index=appkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_appkey_delete_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_appkey_delete;
}

/** 
*
* gecko_cmd_mesh_prov_model_app_bind
*
* Deprecated and replaced by mesh_config_client_bind_model command.
* 
* Bind a model to an application key. Node response is reported with a
* configuration status event. 
*
* @param address   Unicast address of the target node's primary element
* @param elem_address   Unicast address of the element containing the configured model
* @param netkey_index   The network key index used for encrypting the request
* @param appkey_index   The application key to use for binding
* @param vendor_id   Vendor ID of the configured model. Use 0xffff for Bluetooth SIG models.
* @param model_id   Model ID of the configured model
*
* Events generated
*
* gecko_evt_mesh_prov_config_status - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_model_app_bind_rsp_t* gecko_cmd_mesh_prov_model_app_bind(uint16 address,uint16 elem_address,uint16 netkey_index,uint16 appkey_index,uint16 vendor_id,uint16 model_id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_model_app_bind.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_app_bind.elem_address=elem_address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_app_bind.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_model_app_bind.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_model_app_bind.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_prov_model_app_bind.model_id=model_id;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_model_app_bind_id+(((12)&0xff)<<8)+(((12)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_model_app_bind;
}

/** 
*
* gecko_cmd_mesh_prov_model_app_unbind
*
* Deprecated and replaced by mesh_config_client_unbind_model command.
* 
* Remove application key binding from a model. Node response is reported with a
* configuration status event. 
*
* @param address   Unicast address of the target node's primary element
* @param elem_address   Unicast address of the element containing the configured model
* @param netkey_index   The network key index for encrypting the request
* @param appkey_index   The index of the application key used in the binding to be removed
* @param vendor_id   Vendor ID of configured model. Use 0xffff for Bluetooth SIG models
* @param model_id   Model ID of the configured model.
*
* Events generated
*
* gecko_evt_mesh_prov_config_status - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_model_app_unbind_rsp_t* gecko_cmd_mesh_prov_model_app_unbind(uint16 address,uint16 elem_address,uint16 netkey_index,uint16 appkey_index,uint16 vendor_id,uint16 model_id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_model_app_unbind.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_app_unbind.elem_address=elem_address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_app_unbind.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_model_app_unbind.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_model_app_unbind.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_prov_model_app_unbind.model_id=model_id;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_model_app_unbind_id+(((12)&0xff)<<8)+(((12)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_model_app_unbind;
}

/** 
*
* gecko_cmd_mesh_prov_model_app_get
*
* Deprecated and replaced by mesh_config_client_list_bindings command.
* 
* Get application keys to which the model is bound. Node response is reported
* with a configuration status event. 
*
* @param address   Unicast address of the target node's primary element
* @param elem_address   Unicast address of the element containing the configured model
* @param netkey_index   The network key index used for encrypting the request
* @param vendor_id   Vendor ID of model being configured. Use 0xffff for Bluetooth SIG models.
* @param model_id   Model ID of the configured model
*
* Events generated
*
* gecko_evt_mesh_prov_config_status - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_model_app_get_rsp_t* gecko_cmd_mesh_prov_model_app_get(uint16 address,uint16 elem_address,uint16 netkey_index,uint16 vendor_id,uint16 model_id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_model_app_get.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_app_get.elem_address=elem_address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_app_get.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_model_app_get.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_prov_model_app_get.model_id=model_id;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_model_app_get_id+(((10)&0xff)<<8)+(((10)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_model_app_get;
}

/** 
*
* gecko_cmd_mesh_prov_model_sub_add
*
* Deprecated and replaced by mesh_config_client_add_model_sub command.
* 
* Add an address to a model's subscription list. Node response is reported with
* a configuration status event. 
*
* @param address   Unicast address of the target node
* @param elem_address   Unicast address of the element containing the model to be configured
* @param netkey_index   The network key index used for encrypting the request
* @param vendor_id   Vendor ID of the configured model. Use 0xffff for Bluetooth SIG models.
* @param model_id   Model ID of the configured model
* @param sub_address   The address to add to the subscription list. Note that the address has to be a
*  group address.
*
* Events generated
*
* gecko_evt_mesh_prov_config_status - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_model_sub_add_rsp_t* gecko_cmd_mesh_prov_model_sub_add(uint16 address,uint16 elem_address,uint16 netkey_index,uint16 vendor_id,uint16 model_id,uint16 sub_address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_add.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_add.elem_address=elem_address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_add.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_add.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_add.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_add.sub_address=sub_address;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_model_sub_add_id+(((12)&0xff)<<8)+(((12)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_model_sub_add;
}

/** 
*
* gecko_cmd_mesh_prov_model_pub_set
*
* Deprecated and replaced by mesh_config_client_set_model_pub command.
* 
* Set a model's publication address, key, and parameters. Node response is
* reported with a configuration status event. 
*
* @param address   Unicast address of the target node
* @param elem_address   Unicast address of the element containing the configured model
* @param netkey_index   The network key index used for encrypting the request
* @param appkey_index   The application key index to use for the published messages
* @param vendor_id   Vendor ID of model being configured. Use 0xffff for Bluetooth SIG models.
* @param model_id   Model ID of the configured model.
* @param pub_address   The address to publish to. It can be a unicast address, a virtual address, or
*  a group address. It can also be the unassigned address to stop the model from
*  publishing.
* @param ttl   Publication time-to-live value
* @param period   Publication period encoded as step count and step resolution. The encoding is
*  as follows:
*  
*      Bits 0..5: Step count
*      Bits 6..7: Step resolution: 
*      * 00: 100 milliseconds
*      * 01: 1 second
*      * 10: 10 seconds
*      * 11: 10 minutes
* @param retrans   Retransmission count and interval, which controls how many times the model re-
*  publishes the same message after the initial publish transmission and the
*  cadence of retransmissions.
*  
*  Retransmission count is encoded in the three low bits of the value, ranging
*  from 0 to 7. Default value is 0 (no retransmissions).
*  
*  Retransmission interval is encoded in the five high bits of the value, ranging
*  from 0 to 31, in 50-millisecond units. Value of 0 corresponds to 50 ms, while
*  value of 31 corresponds to 1600 ms.
*
* Events generated
*
* gecko_evt_mesh_prov_config_status - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_model_pub_set_rsp_t* gecko_cmd_mesh_prov_model_pub_set(uint16 address,uint16 elem_address,uint16 netkey_index,uint16 appkey_index,uint16 vendor_id,uint16 model_id,uint16 pub_address,uint8 ttl,uint8 period,uint8 retrans)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set.elem_address=elem_address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set.pub_address=pub_address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set.ttl=ttl;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set.period=period;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set.retrans=retrans;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_model_pub_set_id+(((17)&0xff)<<8)+(((17)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_model_pub_set;
}

/** 
*
* gecko_cmd_mesh_prov_provision_gatt_device
*
* Provision a device into a network using the GATT bearer (PB-GATT).
* 
* Issuing this command starts the provisioning process for the specified device.
* After the process completes successfully, a device_provisioned event is
* generated. If provisioning fails, a  provisioning failed event is generated
* instead.
* 
* Note that this command is available only if GATT functionality is compiled in
* to the firmware. If that is not the case, the command will return with a "not
* implemented" return code. 
*
* @param network_id   Index of the initial network key, which is sent to the device during
*  provisioning.
* @param connection   Connection handle for the device to be provisioned
* @param uuid_len   Array length
* @param uuid_data   UUID of the Device to provision
*
* Events generated
*
* gecko_evt_mesh_prov_device_provisioned - 
* gecko_evt_mesh_prov_provisioning_failed - 
*
**/

static inline struct gecko_msg_mesh_prov_provision_gatt_device_rsp_t* gecko_cmd_mesh_prov_provision_gatt_device(uint8 network_id,uint8 connection,uint8 uuid_len, const uint8* uuid_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)uuid_len > 256 - 3)
    {
        gecko_rsp_msg->data.rsp_mesh_prov_provision_gatt_device.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_prov_provision_gatt_device;
    }

    
    gecko_cmd_msg->data.cmd_mesh_prov_provision_gatt_device.network_id=network_id;
    gecko_cmd_msg->data.cmd_mesh_prov_provision_gatt_device.connection=connection;
    gecko_cmd_msg->data.cmd_mesh_prov_provision_gatt_device.uuid.len=uuid_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_prov_provision_gatt_device.uuid.data,uuid_data,uuid_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_provision_gatt_device_id+(((3+uuid_len)&0xff)<<8)+(((3+uuid_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_provision_gatt_device;
}

/** 
*
* gecko_cmd_mesh_prov_ddb_get
*
* Get a Provisioner device database entry with a matching UUID. 
*
* @param uuid_len   Array length
* @param uuid_data   UUID of the Device to retrieve
*
**/

static inline struct gecko_msg_mesh_prov_ddb_get_rsp_t* gecko_cmd_mesh_prov_ddb_get(uint8 uuid_len, const uint8* uuid_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)uuid_len > 256 - 1)
    {
        gecko_rsp_msg->data.rsp_mesh_prov_ddb_get.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_prov_ddb_get;
    }

    
    gecko_cmd_msg->data.cmd_mesh_prov_ddb_get.uuid.len=uuid_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_prov_ddb_get.uuid.data,uuid_data,uuid_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_ddb_get_id+(((1+uuid_len)&0xff)<<8)+(((1+uuid_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_ddb_get;
}

/** 
*
* gecko_cmd_mesh_prov_ddb_delete
*
* Delete node information from the Provisioner database. This should be followed
* by a  key refresh procedure updating the keys of the remaining nodes to make
* sure the deleted node is shut off from the network. 
*
* @param uuid   UUID of the node to delete
*
**/

static inline struct gecko_msg_mesh_prov_ddb_delete_rsp_t* gecko_cmd_mesh_prov_ddb_delete(uuid_128 uuid)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_ddb_delete.uuid=uuid;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_ddb_delete_id+(((16)&0xff)<<8)+(((16)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_ddb_delete;
}

/** 
*
* gecko_cmd_mesh_prov_ddb_add
*
* Add a new node entry to the Provisioner's device database. Note that the
* device key, primary element address, and network key need to be deployed to
* the node being added to ensure it's configurable. See set node provisioning
* data command. 
*
* @param uuid   UUID of the node to add
* @param device_key   Device key value for the node
* @param netkey_index   Index of the network key the node will be used for configuration
* @param address   Unicast address to allocate for the node's primary element
* @param elements   Number of elements the device has
*
**/

static inline struct gecko_msg_mesh_prov_ddb_add_rsp_t* gecko_cmd_mesh_prov_ddb_add(uuid_128 uuid,aes_key_128 device_key,uint16 netkey_index,uint16 address,uint8 elements)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_ddb_add.uuid=uuid;
    gecko_cmd_msg->data.cmd_mesh_prov_ddb_add.device_key=device_key;
    gecko_cmd_msg->data.cmd_mesh_prov_ddb_add.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_ddb_add.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_ddb_add.elements=elements;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_ddb_add_id+(((37)&0xff)<<8)+(((37)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_ddb_add;
}

/** 
*
* gecko_cmd_mesh_prov_ddb_list_devices
*
* Lists nodes known by this Provisioner. A number of database listing events
* will be generated. 
*
*
* Events generated
*
* gecko_evt_mesh_prov_ddb_list - 
*
**/

static inline struct gecko_msg_mesh_prov_ddb_list_devices_rsp_t* gecko_cmd_mesh_prov_ddb_list_devices()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_ddb_list_devices_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_ddb_list_devices;
}

/** 
*
* gecko_cmd_mesh_prov_network_add
*
* Deprecated and replaced by mesh_config_client_add_netkey command.
* 
* Push a network key to a node. The key must exist on the Provisioner (see
* create network key command).
* 
* Node response is reported with an configuration status event. 
*
* @param address   Unicast address of the target node's primary element
* @param netkey_index   The index of the key to push to the node
*
* Events generated
*
* gecko_evt_mesh_prov_config_status - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_network_add_rsp_t* gecko_cmd_mesh_prov_network_add(uint16 address,uint16 netkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_network_add.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_network_add.netkey_index=netkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_network_add_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_network_add;
}

/** 
*
* gecko_cmd_mesh_prov_network_delete
*
* Deprecated and replaced by mesh_config_client_remove_netkey command.
* 
* Delete a network key on a node.
* 
* When a network key is deleted, the application keys bound to it are deleted
* automatically. There is no need to explicitly use the  delete application key
* command.
* 
* Note that it is not possible to delete the key used in encrypting the command
* itself (which is the first network key deployed to the node during
* provisioning), otherwise the node would not be able to respond.
* 
* Node response is reported with an configuration status event. 
*
* @param address   Unicast address of the target node's primary element
* @param netkey_index   The index of the key to delete
*
* Events generated
*
* gecko_evt_mesh_prov_config_status - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_network_delete_rsp_t* gecko_cmd_mesh_prov_network_delete(uint16 address,uint16 netkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_network_delete.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_network_delete.netkey_index=netkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_network_delete_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_network_delete;
}

/** 
*
* gecko_cmd_mesh_prov_nettx_get
*
* Deprecated and replaced by mesh_config_client_get_network_transmit command.
* 
* Retrieve network layer transmission parameters of a node. 
*
* @param address   Unicast address of the target node
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_nettx_get_rsp_t* gecko_cmd_mesh_prov_nettx_get(uint16 address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_nettx_get.address=address;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_nettx_get_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_nettx_get;
}

/** 
*
* gecko_cmd_mesh_prov_nettx_set
*
* Deprecated and replaced by mesh_config_client_set_network_transmit command.
* 
* Set network layer transmission parameters of a node. 
*
* @param address   Unicast address of the target node
* @param count   Retransmission count (excluding initial transmission). Range: 0..7; the
*  default value is 0 (no retransmissions).
* @param interval   Retransmission interval in 10-millisecond steps
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_nettx_set_rsp_t* gecko_cmd_mesh_prov_nettx_set(uint16 address,uint8 count,uint8 interval)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_nettx_set.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_nettx_set.count=count;
    gecko_cmd_msg->data.cmd_mesh_prov_nettx_set.interval=interval;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_nettx_set_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_nettx_set;
}

/** 
*
* gecko_cmd_mesh_prov_model_sub_del
*
* Deprecated and replaced by is mesh_config_client_remove_model_sub command.
* 
* Remove an address from a model's subscription list. Node response is reported
* with a configuration status event. 
*
* @param address   Unicast address of the target node
* @param elem_address   Unicast address of the element containing the model, which will be configured.
* @param netkey_index   The network key index used for encrypting the request
* @param vendor_id   Vendor ID of the configured model. Use 0xffff for Bluetooth SIG models.
* @param model_id   Model ID of the configured model
* @param sub_address   The address to remove from the subscription list
*
* Events generated
*
* gecko_evt_mesh_prov_config_status - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_model_sub_del_rsp_t* gecko_cmd_mesh_prov_model_sub_del(uint16 address,uint16 elem_address,uint16 netkey_index,uint16 vendor_id,uint16 model_id,uint16 sub_address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_del.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_del.elem_address=elem_address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_del.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_del.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_del.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_del.sub_address=sub_address;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_model_sub_del_id+(((12)&0xff)<<8)+(((12)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_model_sub_del;
}

/** 
*
* gecko_cmd_mesh_prov_model_sub_add_va
*
* Deprecated and replaced by mesh_config_client_add_model_sub_va command.
* 
* Add an virtual address to a model's subscription list. Node response is
* reported with a configuration status event. 
*
* @param address   Unicast address of the target node
* @param elem_address   Unicast address of the element containing the model, which will be configured
* @param netkey_index   The network key index used for encrypting the request.
* @param vendor_id   Vendor ID of the configured model. Use 0xffff for Bluetooth SIG models.
* @param model_id   Model ID of the configured model
* @param sub_address_len   Array length
* @param sub_address_data   The Label UUID to add to the subscription list. The array must be exactly 16
*  bytes long.
*
* Events generated
*
* gecko_evt_mesh_prov_config_status - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_model_sub_add_va_rsp_t* gecko_cmd_mesh_prov_model_sub_add_va(uint16 address,uint16 elem_address,uint16 netkey_index,uint16 vendor_id,uint16 model_id,uint8 sub_address_len, const uint8* sub_address_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)sub_address_len > 256 - 11)
    {
        gecko_rsp_msg->data.rsp_mesh_prov_model_sub_add_va.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_prov_model_sub_add_va;
    }

    
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_add_va.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_add_va.elem_address=elem_address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_add_va.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_add_va.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_add_va.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_add_va.sub_address.len=sub_address_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_prov_model_sub_add_va.sub_address.data,sub_address_data,sub_address_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_model_sub_add_va_id+(((11+sub_address_len)&0xff)<<8)+(((11+sub_address_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_model_sub_add_va;
}

/** 
*
* gecko_cmd_mesh_prov_model_sub_del_va
*
* Deprecated and replaced by mesh_config_client_remove_model_sub_va command.
* 
* Remove a virtual address from a model's subscription list. Node response is
* reported with a configuration status event. 
*
* @param address   Unicast address of the target node
* @param elem_address   Unicast address of the element containing the model, which will be configured
* @param netkey_index   The network key index used for encrypting the request
* @param vendor_id   Vendor ID of the configured model. Use 0xffff for Bluetooth SIG models.
* @param model_id   Model ID of the configured model
* @param sub_address_len   Array length
* @param sub_address_data   The Label UUID to remove from the subscription list. The array must be exactly
*  16 bytes long.
*
* Events generated
*
* gecko_evt_mesh_prov_config_status - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_model_sub_del_va_rsp_t* gecko_cmd_mesh_prov_model_sub_del_va(uint16 address,uint16 elem_address,uint16 netkey_index,uint16 vendor_id,uint16 model_id,uint8 sub_address_len, const uint8* sub_address_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)sub_address_len > 256 - 11)
    {
        gecko_rsp_msg->data.rsp_mesh_prov_model_sub_del_va.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_prov_model_sub_del_va;
    }

    
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_del_va.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_del_va.elem_address=elem_address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_del_va.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_del_va.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_del_va.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_del_va.sub_address.len=sub_address_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_prov_model_sub_del_va.sub_address.data,sub_address_data,sub_address_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_model_sub_del_va_id+(((11+sub_address_len)&0xff)<<8)+(((11+sub_address_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_model_sub_del_va;
}

/** 
*
* gecko_cmd_mesh_prov_model_sub_set
*
* Deprecated and replaced by mesh_config_client_set_model_sub command.
* 
* Set an address to a model's subscription list, overwriting previous contents.
* Node response is reported with a configuration status event. 
*
* @param address   Unicast address of the target node
* @param elem_address   Unicast address of the element containing the model, which will be configured
* @param netkey_index   The network key index used for encrypting the request
* @param vendor_id   Vendor ID of the model being configured. Use 0xffff for Bluetooth SIG models.
* @param model_id   Model ID of the configured model
* @param sub_address   The address to set as the subscription list. Note that the address has to be a
*  group address.
*
* Events generated
*
* gecko_evt_mesh_prov_config_status - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_model_sub_set_rsp_t* gecko_cmd_mesh_prov_model_sub_set(uint16 address,uint16 elem_address,uint16 netkey_index,uint16 vendor_id,uint16 model_id,uint16 sub_address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_set.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_set.elem_address=elem_address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_set.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_set.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_set.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_set.sub_address=sub_address;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_model_sub_set_id+(((12)&0xff)<<8)+(((12)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_model_sub_set;
}

/** 
*
* gecko_cmd_mesh_prov_model_sub_set_va
*
* Deprecated and replaced by mesh_config_client_set_model_sub_va command.
* 
* Set a virtual address to a model's subscription list overwriting previous
* content. Node response is reported with a configuration status event. 
*
* @param address   Unicast address of the target node
* @param elem_address   Unicast address of the element containing the model, which will be configured
* @param netkey_index   The network key index used for encrypting the request
* @param vendor_id   Vendor ID of the configured model. Use 0xffff for Bluetooth SIG models.
* @param model_id   Model ID of the configured model
* @param sub_address_len   Array length
* @param sub_address_data   The Label UUID to set as the subscription list. The byte array must be exactly
*  16 bytes long.
*
* Events generated
*
* gecko_evt_mesh_prov_config_status - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_model_sub_set_va_rsp_t* gecko_cmd_mesh_prov_model_sub_set_va(uint16 address,uint16 elem_address,uint16 netkey_index,uint16 vendor_id,uint16 model_id,uint8 sub_address_len, const uint8* sub_address_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)sub_address_len > 256 - 11)
    {
        gecko_rsp_msg->data.rsp_mesh_prov_model_sub_set_va.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_prov_model_sub_set_va;
    }

    
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_set_va.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_set_va.elem_address=elem_address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_set_va.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_set_va.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_set_va.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_set_va.sub_address.len=sub_address_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_prov_model_sub_set_va.sub_address.data,sub_address_data,sub_address_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_model_sub_set_va_id+(((11+sub_address_len)&0xff)<<8)+(((11+sub_address_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_model_sub_set_va;
}

/** 
*
* gecko_cmd_mesh_prov_heartbeat_publication_get
*
* Deprecated and replaced by mesh_config_client_get_heartbeat_pub command.
* 
* Get heartbeat publication state of a node. Node response will be reported as a
* heartbeat publication status event. 
*
* @param address   Unicast address of the target node
* @param netkey_index   Network key index used to encrypt the request
*
* Events generated
*
* gecko_evt_mesh_prov_heartbeat_publication_status - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_heartbeat_publication_get_rsp_t* gecko_cmd_mesh_prov_heartbeat_publication_get(uint16 address,uint16 netkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_heartbeat_publication_get.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_heartbeat_publication_get.netkey_index=netkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_heartbeat_publication_get_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_heartbeat_publication_get;
}

/** 
*
* gecko_cmd_mesh_prov_heartbeat_publication_set
*
* Deprecated and replaced by mesh_config_client_set_heartbeat_pub command.
* 
* Set heartbeat publication state of a node. Node response will be reported as a
* heartbeat publication status event. 
*
* @param address   Unicast address of the target node
* @param netkey_index   The network key index used in encrypting the request.
* @param publication_address   Heartbeat publication address. The address cannot be a virtual address. Note
*  that it can be the unassigned address, in which case the heartbeat publishing
*  is disabled.
* @param count_log   Heartbeat publication count setting. Valid values are as follows:  
*  
*      0x00: Heartbeat messages are not sent
*      0x01 .. 0x11: Node sends 2^(n-1) heartbeat messages
*      0x12 .. 0xfe: Prohibited
*      0xff: Heartbeat messages are sent indefinitely
* @param period_log   Heartbeat publication period setting. Valid values are as follows:  
*  
*      0x00: Heartbeat messages are not sent
*      0x01 .. 0x11: Node sends a heartbeat message every 2^(n-1) seconds
*      0x12 .. 0xff: Prohibited
* @param ttl   Time-to-live parameter for heartbeat messages
* @param features   Heartbeat trigger setting. For bits set in the bitmask, reconfiguration of the
*  node feature associated with the bit will result in the node emitting a
*  heartbeat message. Valid values are as follows:
*  
*      Bit 0: Relay feature
*      Bit 1: Proxy feature
*      Bit 2: Friend feature
*      Bit 3: Low power feature
*  
*  Remaining bits are reserved for future use.
* @param publication_netkey_index   Index of the network key used to encrypt heartbeat messages
*
* Events generated
*
* gecko_evt_mesh_prov_heartbeat_publication_status - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_heartbeat_publication_set_rsp_t* gecko_cmd_mesh_prov_heartbeat_publication_set(uint16 address,uint16 netkey_index,uint16 publication_address,uint8 count_log,uint8 period_log,uint8 ttl,uint16 features,uint16 publication_netkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_heartbeat_publication_set.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_heartbeat_publication_set.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_heartbeat_publication_set.publication_address=publication_address;
    gecko_cmd_msg->data.cmd_mesh_prov_heartbeat_publication_set.count_log=count_log;
    gecko_cmd_msg->data.cmd_mesh_prov_heartbeat_publication_set.period_log=period_log;
    gecko_cmd_msg->data.cmd_mesh_prov_heartbeat_publication_set.ttl=ttl;
    gecko_cmd_msg->data.cmd_mesh_prov_heartbeat_publication_set.features=features;
    gecko_cmd_msg->data.cmd_mesh_prov_heartbeat_publication_set.publication_netkey_index=publication_netkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_heartbeat_publication_set_id+(((13)&0xff)<<8)+(((13)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_heartbeat_publication_set;
}

/** 
*
* gecko_cmd_mesh_prov_heartbeat_subscription_get
*
* Deprecated and replaced by mesh_config_client_get_heartbeat_sub command.
* 
* Get node heartbeat subscription state. The node will respond with a
* subscription status event. 
*
* @param address   Unicast address of the target node
* @param netkey_index   The network key index used to encrypt the request
*
* Events generated
*
* gecko_evt_mesh_prov_heartbeat_subscription_status - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_heartbeat_subscription_get_rsp_t* gecko_cmd_mesh_prov_heartbeat_subscription_get(uint16 address,uint16 netkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_heartbeat_subscription_get.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_heartbeat_subscription_get.netkey_index=netkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_heartbeat_subscription_get_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_heartbeat_subscription_get;
}

/** 
*
* gecko_cmd_mesh_prov_heartbeat_subscription_set
*
* Deprecated and replaced by mesh_config_client_set_heartbeat_sub command.
* 
* Get node heartbeat subscription state. The node will respond with a
* subscription status event. 
*
* @param address   Unicast address of the target node
* @param netkey_index   The network key index used in encrypting the request
* @param subscription_source   Source address for heartbeat messages. Must be either a unicast address or the
*  unassigned address, in which case heartbeat messages are not processed.
* @param subscription_destination   Destination address for heartbeat messages. The address must be either the
*  unicast address of the primary element of the node, a group address, or the
*  unassigned address. If it is the unassigned address, heartbeat messages are
*  not processed.
* @param period_log   Heartbeat subscription period setting. Valid values are as follows:  
*  
*      0x00: Heartbeat messages are not received
*      0x01 .. 0x11: Node receives heartbeat messages for 2^(n-1) seconds
*      0x12 .. 0xff: Prohibited
*
* Events generated
*
* gecko_evt_mesh_prov_heartbeat_subscription_status - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_heartbeat_subscription_set_rsp_t* gecko_cmd_mesh_prov_heartbeat_subscription_set(uint16 address,uint16 netkey_index,uint16 subscription_source,uint16 subscription_destination,uint8 period_log)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_heartbeat_subscription_set.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_heartbeat_subscription_set.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_heartbeat_subscription_set.subscription_source=subscription_source;
    gecko_cmd_msg->data.cmd_mesh_prov_heartbeat_subscription_set.subscription_destination=subscription_destination;
    gecko_cmd_msg->data.cmd_mesh_prov_heartbeat_subscription_set.period_log=period_log;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_heartbeat_subscription_set_id+(((9)&0xff)<<8)+(((9)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_heartbeat_subscription_set;
}

/** 
*
* gecko_cmd_mesh_prov_relay_get
*
* Deprecated and replaced by mesh_config_client_get_relay command.
* 
* Get node relay retransmission state. The node will respond with a subscription
* status event. 
*
* @param address   Unicast address of the target node
* @param netkey_index   The network key index used in encrypting the request
*
* Events generated
*
* gecko_evt_mesh_prov_relay_status - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_relay_get_rsp_t* gecko_cmd_mesh_prov_relay_get(uint16 address,uint16 netkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_relay_get.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_relay_get.netkey_index=netkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_relay_get_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_relay_get;
}

/** 
*
* gecko_cmd_mesh_prov_relay_set
*
* Deprecated and replaced by mesh_config_client_set_relay command.
* 
* Set node relay retransmission state. The node will respond with a relay status
* event. 
*
* @param address   Unicast address of the target node
* @param netkey_index   The network key index used in encrypting the request.
* @param relay   Relay state. Valid values are as follows:  
*  
*      0x00: Relaying disabled
*      0x01: Relaying enabled
* @param count   Relay retransmit count. Value must be between 0 and 7; default value is 0 (no
*  retransmissions).
* @param interval   Relay retransmit interval in milliseconds. Value must be between 0 and 31; it
*  represents 10-millisecond increments, starting at 10 ms.
*
* Events generated
*
* gecko_evt_mesh_prov_relay_status - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_relay_set_rsp_t* gecko_cmd_mesh_prov_relay_set(uint16 address,uint16 netkey_index,uint8 relay,uint8 count,uint8 interval)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_relay_set.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_relay_set.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_relay_set.relay=relay;
    gecko_cmd_msg->data.cmd_mesh_prov_relay_set.count=count;
    gecko_cmd_msg->data.cmd_mesh_prov_relay_set.interval=interval;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_relay_set_id+(((7)&0xff)<<8)+(((7)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_relay_set;
}

/** 
*
* gecko_cmd_mesh_prov_reset_node
*
* Deprecated and replaced by mesh_config_client_reset_node command.
* 
* Send a reset request to a node.
* 
* If a node replies to the request, a node reset event will be generated. Note
* that the reply packet may get lost and the node has reset itself even in the
* absence of the event.
* 
* Also note that for securely removing a node from the network, perform a key
* refresh with the removed node blacklisted. 
*
* @param address   Unicast address of the target node
* @param netkey_index   The network key index used in encrypting the request
*
* Events generated
*
* gecko_evt_mesh_prov_node_reset - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_reset_node_rsp_t* gecko_cmd_mesh_prov_reset_node(uint16 address,uint16 netkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_reset_node.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_reset_node.netkey_index=netkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_reset_node_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_reset_node;
}

/** 
*
* gecko_cmd_mesh_prov_appkey_get
*
* Deprecated and replaced by mesh_config_client_list_appkeys command.
* 
* Get a list of application keys bound to a network key on a node.
* 
* Return a list of application key indices for the application keys bound to a
* particular network key on a node.
* 
* Node response is reported with a number of application key list events,
* terminated by a application key list end event. 
*
* @param address   Unicast address of the target node's primary element
* @param netkey_index   Index of the network key to which the application keys are bound on the node
*
* Events generated
*
* gecko_evt_mesh_prov_appkey_list - 
* gecko_evt_mesh_prov_appkey_list_end - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_appkey_get_rsp_t* gecko_cmd_mesh_prov_appkey_get(uint16 address,uint16 netkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_appkey_get.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_appkey_get.netkey_index=netkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_appkey_get_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_appkey_get;
}

/** 
*
* gecko_cmd_mesh_prov_network_get
*
* Deprecated and replaced by mesh_config_client_list_netkeys command.
* 
* Get a list of network keys bound from a node.
* 
* Return a list of network key indices of network keys deployed to a node.
* 
* Node response is reported with a number of network key list events, terminated
* by a network key list end event. 
*
* @param address   Unicast address of the target node's primary element
*
* Events generated
*
* gecko_evt_mesh_prov_network_list - 
* gecko_evt_mesh_prov_network_list_end - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_network_get_rsp_t* gecko_cmd_mesh_prov_network_get(uint16 address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_network_get.address=address;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_network_get_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_network_get;
}

/** 
*
* gecko_cmd_mesh_prov_model_sub_clear
*
* Deprecated and replaced by mesh_config_client_clear_model_sub command.
* 
* Clear all addresses from a model's subscription list. Node response is
* reported with a configuration status event. 
*
* @param address   Unicast address of the target node
* @param elem_address   Unicast address of the element containing the model, which will be configured
* @param netkey_index   The network key index used for encrypting the request
* @param vendor_id   Vendor ID of the configured model. Use 0xffff for Bluetooth SIG models.
* @param model_id   Model ID of the configured model
*
* Events generated
*
* gecko_evt_mesh_prov_config_status - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_model_sub_clear_rsp_t* gecko_cmd_mesh_prov_model_sub_clear(uint16 address,uint16 elem_address,uint16 netkey_index,uint16 vendor_id,uint16 model_id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_clear.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_clear.elem_address=elem_address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_clear.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_clear.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_clear.model_id=model_id;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_model_sub_clear_id+(((10)&0xff)<<8)+(((10)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_model_sub_clear;
}

/** 
*
* gecko_cmd_mesh_prov_model_pub_get
*
* Deprecated and replaced by mesh_config_client_get_model_pub command.
* 
* Get a model's publication address, key, and parameters. Node response is
* reported with a model publication parameters event. 
*
* @param address   Unicast address of the target node
* @param elem_address   Unicast address of the element containing the model, which will be configured
* @param vendor_id   Vendor ID of the configured model. Use 0xffff for Bluetooth SIG models.
* @param model_id   Model ID of the configured model
*
* Events generated
*
* gecko_evt_mesh_prov_model_pub_status - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_model_pub_get_rsp_t* gecko_cmd_mesh_prov_model_pub_get(uint16 address,uint16 elem_address,uint16 vendor_id,uint16 model_id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_get.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_get.elem_address=elem_address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_get.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_get.model_id=model_id;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_model_pub_get_id+(((8)&0xff)<<8)+(((8)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_model_pub_get;
}

/** 
*
* gecko_cmd_mesh_prov_model_pub_set_va
*
* Deprecated and replaced by mesh_config_client_set_model_pub_va command.
* 
* Set a model's publication virtual address, key, and parameters. Node response
* is reported with a configuration status event. 
*
* @param address   Unicast address of the target node
* @param elem_address   Unicast address of the element containing the model, which will be configured.
* @param netkey_index   The network key index used for encrypting the request
* @param appkey_index   The application key index to use for the published messages
* @param vendor_id   Vendor ID of the model being configured. Use 0xffff for Bluetooth SIG models.
* @param model_id   Model ID of the configured model
* @param ttl   Publication time-to-live value
* @param period   Publication period encoded as step count and step resolution. The encoding is
*  as follows:
*  
*      Bits 0..5: Step count
*      Bits 6..7: Step resolution: 
*      * 00: 100 milliseconds
*      * 01: 1 second
*      * 10: 10 seconds
*      * 11: 10 minutes
* @param retrans   See documentation of model publication set command for details.
* @param pub_address_len   Array length
* @param pub_address_data   The Label UUID to publish to. The byte array must be exactly 16 bytes long.
*
* Events generated
*
* gecko_evt_mesh_prov_config_status - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_model_pub_set_va_rsp_t* gecko_cmd_mesh_prov_model_pub_set_va(uint16 address,uint16 elem_address,uint16 netkey_index,uint16 appkey_index,uint16 vendor_id,uint16 model_id,uint8 ttl,uint8 period,uint8 retrans,uint8 pub_address_len, const uint8* pub_address_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)pub_address_len > 256 - 16)
    {
        gecko_rsp_msg->data.rsp_mesh_prov_model_pub_set_va.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_prov_model_pub_set_va;
    }

    
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_va.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_va.elem_address=elem_address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_va.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_va.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_va.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_va.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_va.ttl=ttl;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_va.period=period;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_va.retrans=retrans;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_va.pub_address.len=pub_address_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_va.pub_address.data,pub_address_data,pub_address_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_model_pub_set_va_id+(((16+pub_address_len)&0xff)<<8)+(((16+pub_address_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_model_pub_set_va;
}

/** 
*
* gecko_cmd_mesh_prov_model_pub_set_cred
*
* Deprecated and replaced by mesh_config_client_set_model_pub command.
* 
* This command is otherwise the same as the regular model publication set
* command but it also has a parameter for setting the Friendship Credential
* Flag. 
*
* @param address   Unicast address of the target node
* @param elem_address   Unicast address of the element containing the model, which will be configured
* @param netkey_index   The network key index for encrypting the request
* @param appkey_index   The application key index for the published messages
* @param vendor_id   Vendor ID of the model being configured. Use 0xffff for Bluetooth SIG models.
* @param model_id   Model ID of the configured model
* @param pub_address   The address to publish to. It can be a unicast address, a virtual address, or
*  a group address. It can also be the unassigned address to stop the model from
*  publishing.
* @param ttl   Publication time-to-live value
* @param period   Publication period encoded as step count and step resolution. The encoding is
*  as follows:
*  
*      Bits 0..5: Step count
*      Bits 6..7: Step resolution: 
*      * 00: 100 milliseconds
*      * 01: 1 second
*      * 10: 10 seconds
*      * 11: 10 minutes
* @param retrans   See documentation of model publication set command for details.
* @param credentials   Friendship credential flag. If the value is zero, publication is done using
*  normal credentials. If the value is one, it is done with friendship
*  credentials, meaning only the friend can decrypt the published message and
*  relay it forward using the normal credentials. The default value is 0.
*
* Events generated
*
* gecko_evt_mesh_prov_config_status - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_model_pub_set_cred_rsp_t* gecko_cmd_mesh_prov_model_pub_set_cred(uint16 address,uint16 elem_address,uint16 netkey_index,uint16 appkey_index,uint16 vendor_id,uint16 model_id,uint16 pub_address,uint8 ttl,uint8 period,uint8 retrans,uint8 credentials)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_cred.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_cred.elem_address=elem_address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_cred.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_cred.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_cred.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_cred.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_cred.pub_address=pub_address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_cred.ttl=ttl;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_cred.period=period;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_cred.retrans=retrans;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_cred.credentials=credentials;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_model_pub_set_cred_id+(((18)&0xff)<<8)+(((18)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_model_pub_set_cred;
}

/** 
*
* gecko_cmd_mesh_prov_model_pub_set_va_cred
*
* Deprecated and replaced by mesh_config_client_set_model_pub_va command.
* 
* This command is otherwise the same as the regular model publication set
* virtual address command but it also has a parameter for setting the Friendship
* Credential Flag. 
*
* @param address   Unicast address of the target node
* @param elem_address   Unicast address of the element containing the model, which will be configured
* @param netkey_index   The network key index for encrypting the request.
* @param appkey_index   The application key index for the published messages.
* @param vendor_id   Vendor ID of the configured model. Use 0xffff for Bluetooth SIG models.
* @param model_id   Model ID of the configured model
* @param ttl   Publication time-to-live value
* @param period   Publication period encoded as step count and step resolution. The encoding is
*  as follows:
*  
*      Bits 0..5: Step count
*      Bits 6..7: Step resolution: 
*      * 00: 100 milliseconds
*      * 01: 1 second
*      * 10: 10 seconds
*      * 11: 10 minutes
* @param retrans   See documentation of model publication set command for details.
* @param credentials   Friendship credential flag. If the value is zero, publication is done using
*  normal credentials. If the value is one, it is done with friendship
*  credentials, meaning only the friend can decrypt the published message and
*  relay it forward using the normal credentials. The default value is 0.
* @param pub_address_len   Array length
* @param pub_address_data   The Label UUID to publish to. The byte array must be exactly 16 bytes long.
*
* Events generated
*
* gecko_evt_mesh_prov_config_status - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_model_pub_set_va_cred_rsp_t* gecko_cmd_mesh_prov_model_pub_set_va_cred(uint16 address,uint16 elem_address,uint16 netkey_index,uint16 appkey_index,uint16 vendor_id,uint16 model_id,uint8 ttl,uint8 period,uint8 retrans,uint8 credentials,uint8 pub_address_len, const uint8* pub_address_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)pub_address_len > 256 - 17)
    {
        gecko_rsp_msg->data.rsp_mesh_prov_model_pub_set_va_cred.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_prov_model_pub_set_va_cred;
    }

    
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_va_cred.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_va_cred.elem_address=elem_address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_va_cred.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_va_cred.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_va_cred.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_va_cred.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_va_cred.ttl=ttl;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_va_cred.period=period;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_va_cred.retrans=retrans;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_va_cred.credentials=credentials;
    gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_va_cred.pub_address.len=pub_address_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_prov_model_pub_set_va_cred.pub_address.data,pub_address_data,pub_address_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_model_pub_set_va_cred_id+(((17+pub_address_len)&0xff)<<8)+(((17+pub_address_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_model_pub_set_va_cred;
}

/** 
*
* gecko_cmd_mesh_prov_model_sub_get
*
* Deprecated and replaced by mesh_config_client_list_subs command.
* 
* Get a model's subscription list. Node response is reported with subscription
* list entry and subscription list entries end events. 
*
* @param address   Unicast address of the target node
* @param elem_address   Unicast address of the element containing the model, which will be configured
* @param netkey_index   The network key index for encrypting the request
* @param vendor_id   Vendor ID of the model being configured. Use 0xffff for Bluetooth SIG models.
* @param model_id   Model ID of the configured model
*
* Events generated
*
* gecko_evt_mesh_prov_model_sub_addr - 
* gecko_evt_mesh_prov_model_sub_addr_end - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_model_sub_get_rsp_t* gecko_cmd_mesh_prov_model_sub_get(uint16 address,uint16 elem_address,uint16 netkey_index,uint16 vendor_id,uint16 model_id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_get.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_get.elem_address=elem_address;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_get.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_get.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_prov_model_sub_get.model_id=model_id;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_model_sub_get_id+(((10)&0xff)<<8)+(((10)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_model_sub_get;
}

/** 
*
* gecko_cmd_mesh_prov_friend_timeout_get
*
* Deprecated and replaced by mesh_config_client_get_lpn_polltimeout command.
* 
* LPN poll timeout request. Result is reported in a  friend poll timeout status
* event. 
*
* @param address   Unicast address of the friend node
* @param netkey_index   The network key index used in encrypting the request
* @param lpn_address   Unicast address of the LPN node
*
* Events generated
*
* gecko_evt_mesh_prov_friend_timeout_status - 
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_friend_timeout_get_rsp_t* gecko_cmd_mesh_prov_friend_timeout_get(uint16 address,uint16 netkey_index,uint16 lpn_address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_friend_timeout_get.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_friend_timeout_get.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_friend_timeout_get.lpn_address=lpn_address;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_friend_timeout_get_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_friend_timeout_get;
}

/** 
*
* gecko_cmd_mesh_prov_get_default_configuration_timeout
*
* Deprecated and replaced by mesh_config_client_get_default_timeout command.
* 
* Get the default timeout for configuration client requests. If there is no
* response when the timeout expires, a configuration request is considered to
* have failed. 
*
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_get_default_configuration_timeout_rsp_t* gecko_cmd_mesh_prov_get_default_configuration_timeout()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_get_default_configuration_timeout_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_get_default_configuration_timeout;
}

/** 
*
* gecko_cmd_mesh_prov_set_default_configuration_timeout
*
* Deprecated and replaced by mesh_config_client_set_default_timeout command.
* 
* Set the default timeout for configuration client requests. If there is no
* response when the timeout expires, a configuration request is considered to
* have failed. 
*
* @param timeout   Timeout in milliseconds. Default timeout is 5 s (5000 ms).
* @param lpn_timeout   Timeout in milliseconds when communicating with an LPN node. Default LPN
*  timeout is 120 s (120000 ms).
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_prov_set_default_configuration_timeout_rsp_t* gecko_cmd_mesh_prov_set_default_configuration_timeout(uint32 timeout,uint32 lpn_timeout)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_set_default_configuration_timeout.timeout=timeout;
    gecko_cmd_msg->data.cmd_mesh_prov_set_default_configuration_timeout.lpn_timeout=lpn_timeout;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_set_default_configuration_timeout_id+(((8)&0xff)<<8)+(((8)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_set_default_configuration_timeout;
}

/** 
*
* gecko_cmd_mesh_prov_provision_device_with_address
*
* Provision a device into a network using the advertisement bearer (PB-ADV).
* Application may specify the unicast addresses given for the device elements
* with this command.
* 
* Issuing this command starts the provisioning process for the specified device.
* Once the process completes successfully, a device provisioned event is
* generated. If provisioning does not succeed, a  provisioning failed event will
* be generated instead. 
*
* @param network_id   Index of the initial network key, which is sent to the device during
*  provisioning
* @param address   Unicast address for the primary element of the device. If unassigned address
*  (0x0000) is given, the stack will automatically assign an address. Note that
*  element addresses are contiguous and must all be unicast addresses; primary
*  address must be chosen so that also the last element's address will still be a
*  unicast address.
* @param elements   Number of elements in device to be provisioned. If the primary element address
*  is set to unassigned, this needs to be set to zero.
* @param attention_timer   Attention timer value, in seconds, which indicates the time that the
*  provisioned device should attract human attention
* @param uuid_len   Array length
* @param uuid_data   UUID of the device to provision
*
* Events generated
*
* gecko_evt_mesh_prov_device_provisioned - 
* gecko_evt_mesh_prov_provisioning_failed - 
*
**/

static inline struct gecko_msg_mesh_prov_provision_device_with_address_rsp_t* gecko_cmd_mesh_prov_provision_device_with_address(uint8 network_id,uint16 address,uint8 elements,uint8 attention_timer,uint8 uuid_len, const uint8* uuid_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)uuid_len > 256 - 6)
    {
        gecko_rsp_msg->data.rsp_mesh_prov_provision_device_with_address.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_prov_provision_device_with_address;
    }

    
    gecko_cmd_msg->data.cmd_mesh_prov_provision_device_with_address.network_id=network_id;
    gecko_cmd_msg->data.cmd_mesh_prov_provision_device_with_address.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_provision_device_with_address.elements=elements;
    gecko_cmd_msg->data.cmd_mesh_prov_provision_device_with_address.attention_timer=attention_timer;
    gecko_cmd_msg->data.cmd_mesh_prov_provision_device_with_address.uuid.len=uuid_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_prov_provision_device_with_address.uuid.data,uuid_data,uuid_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_provision_device_with_address_id+(((6+uuid_len)&0xff)<<8)+(((6+uuid_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_provision_device_with_address;
}

/** 
*
* gecko_cmd_mesh_prov_provision_gatt_device_with_address
*
* Provision a device into a network using the GATT bearer (PB-GATT). Application
* may specify the unicast addresses given for the device elements with this
* command.
* 
* Issuing this command starts the provisioning process for the specified device.
* Once the process completes successfully, a device provisioned event is
* generated. If provisioning does not succeed, a  provisioning failed event will
* be generated instead.
* 
* Note that this command is available only if GATT functionality is compiled in
* to the firmware. If that is not the case, the command will return with a "not
* implemented" return code. 
*
* @param network_id   Index of the initial network key, which is sent to the device during
*  provisioning
* @param connection   Connection handle for the device to be provisioned
* @param address   Unicast address for the primary element of the device. If unassigned address
*  (0x0000) is given, the stack will automatically assign an address. Note that
*  element addresses are contiguous and must all be unicast addresses; primary
*  address must be chosen so that also the last element's address will still be a
*  unicast address.
* @param elements   Number of elements in device to be provisioned. If the primary element address
*  is set to unassigned, this needs to be set to zero.
* @param attention_timer   Attention timer value, in seconds, indicates the time that the provisioned
*  device should attract human attention
* @param uuid_len   Array length
* @param uuid_data   UUID of the device to provision
*
* Events generated
*
* gecko_evt_mesh_prov_device_provisioned - 
* gecko_evt_mesh_prov_provisioning_failed - 
*
**/

static inline struct gecko_msg_mesh_prov_provision_gatt_device_with_address_rsp_t* gecko_cmd_mesh_prov_provision_gatt_device_with_address(uint8 network_id,uint8 connection,uint16 address,uint8 elements,uint8 attention_timer,uint8 uuid_len, const uint8* uuid_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)uuid_len > 256 - 7)
    {
        gecko_rsp_msg->data.rsp_mesh_prov_provision_gatt_device_with_address.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_prov_provision_gatt_device_with_address;
    }

    
    gecko_cmd_msg->data.cmd_mesh_prov_provision_gatt_device_with_address.network_id=network_id;
    gecko_cmd_msg->data.cmd_mesh_prov_provision_gatt_device_with_address.connection=connection;
    gecko_cmd_msg->data.cmd_mesh_prov_provision_gatt_device_with_address.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_provision_gatt_device_with_address.elements=elements;
    gecko_cmd_msg->data.cmd_mesh_prov_provision_gatt_device_with_address.attention_timer=attention_timer;
    gecko_cmd_msg->data.cmd_mesh_prov_provision_gatt_device_with_address.uuid.len=uuid_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_prov_provision_gatt_device_with_address.uuid.data,uuid_data,uuid_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_provision_gatt_device_with_address_id+(((7+uuid_len)&0xff)<<8)+(((7+uuid_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_provision_gatt_device_with_address;
}

/** 
*
* gecko_cmd_mesh_prov_initialize_network
*
* Initialize mesh network and assign provisioner address and IV index for the
* network. If this command is not invoked prior to invoking mesh prov create
* network, the network will be initialized with default address and IV index. 
*
* @param address   Address to assign for provisioner.
* @param ivi   IV index of the network.
*
**/

static inline struct gecko_msg_mesh_prov_initialize_network_rsp_t* gecko_cmd_mesh_prov_initialize_network(uint16 address,uint32 ivi)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_initialize_network.address=address;
    gecko_cmd_msg->data.cmd_mesh_prov_initialize_network.ivi=ivi;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_initialize_network_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_initialize_network;
}

/** 
*
* gecko_cmd_mesh_prov_get_key_refresh_appkey_blacklist
*
* Check the application key refresh blacklist status of a node. Nodes which are
* blacklisted for a given application key do not receive updates for that
* particular application key, but do participate in the key refresh procedure as
* a whole. This enables the Provisioner to set up and update restricted sets of
* application keys across the nodes. 
*
* @param netkey_index   Network key index
* @param appkey_index   Application key index
* @param uuid_len   Array length
* @param uuid_data   UUID of the Device
*
**/

static inline struct gecko_msg_mesh_prov_get_key_refresh_appkey_blacklist_rsp_t* gecko_cmd_mesh_prov_get_key_refresh_appkey_blacklist(uint16 netkey_index,uint16 appkey_index,uint8 uuid_len, const uint8* uuid_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)uuid_len > 256 - 5)
    {
        gecko_rsp_msg->data.rsp_mesh_prov_get_key_refresh_appkey_blacklist.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_prov_get_key_refresh_appkey_blacklist;
    }

    
    gecko_cmd_msg->data.cmd_mesh_prov_get_key_refresh_appkey_blacklist.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_get_key_refresh_appkey_blacklist.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_get_key_refresh_appkey_blacklist.uuid.len=uuid_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_prov_get_key_refresh_appkey_blacklist.uuid.data,uuid_data,uuid_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_get_key_refresh_appkey_blacklist_id+(((5+uuid_len)&0xff)<<8)+(((5+uuid_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_get_key_refresh_appkey_blacklist;
}

/** 
*
* gecko_cmd_mesh_prov_set_key_refresh_appkey_blacklist
*
* Set the application key refresh blacklist status of a node. Nodes which are
* blacklisted for a given application key do not receive updates for that
* particular application key, but do participate in the key refresh procedure as
* a whole. This enables the Provisioner to set up and update restricted sets of
* application keys across the nodes. 
*
* @param netkey_index   Network key index
* @param appkey_index   Application key index
* @param status   Non-zero for blacklisted node
* @param uuid_len   Array length
* @param uuid_data   UUID of the device
*
**/

static inline struct gecko_msg_mesh_prov_set_key_refresh_appkey_blacklist_rsp_t* gecko_cmd_mesh_prov_set_key_refresh_appkey_blacklist(uint16 netkey_index,uint16 appkey_index,uint8 status,uint8 uuid_len, const uint8* uuid_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)uuid_len > 256 - 6)
    {
        gecko_rsp_msg->data.rsp_mesh_prov_set_key_refresh_appkey_blacklist.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_prov_set_key_refresh_appkey_blacklist;
    }

    
    gecko_cmd_msg->data.cmd_mesh_prov_set_key_refresh_appkey_blacklist.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_set_key_refresh_appkey_blacklist.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_set_key_refresh_appkey_blacklist.status=status;
    gecko_cmd_msg->data.cmd_mesh_prov_set_key_refresh_appkey_blacklist.uuid.len=uuid_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_prov_set_key_refresh_appkey_blacklist.uuid.data,uuid_data,uuid_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_set_key_refresh_appkey_blacklist_id+(((6+uuid_len)&0xff)<<8)+(((6+uuid_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_set_key_refresh_appkey_blacklist;
}

/** 
*
* gecko_cmd_mesh_prov_stop_scan_unprov_beacons
*
* Stop scanning for unprovisioned device beacons. 
*
*
**/

static inline struct gecko_msg_mesh_prov_stop_scan_unprov_beacons_rsp_t* gecko_cmd_mesh_prov_stop_scan_unprov_beacons()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_stop_scan_unprov_beacons_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_stop_scan_unprov_beacons;
}

/** 
*
* gecko_cmd_mesh_prov_ddb_update_netkey_index
*
* Update a node's entry in the Provisioner's device database by setting a new
* value to the netkey_index field. The netkey_index field is used to determine
* the network key to use when encrypting and decrypting configuration model
* messages to and from the node. 
*
* @param uuid   UUID of the node
* @param netkey_index   Index of the network key used in configuring the node.
*
**/

static inline struct gecko_msg_mesh_prov_ddb_update_netkey_index_rsp_t* gecko_cmd_mesh_prov_ddb_update_netkey_index(uuid_128 uuid,uint16 netkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_ddb_update_netkey_index.uuid=uuid;
    gecko_cmd_msg->data.cmd_mesh_prov_ddb_update_netkey_index.netkey_index=netkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_ddb_update_netkey_index_id+(((18)&0xff)<<8)+(((18)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_ddb_update_netkey_index;
}

/** 
*
* gecko_cmd_mesh_prov_key_refresh_suspend
*
* Suspend an ongoing key refresh procedure.
* 
* Suspending a key refresh procedure means no further requests for updating keys
* or setting key refresh phase will be sent to the network by the Provisioner
* until the key refresh procedure is resumed. 
*
* @param netkey_index   Index of the network key identifying an ongoing key refresh procedure
*
**/

static inline struct gecko_msg_mesh_prov_key_refresh_suspend_rsp_t* gecko_cmd_mesh_prov_key_refresh_suspend(uint16 netkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_key_refresh_suspend.netkey_index=netkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_key_refresh_suspend_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_key_refresh_suspend;
}

/** 
*
* gecko_cmd_mesh_prov_key_refresh_resume
*
* Resume a suspended key refresh procedure.
* 
* By resuming a suspended key refresh procedure the Provisioner will again start
* to send requests for updating keys or setting key refresh phase to the
* network. 
*
* @param netkey_index   Index of the network key identifying a suspended key refresh procedure
*
**/

static inline struct gecko_msg_mesh_prov_key_refresh_resume_rsp_t* gecko_cmd_mesh_prov_key_refresh_resume(uint16 netkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_key_refresh_resume.netkey_index=netkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_key_refresh_resume_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_key_refresh_resume;
}

/** 
*
* gecko_cmd_mesh_prov_get_key_refresh_phase
*
* Get the key refresh phase of an ongoing key refresh procedure. 
*
* @param netkey_index   Index of the network key identifying an ongoing key refresh procedure
*
**/

static inline struct gecko_msg_mesh_prov_get_key_refresh_phase_rsp_t* gecko_cmd_mesh_prov_get_key_refresh_phase(uint16 netkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_get_key_refresh_phase.netkey_index=netkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_get_key_refresh_phase_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_get_key_refresh_phase;
}

/** 
*
* gecko_cmd_mesh_prov_key_refresh_start_from_phase
*
* Start a key refresh procedure from a non-default phase. Before calling this
* the keys to be used in the key refresh procedure should have been specified by
* calling prepare key refresh command.
* 
* Note that this command should not normally be used. It is intended only for
* resuming an interrupted key refresh procedure on a backup Provisioner when the
* original Provisioner that started the key refresh procedure is no longer
* available to complete the procedure. 
*
* @param phase   Current key refresh phase
* @param netkey_index   Index of the network key identifying a key refresh procedure
* @param num_appkeys   Number of application keys to update; may be zero.
* @param appkey_indices_len   Array length
* @param appkey_indices_data   Indices of the application keys to update, represented as little endian two
*  byte sequences. The array must contain num_appkeys indices and therefore
*  2*num_appkeys bytes total.
*
* Events generated
*
* gecko_evt_mesh_prov_key_refresh_node_update - 
* gecko_evt_mesh_prov_key_refresh_phase_update - 
* gecko_evt_mesh_prov_key_refresh_complete - 
*
**/

static inline struct gecko_msg_mesh_prov_key_refresh_start_from_phase_rsp_t* gecko_cmd_mesh_prov_key_refresh_start_from_phase(uint8 phase,uint16 netkey_index,uint8 num_appkeys,uint8 appkey_indices_len, const uint8* appkey_indices_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)appkey_indices_len > 256 - 5)
    {
        gecko_rsp_msg->data.rsp_mesh_prov_key_refresh_start_from_phase.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_prov_key_refresh_start_from_phase;
    }

    
    gecko_cmd_msg->data.cmd_mesh_prov_key_refresh_start_from_phase.phase=phase;
    gecko_cmd_msg->data.cmd_mesh_prov_key_refresh_start_from_phase.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_prov_key_refresh_start_from_phase.num_appkeys=num_appkeys;
    gecko_cmd_msg->data.cmd_mesh_prov_key_refresh_start_from_phase.appkey_indices.len=appkey_indices_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_prov_key_refresh_start_from_phase.appkey_indices.data,appkey_indices_data,appkey_indices_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_key_refresh_start_from_phase_id+(((5+appkey_indices_len)&0xff)<<8)+(((5+appkey_indices_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_key_refresh_start_from_phase;
}

/** 
*
* gecko_cmd_mesh_prov_flush_key_refresh_state
*
* Clear key refresh state stored in persistent storage.
* 
* Note that this command should not normally be used. It is intended only for
* clearing stored key refresh state when a key refresh procedure has been
* suspended and will not be resumed, either because the network key has been
* deleted from all nodes or the responsibility for completing the key refresh
* has been moved to another Provisioner. 
*
* @param netkey_index   Index of the network key identifying a key refresh procedure
*
**/

static inline struct gecko_msg_mesh_prov_flush_key_refresh_state_rsp_t* gecko_cmd_mesh_prov_flush_key_refresh_state(uint16 netkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_prov_flush_key_refresh_state.netkey_index=netkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_prov_flush_key_refresh_state_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_prov_flush_key_refresh_state;
}

/** 
*
* gecko_cmd_mesh_proxy_connect
*
* Start connecting a proxy client to a proxy server. After the connection is
* complete, a  connection established event will be generated. LE-connection
* must be opened prior to opening proxy connection. 
*
* @param connection   Connection handle
*
**/

static inline struct gecko_msg_mesh_proxy_connect_rsp_t* gecko_cmd_mesh_proxy_connect(uint8 connection)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_proxy_connect.connection=connection;
    gecko_cmd_msg->header=(gecko_cmd_mesh_proxy_connect_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_proxy_connect;
}

/** 
*
* gecko_cmd_mesh_proxy_disconnect
*
* Disconnect. This call can be used also for a connection, which is not yet
* fully formed. 
*
* @param handle   Proxy handle
*
**/

static inline struct gecko_msg_mesh_proxy_disconnect_rsp_t* gecko_cmd_mesh_proxy_disconnect(uint32 handle)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_proxy_disconnect.handle=handle;
    gecko_cmd_msg->header=(gecko_cmd_mesh_proxy_disconnect_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_proxy_disconnect;
}

/** 
*
* gecko_cmd_mesh_proxy_set_filter_type
*
* Set up proxy filtering type. At the proxy server side, this is a local
* configuration, while on the proxy client a proxy configuration PDU will be
* sent to the proxy server. 
*
* @param handle   Proxy handle
* @param type   Filter type: 0x00 for whitelist, 0x01 for blacklist
* @param key   Network key index used in encrypting the request to the proxy server
*
**/

static inline struct gecko_msg_mesh_proxy_set_filter_type_rsp_t* gecko_cmd_mesh_proxy_set_filter_type(uint32 handle,uint8 type,uint16 key)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_proxy_set_filter_type.handle=handle;
    gecko_cmd_msg->data.cmd_mesh_proxy_set_filter_type.type=type;
    gecko_cmd_msg->data.cmd_mesh_proxy_set_filter_type.key=key;
    gecko_cmd_msg->header=(gecko_cmd_mesh_proxy_set_filter_type_id+(((7)&0xff)<<8)+(((7)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_proxy_set_filter_type;
}

/** 
*
* gecko_cmd_mesh_proxy_allow
*
* Allow messages destined to the given address to be forwarded over the proxy
* connection to the proxy client. At the proxy server side, this is a local
* configuration, while on the proxy client a proxy configuration PDU will be
* sent to the proxy server. 
*
* @param handle   Proxy handle
* @param address   Destination address to allow. The address may be either a unicast address, a
*  group address, or a virtual address.
* @param key   Network key index used in encrypting the request to the proxy server
*
**/

static inline struct gecko_msg_mesh_proxy_allow_rsp_t* gecko_cmd_mesh_proxy_allow(uint32 handle,uint16 address,uint16 key)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_proxy_allow.handle=handle;
    gecko_cmd_msg->data.cmd_mesh_proxy_allow.address=address;
    gecko_cmd_msg->data.cmd_mesh_proxy_allow.key=key;
    gecko_cmd_msg->header=(gecko_cmd_mesh_proxy_allow_id+(((8)&0xff)<<8)+(((8)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_proxy_allow;
}

/** 
*
* gecko_cmd_mesh_proxy_deny
*
* Block messages meant for the given address from being forwarded over the proxy
* connection to the proxy client. At the proxy server side, this is a local
* configuration, while on the proxy client a proxy configuration PDU will be
* sent to the proxy server. 
*
* @param handle   Proxy handle
* @param address   Destination address to block. The address may be either a unicast address, a
*  group address, or a virtual address.
* @param key   Network key index used in encrypting the request to the proxy server
*
**/

static inline struct gecko_msg_mesh_proxy_deny_rsp_t* gecko_cmd_mesh_proxy_deny(uint32 handle,uint16 address,uint16 key)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_proxy_deny.handle=handle;
    gecko_cmd_msg->data.cmd_mesh_proxy_deny.address=address;
    gecko_cmd_msg->data.cmd_mesh_proxy_deny.key=key;
    gecko_cmd_msg->header=(gecko_cmd_mesh_proxy_deny_id+(((8)&0xff)<<8)+(((8)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_proxy_deny;
}

/** 
*
* gecko_cmd_mesh_vendor_model_send
*
* Send vendor-specific data.
* 
* Note that, because of bgapi event length restrictions the message sent may
* need to be fragmented into several commands. If this is the case, the
* application must issue the commands in the correct order and mark the command
* carrying the last message fragment with the final flag set to a non-zero
* value. The stack will not start sending the message until the complete message
* is provided by the application. Fragments from multiple messages must not be
* interleaved. 
*
* @param elem_index   Sending model element index
* @param vendor_id   Vendor ID of the sending model
* @param model_id   Model ID of the sending model
* @param destination_address   Destination address of the message. It can be a unicast address, a group
*  address, or a virtual address.
* @param va_index   Index of the destination Label UUID (used only is the destination address is a
*  virtual address)
* @param appkey_index   The application key index used
* @param nonrelayed   If the message is a response to a received message, set this parameter
*  according to what was received in the receive event. Otherwise, set to non-
*  zero if the message affects only devices in the immediate radio neighborhood.
* @param opcode   Message opcode
* @param final   Indicates whether this payload chunk is the final one of the message or
*  whether more will follow.
* @param payload_len   Array length
* @param payload_data   Payload data (either complete or partial; see final parameter).
*
**/

static inline struct gecko_msg_mesh_vendor_model_send_rsp_t* gecko_cmd_mesh_vendor_model_send(uint16 elem_index,uint16 vendor_id,uint16 model_id,uint16 destination_address,int8 va_index,uint16 appkey_index,uint8 nonrelayed,uint8 opcode,uint8 final,uint8 payload_len, const uint8* payload_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)payload_len > 256 - 15)
    {
        gecko_rsp_msg->data.rsp_mesh_vendor_model_send.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_vendor_model_send;
    }

    
    gecko_cmd_msg->data.cmd_mesh_vendor_model_send.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_vendor_model_send.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_vendor_model_send.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_vendor_model_send.destination_address=destination_address;
    gecko_cmd_msg->data.cmd_mesh_vendor_model_send.va_index=va_index;
    gecko_cmd_msg->data.cmd_mesh_vendor_model_send.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_vendor_model_send.nonrelayed=nonrelayed;
    gecko_cmd_msg->data.cmd_mesh_vendor_model_send.opcode=opcode;
    gecko_cmd_msg->data.cmd_mesh_vendor_model_send.final=final;
    gecko_cmd_msg->data.cmd_mesh_vendor_model_send.payload.len=payload_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_vendor_model_send.payload.data,payload_data,payload_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_vendor_model_send_id+(((15+payload_len)&0xff)<<8)+(((15+payload_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_vendor_model_send;
}

/** 
*
* gecko_cmd_mesh_vendor_model_set_publication
*
* Set vendor model publication message.
* 
* The model publication message will be sent out when model publication occurs
* either periodically (if the model is configured for periodic publishing) or
* explicitly (see vendor model publish command.
* 
* Note that, because of bgapi length requirements the message may need to be
* fragmented over multiple commands. If this is the case, the application must
* issue the commands in the correct order and mark the command carrying the last
* message fragment with the final flag set to a non-zero value. The stack will
* not assign the message to the model until the complete message is provided by
* the application.
* 
* To disable publication the publication message may be erased using the  clear
* vendor model publication message command. 
*
* @param elem_index   Publishing model element index
* @param vendor_id   Vendor ID of the model
* @param model_id   Model ID of the model
* @param opcode   Message opcode
* @param final   Indicates whether this payload chunk is the final one of the message or
*  whether more will follow.
* @param payload_len   Array length
* @param payload_data   Payload data (either complete or partial; see final parameter).
*
**/

static inline struct gecko_msg_mesh_vendor_model_set_publication_rsp_t* gecko_cmd_mesh_vendor_model_set_publication(uint16 elem_index,uint16 vendor_id,uint16 model_id,uint8 opcode,uint8 final,uint8 payload_len, const uint8* payload_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)payload_len > 256 - 9)
    {
        gecko_rsp_msg->data.rsp_mesh_vendor_model_set_publication.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_vendor_model_set_publication;
    }

    
    gecko_cmd_msg->data.cmd_mesh_vendor_model_set_publication.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_vendor_model_set_publication.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_vendor_model_set_publication.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_vendor_model_set_publication.opcode=opcode;
    gecko_cmd_msg->data.cmd_mesh_vendor_model_set_publication.final=final;
    gecko_cmd_msg->data.cmd_mesh_vendor_model_set_publication.payload.len=payload_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_vendor_model_set_publication.payload.data,payload_data,payload_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_vendor_model_set_publication_id+(((9+payload_len)&0xff)<<8)+(((9+payload_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_vendor_model_set_publication;
}

/** 
*
* gecko_cmd_mesh_vendor_model_clear_publication
*
* Clear vendor model publication message.
* 
* Clearing the model publication message disables model publishing, which can be
* re-enabled by defining the publication message using the  set vendor model
* publication command. 
*
* @param elem_index   Publishing model element index
* @param vendor_id   Vendor ID of the model
* @param model_id   Model ID of the model
*
**/

static inline struct gecko_msg_mesh_vendor_model_clear_publication_rsp_t* gecko_cmd_mesh_vendor_model_clear_publication(uint16 elem_index,uint16 vendor_id,uint16 model_id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_vendor_model_clear_publication.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_vendor_model_clear_publication.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_vendor_model_clear_publication.model_id=model_id;
    gecko_cmd_msg->header=(gecko_cmd_mesh_vendor_model_clear_publication_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_vendor_model_clear_publication;
}

/** 
*
* gecko_cmd_mesh_vendor_model_publish
*
* Publish vendor model publication message.
* 
* Sends the stored publication message to the network using the application key
* and destination address stored in the model publication parameters. 
*
* @param elem_index   Publishing model element index
* @param vendor_id   Vendor ID of the model
* @param model_id   Model ID of the model
*
**/

static inline struct gecko_msg_mesh_vendor_model_publish_rsp_t* gecko_cmd_mesh_vendor_model_publish(uint16 elem_index,uint16 vendor_id,uint16 model_id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_vendor_model_publish.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_vendor_model_publish.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_vendor_model_publish.model_id=model_id;
    gecko_cmd_msg->header=(gecko_cmd_mesh_vendor_model_publish_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_vendor_model_publish;
}

/** 
*
* gecko_cmd_mesh_vendor_model_init
*
* Initialize the vendor model. This function has to be called before the model
* can be used. Note that the model can be deinitialized if it is not needed
* anymore; see deinitialization command.
* 
* Opcodes that the model is able to receive at initialization must be defined.
* This enables the stack to pass only valid messages up to the model during
* runtime. Per Mesh specification there are up to 64 opcodes per vendor, ranging
* from 0 to 63. Specifying opcodes outside of that range will result in an error
* response. Duplicate opcodes in the array do not result in an error, but will
* of course be recorded only once. 
*
* @param elem_index   Model element index
* @param vendor_id   Vendor ID of the model
* @param model_id   Model ID of the model
* @param publish   Indicates if the model is a publish model (non-zero) or not (zero).
* @param opcodes_len   Array length
* @param opcodes_data   Array of opcodes the model can handle
*
**/

static inline struct gecko_msg_mesh_vendor_model_init_rsp_t* gecko_cmd_mesh_vendor_model_init(uint16 elem_index,uint16 vendor_id,uint16 model_id,uint8 publish,uint8 opcodes_len, const uint8* opcodes_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)opcodes_len > 256 - 8)
    {
        gecko_rsp_msg->data.rsp_mesh_vendor_model_init.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_vendor_model_init;
    }

    
    gecko_cmd_msg->data.cmd_mesh_vendor_model_init.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_vendor_model_init.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_vendor_model_init.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_vendor_model_init.publish=publish;
    gecko_cmd_msg->data.cmd_mesh_vendor_model_init.opcodes.len=opcodes_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_vendor_model_init.opcodes.data,opcodes_data,opcodes_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_vendor_model_init_id+(((8+opcodes_len)&0xff)<<8)+(((8+opcodes_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_vendor_model_init;
}

/** 
*
* gecko_cmd_mesh_vendor_model_deinit
*
* Deinitialize the model. After this call, the model cannot be used until it is
* initialized again. See initialization command. 
*
* @param elem_index   Model element index
* @param vendor_id   Vendor ID of the model
* @param model_id   Model ID of the model
*
**/

static inline struct gecko_msg_mesh_vendor_model_deinit_rsp_t* gecko_cmd_mesh_vendor_model_deinit(uint16 elem_index,uint16 vendor_id,uint16 model_id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_vendor_model_deinit.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_vendor_model_deinit.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_vendor_model_deinit.model_id=model_id;
    gecko_cmd_msg->header=(gecko_cmd_mesh_vendor_model_deinit_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_vendor_model_deinit;
}

/** 
*
* gecko_cmd_mesh_health_client_get
*
* Get the registered fault status of a Health Server model or models in the
* network.
* 
* Besides the immediate result code, the response or responses (if the
* destination server address is a group address) from the network will generate
* server status report events. 
*
* @param elem_index   Client model element index. Identifies the client model used for sending the
*  request.
* @param server_address   Destination server model address. May be a unicast address or a group address.
* @param appkey_index   The application key index to use in encrypting the request
* @param vendor_id   Bluetooth vendor ID used in the request
*
**/

static inline struct gecko_msg_mesh_health_client_get_rsp_t* gecko_cmd_mesh_health_client_get(uint16 elem_index,uint16 server_address,uint16 appkey_index,uint16 vendor_id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_health_client_get.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_health_client_get.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_health_client_get.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_health_client_get.vendor_id=vendor_id;
    gecko_cmd_msg->header=(gecko_cmd_mesh_health_client_get_id+(((8)&0xff)<<8)+(((8)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_health_client_get;
}

/** 
*
* gecko_cmd_mesh_health_client_clear
*
* Clear the fault status of a Health Server model or models in the network.
* 
* Besides the immediate result code, the response or responses (if the
* destination server address is a group address) from the network will generate
* server status report events. 
*
* @param elem_index   Client model element index. Identifies the client model used for sending the
*  request.
* @param server_address   Destination server model address. May be a unicast address or a group address.
* @param appkey_index   The application key index to use in encrypting the request
* @param vendor_id   Bluetooth vendor ID used in the request
* @param reliable   If non-zero, a reliable model message is used.
*
**/

static inline struct gecko_msg_mesh_health_client_clear_rsp_t* gecko_cmd_mesh_health_client_clear(uint16 elem_index,uint16 server_address,uint16 appkey_index,uint16 vendor_id,uint8 reliable)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_health_client_clear.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_health_client_clear.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_health_client_clear.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_health_client_clear.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_health_client_clear.reliable=reliable;
    gecko_cmd_msg->header=(gecko_cmd_mesh_health_client_clear_id+(((9)&0xff)<<8)+(((9)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_health_client_clear;
}

/** 
*
* gecko_cmd_mesh_health_client_test
*
* Execute a self test on a server model or models in the network. 
*
* @param elem_index   Client model element index. Identifies the client model used for sending the
*  request.
* @param server_address   Destination server model address. May be a unicast address or a group address.
* @param appkey_index   The application key index to use in encrypting the request
* @param test_id   Test ID used in the request
* @param vendor_id   Bluetooth vendor ID used in the request
* @param reliable   If non-zero, a reliable model message is used.
*
**/

static inline struct gecko_msg_mesh_health_client_test_rsp_t* gecko_cmd_mesh_health_client_test(uint16 elem_index,uint16 server_address,uint16 appkey_index,uint8 test_id,uint16 vendor_id,uint8 reliable)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_health_client_test.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_health_client_test.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_health_client_test.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_health_client_test.test_id=test_id;
    gecko_cmd_msg->data.cmd_mesh_health_client_test.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_health_client_test.reliable=reliable;
    gecko_cmd_msg->header=(gecko_cmd_mesh_health_client_test_id+(((10)&0xff)<<8)+(((10)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_health_client_test;
}

/** 
*
* gecko_cmd_mesh_health_client_get_period
*
* Get the health period log of a Health Server model or models in the network.
* 
* Except for the immediate result code, the response or responses (if the
* destination server address is a group address) from the network will generate
* server status report events. 
*
* @param elem_index   Client model element index. Identifies the client model used for sending the
*  request.
* @param server_address   Destination server model address, which may be a unicast address or a group
*  address
* @param appkey_index   The application key index to use in encrypting the request
*
**/

static inline struct gecko_msg_mesh_health_client_get_period_rsp_t* gecko_cmd_mesh_health_client_get_period(uint16 elem_index,uint16 server_address,uint16 appkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_health_client_get_period.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_health_client_get_period.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_health_client_get_period.appkey_index=appkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_health_client_get_period_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_health_client_get_period;
}

/** 
*
* gecko_cmd_mesh_health_client_set_period
*
* Set the health period divisor of a Health Server model or models in the
* network.
* 
* Except for the immediate result code, the response or responses (if the
* destination server address is a group address) from the network will generate
* server status report events. 
*
* @param elem_index   Client model element index, which identifies the client model used for sending
*  the request.
* @param server_address   Destination server model address. May be a unicast address or a group address.
* @param appkey_index   The application key index to use in encrypting the request
* @param period   Health period divisor value
* @param reliable   If non-zero, a reliable model message is used.
*
**/

static inline struct gecko_msg_mesh_health_client_set_period_rsp_t* gecko_cmd_mesh_health_client_set_period(uint16 elem_index,uint16 server_address,uint16 appkey_index,uint8 period,uint8 reliable)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_health_client_set_period.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_health_client_set_period.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_health_client_set_period.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_health_client_set_period.period=period;
    gecko_cmd_msg->data.cmd_mesh_health_client_set_period.reliable=reliable;
    gecko_cmd_msg->header=(gecko_cmd_mesh_health_client_set_period_id+(((8)&0xff)<<8)+(((8)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_health_client_set_period;
}

/** 
*
* gecko_cmd_mesh_health_client_get_attention
*
* Get the attention timer value of a Health Server model or models in the
* network.
* 
* Besides the immediate result code, the response or responses (if the
* destination server address is a group address) from the network will generate
* server status report events. 
*
* @param elem_index   Client model element index. Identifies the client model used for sending the
*  request.
* @param server_address   Destination server model address. May be a unicast address or a group address.
* @param appkey_index   The application key index to use in encrypting the request
*
**/

static inline struct gecko_msg_mesh_health_client_get_attention_rsp_t* gecko_cmd_mesh_health_client_get_attention(uint16 elem_index,uint16 server_address,uint16 appkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_health_client_get_attention.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_health_client_get_attention.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_health_client_get_attention.appkey_index=appkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_health_client_get_attention_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_health_client_get_attention;
}

/** 
*
* gecko_cmd_mesh_health_client_set_attention
*
* Set the attention timer value of a Health Server model or models in the
* network.
* 
* Except for the immediate result code, the response or responses (if the
* destination server address is a group address) from the network will generate
* server status report events. 
*
* @param elem_index   Client model element index. Identifies the client model used for sending the
*  request.
* @param server_address   Destination server model address. May be a unicast address or a group address.
* @param appkey_index   The application key index to use in encrypting the request
* @param attention   Attention timer period in seconds
* @param reliable   If non-zero, a reliable model message is used.
*
**/

static inline struct gecko_msg_mesh_health_client_set_attention_rsp_t* gecko_cmd_mesh_health_client_set_attention(uint16 elem_index,uint16 server_address,uint16 appkey_index,uint8 attention,uint8 reliable)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_health_client_set_attention.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_health_client_set_attention.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_health_client_set_attention.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_health_client_set_attention.attention=attention;
    gecko_cmd_msg->data.cmd_mesh_health_client_set_attention.reliable=reliable;
    gecko_cmd_msg->header=(gecko_cmd_mesh_health_client_set_attention_id+(((8)&0xff)<<8)+(((8)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_health_client_set_attention;
}

/** 
*
* gecko_cmd_mesh_health_server_set_fault
*
* Set fault condition on an element. 
*
* @param elem_index   Index of the element on which the fault is occurring
* @param id   Fault ID. See the Mesh Profile specification for IDs defined by the Bluetooth
*  SIG.
*
**/

static inline struct gecko_msg_mesh_health_server_set_fault_rsp_t* gecko_cmd_mesh_health_server_set_fault(uint16 elem_index,uint8 id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_health_server_set_fault.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_health_server_set_fault.id=id;
    gecko_cmd_msg->header=(gecko_cmd_mesh_health_server_set_fault_id+(((3)&0xff)<<8)+(((3)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_health_server_set_fault;
}

/** 
*
* gecko_cmd_mesh_health_server_clear_fault
*
* Clear fault condition on an element. 
*
* @param elem_index   Index of the element on which the fault is no longer occurring.
* @param id   Fault ID. See the Mesh Profile specification for IDs defined by the Bluetooth
*  SIG.
*
**/

static inline struct gecko_msg_mesh_health_server_clear_fault_rsp_t* gecko_cmd_mesh_health_server_clear_fault(uint16 elem_index,uint8 id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_health_server_clear_fault.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_health_server_clear_fault.id=id;
    gecko_cmd_msg->header=(gecko_cmd_mesh_health_server_clear_fault_id+(((3)&0xff)<<8)+(((3)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_health_server_clear_fault;
}

/** 
*
* gecko_cmd_mesh_health_server_test_response
*
* Indicate to the stack that a test request has been completed and that the
* status may be communicated to the Health Client which made the test request. 
*
* @param elem_index   Server model element index. Identifies the Server model that received the
*  request as well as the element on which the test is to be performed.
* @param client_address   Address of the client model which sent the message
* @param appkey_index   The application key index to use in encrypting the request.
* @param vendor_id   Bluetooth vendor ID used in the request
*
**/

static inline struct gecko_msg_mesh_health_server_test_response_rsp_t* gecko_cmd_mesh_health_server_test_response(uint16 elem_index,uint16 client_address,uint16 appkey_index,uint16 vendor_id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_health_server_test_response.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_health_server_test_response.client_address=client_address;
    gecko_cmd_msg->data.cmd_mesh_health_server_test_response.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_health_server_test_response.vendor_id=vendor_id;
    gecko_cmd_msg->header=(gecko_cmd_mesh_health_server_test_response_id+(((8)&0xff)<<8)+(((8)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_health_server_test_response;
}

/** 
*
* gecko_cmd_mesh_generic_client_get
*
* Get the current state of a server model or models in the network. Besides the
* immediate result code, the response or responses from the network will
* generate server state report events for the replies received.
* 
* The server model responses will be reported in  server status events. 
*
* @param model_id   Client model ID
* @param elem_index   Client model element index
* @param server_address   Destination server model address
* @param appkey_index   The application key index to use
* @param type   Model-specific state type, identifying the kind of state to retrieve. See get
*  state types list for details.
*
* Events generated
*
* gecko_evt_mesh_generic_client_server_status - 
*
**/

static inline struct gecko_msg_mesh_generic_client_get_rsp_t* gecko_cmd_mesh_generic_client_get(uint16 model_id,uint16 elem_index,uint16 server_address,uint16 appkey_index,uint8 type)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_generic_client_get.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_generic_client_get.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_generic_client_get.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_generic_client_get.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_generic_client_get.type=type;
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_client_get_id+(((9)&0xff)<<8)+(((9)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_client_get;
}

/** 
*
* gecko_cmd_mesh_generic_client_set
*
* Set the current state of a server model or models in the network. Besides the
* immediate result code, the response or responses from the network will
* generate server state report events for the replies received.
* 
* The server model responses will be reported in  server status events. Note
* that for responses to be generated the corresponding flag needs to be set. 
*
* @param model_id   Client model ID
* @param elem_index   Client model element index
* @param server_address   Destination server model address
* @param appkey_index   The application key index to use
* @param tid   Transaction identifier. This applies to those messages the Mesh Model
*  specification defines as transactional and can be left as zero for others.
* @param transition   Transition time (in milliseconds) for the state change. If both the transition
*  time and the delay are zero the transition is immediate.
*  
*  This applies to messages the Mesh Model specification defines to have
*  transition and delay times and can be left as zero for others.
* @param delay   Delay time (in milliseconds) before starting the state change. If both the
*  transition time and the delay are zero the transition is immediate.
*  
*  This applies to messages the Mesh Model specification defines to have
*  transition and delay times and can be left as zero for others.
* @param flags   Message flags. Bitmask of the following:
*  
*      Bit 0: Response required. If non-zero client expects a response from the server
*      Bit 1: Default transition timer. If non-zero client requests that server uses its default transition timer and the supplied transition and delay values are ignored.
* @param type   Model-specific request type. See set request types list for details.
* @param parameters_len   Array length
* @param parameters_data   Message-specific set request parameters serialized into a byte array
*
* Events generated
*
* gecko_evt_mesh_generic_client_server_status - 
*
**/

static inline struct gecko_msg_mesh_generic_client_set_rsp_t* gecko_cmd_mesh_generic_client_set(uint16 model_id,uint16 elem_index,uint16 server_address,uint16 appkey_index,uint8 tid,uint32 transition,uint16 delay,uint16 flags,uint8 type,uint8 parameters_len, const uint8* parameters_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)parameters_len > 256 - 19)
    {
        gecko_rsp_msg->data.rsp_mesh_generic_client_set.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_generic_client_set;
    }

    
    gecko_cmd_msg->data.cmd_mesh_generic_client_set.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_generic_client_set.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_generic_client_set.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_generic_client_set.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_generic_client_set.tid=tid;
    gecko_cmd_msg->data.cmd_mesh_generic_client_set.transition=transition;
    gecko_cmd_msg->data.cmd_mesh_generic_client_set.delay=delay;
    gecko_cmd_msg->data.cmd_mesh_generic_client_set.flags=flags;
    gecko_cmd_msg->data.cmd_mesh_generic_client_set.type=type;
    gecko_cmd_msg->data.cmd_mesh_generic_client_set.parameters.len=parameters_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_generic_client_set.parameters.data,parameters_data,parameters_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_client_set_id+(((19+parameters_len)&0xff)<<8)+(((19+parameters_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_client_set;
}

/** 
*
* gecko_cmd_mesh_generic_client_publish
*
* Publish a set request to the network using the publish address and publish
* application key of the model. The message will be received by the server
* models which subscribe to the publish address, and there's no need to
* explicitly specify a destination address or application key.
* 
* The server model responses will be reported in  server status events. Note
* that for responses to be generated the corresponding flag needs to be set. 
*
* @param model_id   Client model ID
* @param elem_index   Client model element index
* @param tid   Transaction identifier
* @param transition   Transition time (in milliseconds) for the state change. If both the transition
*  time and the delay are zero the transition is immediate.
*  
*  This applies to messages the Mesh Model specification defines to have
*  transition and delay times and can be left as zero for others.
* @param delay   Delay time (in milliseconds) before starting the state change. If both the
*  transition time and the delay are zero the transition is immediate.
*  
*  This applies to messages the Mesh Model specification defines to have
*  transition and delay times, and can be left as zero for others.
* @param flags   Message flags. Bitmask of the following:
*  
*      Bit 0: Response required. If non-zero client expects a response from the server
*      Bit 1: Default transition timer. If non-zero client requests that server uses its default transition timer and the supplied transition and delay values are ignored.
* @param type   Model-specific request type. See set request types list for details.
* @param parameters_len   Array length
* @param parameters_data   Message-specific set request parameters serialized into a byte array
*
* Events generated
*
* gecko_evt_mesh_generic_client_server_status - 
*
**/

static inline struct gecko_msg_mesh_generic_client_publish_rsp_t* gecko_cmd_mesh_generic_client_publish(uint16 model_id,uint16 elem_index,uint8 tid,uint32 transition,uint16 delay,uint16 flags,uint8 type,uint8 parameters_len, const uint8* parameters_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)parameters_len > 256 - 15)
    {
        gecko_rsp_msg->data.rsp_mesh_generic_client_publish.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_generic_client_publish;
    }

    
    gecko_cmd_msg->data.cmd_mesh_generic_client_publish.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_generic_client_publish.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_generic_client_publish.tid=tid;
    gecko_cmd_msg->data.cmd_mesh_generic_client_publish.transition=transition;
    gecko_cmd_msg->data.cmd_mesh_generic_client_publish.delay=delay;
    gecko_cmd_msg->data.cmd_mesh_generic_client_publish.flags=flags;
    gecko_cmd_msg->data.cmd_mesh_generic_client_publish.type=type;
    gecko_cmd_msg->data.cmd_mesh_generic_client_publish.parameters.len=parameters_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_generic_client_publish.parameters.data,parameters_data,parameters_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_client_publish_id+(((15+parameters_len)&0xff)<<8)+(((15+parameters_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_client_publish;
}

/** 
*
* gecko_cmd_mesh_generic_client_get_params
*
* Get the current state of a server model or models in the network, with
* additional parameters detailing the request. Besides the immediate result
* code, the response or responses from the network will generate server state
* report events for the replies received.
* 
* The server model responses will be reported in  server status events.
* 
* This call is used to query properties, for which the property ID is given as a
* parameter. 
*
* @param model_id   Client model ID
* @param elem_index   Client model element index
* @param server_address   Destination server model address
* @param appkey_index   The application key index to use.
* @param type   Model-specific state type, identifying the kind of state to retrieve. See get
*  state types list for details.
* @param parameters_len   Array length
* @param parameters_data   Message-specific get request parameters serialized into a byte array
*
* Events generated
*
* gecko_evt_mesh_generic_client_server_status - 
*
**/

static inline struct gecko_msg_mesh_generic_client_get_params_rsp_t* gecko_cmd_mesh_generic_client_get_params(uint16 model_id,uint16 elem_index,uint16 server_address,uint16 appkey_index,uint8 type,uint8 parameters_len, const uint8* parameters_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)parameters_len > 256 - 10)
    {
        gecko_rsp_msg->data.rsp_mesh_generic_client_get_params.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_generic_client_get_params;
    }

    
    gecko_cmd_msg->data.cmd_mesh_generic_client_get_params.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_generic_client_get_params.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_generic_client_get_params.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_generic_client_get_params.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_generic_client_get_params.type=type;
    gecko_cmd_msg->data.cmd_mesh_generic_client_get_params.parameters.len=parameters_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_generic_client_get_params.parameters.data,parameters_data,parameters_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_client_get_params_id+(((10+parameters_len)&0xff)<<8)+(((10+parameters_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_client_get_params;
}

/** 
*
* gecko_cmd_mesh_generic_client_init
*
* Initialize generic client models. This command initializes all generic client
* models on the device. Alternatively, only the necessary client models can be
* initialized using model-specific initialization commands. Using model-specific
* initialization can result in a smaller firmware image size for SoC projects. 
*
*
**/

static inline struct gecko_msg_mesh_generic_client_init_rsp_t* gecko_cmd_mesh_generic_client_init()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_client_init_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_client_init;
}

/** 
*
* gecko_cmd_mesh_generic_client_init_common
*
* Initialize generic client model common functionality. This should be called
* after all model-specific initialization calls are done, and does not need to
* be called if command to initialize all generic client models is used. 
*
*
**/

static inline struct gecko_msg_mesh_generic_client_init_common_rsp_t* gecko_cmd_mesh_generic_client_init_common()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_client_init_common_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_client_init_common;
}

/** 
*
* gecko_cmd_mesh_generic_client_init_on_off
*
* Initialize generic on/off client models 
*
*
**/

static inline struct gecko_msg_mesh_generic_client_init_on_off_rsp_t* gecko_cmd_mesh_generic_client_init_on_off()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_client_init_on_off_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_client_init_on_off;
}

/** 
*
* gecko_cmd_mesh_generic_client_init_level
*
* Initialize generic level client models 
*
*
**/

static inline struct gecko_msg_mesh_generic_client_init_level_rsp_t* gecko_cmd_mesh_generic_client_init_level()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_client_init_level_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_client_init_level;
}

/** 
*
* gecko_cmd_mesh_generic_client_init_default_transition_time
*
* Initialize generic default transition time client models 
*
*
**/

static inline struct gecko_msg_mesh_generic_client_init_default_transition_time_rsp_t* gecko_cmd_mesh_generic_client_init_default_transition_time()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_client_init_default_transition_time_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_client_init_default_transition_time;
}

/** 
*
* gecko_cmd_mesh_generic_client_init_power_on_off
*
* Initialize generic power on/off client models 
*
*
**/

static inline struct gecko_msg_mesh_generic_client_init_power_on_off_rsp_t* gecko_cmd_mesh_generic_client_init_power_on_off()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_client_init_power_on_off_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_client_init_power_on_off;
}

/** 
*
* gecko_cmd_mesh_generic_client_init_power_level
*
* Initialize generic power level client models 
*
*
**/

static inline struct gecko_msg_mesh_generic_client_init_power_level_rsp_t* gecko_cmd_mesh_generic_client_init_power_level()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_client_init_power_level_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_client_init_power_level;
}

/** 
*
* gecko_cmd_mesh_generic_client_init_battery
*
* Initialize generic battery client models 
*
*
**/

static inline struct gecko_msg_mesh_generic_client_init_battery_rsp_t* gecko_cmd_mesh_generic_client_init_battery()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_client_init_battery_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_client_init_battery;
}

/** 
*
* gecko_cmd_mesh_generic_client_init_location
*
* Initialize generic location client models 
*
*
**/

static inline struct gecko_msg_mesh_generic_client_init_location_rsp_t* gecko_cmd_mesh_generic_client_init_location()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_client_init_location_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_client_init_location;
}

/** 
*
* gecko_cmd_mesh_generic_client_init_property
*
* Initialize generic property client models 
*
*
**/

static inline struct gecko_msg_mesh_generic_client_init_property_rsp_t* gecko_cmd_mesh_generic_client_init_property()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_client_init_property_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_client_init_property;
}

/** 
*
* gecko_cmd_mesh_generic_client_init_lightness
*
* Initialize light lightness client models 
*
*
**/

static inline struct gecko_msg_mesh_generic_client_init_lightness_rsp_t* gecko_cmd_mesh_generic_client_init_lightness()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_client_init_lightness_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_client_init_lightness;
}

/** 
*
* gecko_cmd_mesh_generic_client_init_ctl
*
* Initialize light CTL client models 
*
*
**/

static inline struct gecko_msg_mesh_generic_client_init_ctl_rsp_t* gecko_cmd_mesh_generic_client_init_ctl()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_client_init_ctl_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_client_init_ctl;
}

/** 
*
* gecko_cmd_mesh_generic_server_response
*
* Server response to a client request. This command must be used when an
* application updates the server model state as a response to a  client request
* event which required a response. 
*
* @param model_id   Server model ID
* @param elem_index   Server model element index
* @param client_address   Address of the client model which sent the message
* @param appkey_index   The application key index used
* @param remaining   Time (in milliseconds) remaining before transition from current state to
*  target state is complete. Set to zero if no transition is taking place or if
*  the transition time does not apply to the state change.
* @param flags   Message flags. Bitmask of the following:
*  
*      Bit 0: Non-relayed. If non-zero, indicates a response to a non-relayed request.
* @param type   Model-specific state type, identifying the kind of state to be updated. See
*  get state types list for details.
* @param parameters_len   Array length
* @param parameters_data   Message-specific parameters serialized into a byte array
*
**/

static inline struct gecko_msg_mesh_generic_server_response_rsp_t* gecko_cmd_mesh_generic_server_response(uint16 model_id,uint16 elem_index,uint16 client_address,uint16 appkey_index,uint32 remaining,uint16 flags,uint8 type,uint8 parameters_len, const uint8* parameters_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)parameters_len > 256 - 16)
    {
        gecko_rsp_msg->data.rsp_mesh_generic_server_response.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_generic_server_response;
    }

    
    gecko_cmd_msg->data.cmd_mesh_generic_server_response.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_generic_server_response.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_generic_server_response.client_address=client_address;
    gecko_cmd_msg->data.cmd_mesh_generic_server_response.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_generic_server_response.remaining=remaining;
    gecko_cmd_msg->data.cmd_mesh_generic_server_response.flags=flags;
    gecko_cmd_msg->data.cmd_mesh_generic_server_response.type=type;
    gecko_cmd_msg->data.cmd_mesh_generic_server_response.parameters.len=parameters_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_generic_server_response.parameters.data,parameters_data,parameters_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_server_response_id+(((16+parameters_len)&0xff)<<8)+(((16+parameters_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_server_response;
}

/** 
*
* gecko_cmd_mesh_generic_server_update
*
* Server state update. This command must be used when an application updates the
* server model state as a response to a  client request event which did not
* require a response, but also when the application state changes spontaneously
* or as a result of some external (non-Mesh) event. 
*
* @param model_id   Server model ID
* @param elem_index   Server model element index
* @param remaining   Time (in milliseconds) remaining before transition from current state to
*  target state is complete. Set to zero if no transition is taking place or if
*  transition time does not apply to the state change.
* @param type   Model-specific state type, identifying the kind of state to be updated. See
*  get state types list for details.
* @param parameters_len   Array length
* @param parameters_data   Message-specific parameters, serialized into a byte array
*
**/

static inline struct gecko_msg_mesh_generic_server_update_rsp_t* gecko_cmd_mesh_generic_server_update(uint16 model_id,uint16 elem_index,uint32 remaining,uint8 type,uint8 parameters_len, const uint8* parameters_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)parameters_len > 256 - 10)
    {
        gecko_rsp_msg->data.rsp_mesh_generic_server_update.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_generic_server_update;
    }

    
    gecko_cmd_msg->data.cmd_mesh_generic_server_update.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_generic_server_update.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_generic_server_update.remaining=remaining;
    gecko_cmd_msg->data.cmd_mesh_generic_server_update.type=type;
    gecko_cmd_msg->data.cmd_mesh_generic_server_update.parameters.len=parameters_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_generic_server_update.parameters.data,parameters_data,parameters_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_server_update_id+(((10+parameters_len)&0xff)<<8)+(((10+parameters_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_server_update;
}

/** 
*
* gecko_cmd_mesh_generic_server_publish
*
* Publish server state into the network using the publish parameters configured
* into the model. The message is constructed using the cached state in the
* stack. 
*
* @param model_id   Server model ID
* @param elem_index   Server model element index
* @param type   Model-specific state type, identifying the kind of state used in the published
*  message. See get state types list for details.
*
**/

static inline struct gecko_msg_mesh_generic_server_publish_rsp_t* gecko_cmd_mesh_generic_server_publish(uint16 model_id,uint16 elem_index,uint8 type)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_generic_server_publish.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_generic_server_publish.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_generic_server_publish.type=type;
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_server_publish_id+(((5)&0xff)<<8)+(((5)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_server_publish;
}

/** 
*
* gecko_cmd_mesh_generic_server_init
*
* Initialize generic server models. This command initializes all generic server
* models on the device. Alternatively, only the necessary server models can be
* initialized using model-specific initialization commands. Using model-specific
* initialization can result in a smaller firmware image size for SoC projects. 
*
*
**/

static inline struct gecko_msg_mesh_generic_server_init_rsp_t* gecko_cmd_mesh_generic_server_init()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_server_init_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_server_init;
}

/** 
*
* gecko_cmd_mesh_generic_server_init_common
*
* Initialize generic server model common functionality. This should be called
* after all model-specific initialization calls are done, and does not need to
* be called if command to initialize all generic server models is used. 
*
*
**/

static inline struct gecko_msg_mesh_generic_server_init_common_rsp_t* gecko_cmd_mesh_generic_server_init_common()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_server_init_common_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_server_init_common;
}

/** 
*
* gecko_cmd_mesh_generic_server_init_on_off
*
* Initialize generic on/off server models 
*
*
**/

static inline struct gecko_msg_mesh_generic_server_init_on_off_rsp_t* gecko_cmd_mesh_generic_server_init_on_off()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_server_init_on_off_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_server_init_on_off;
}

/** 
*
* gecko_cmd_mesh_generic_server_init_level
*
* Initialize generic level server models 
*
*
**/

static inline struct gecko_msg_mesh_generic_server_init_level_rsp_t* gecko_cmd_mesh_generic_server_init_level()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_server_init_level_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_server_init_level;
}

/** 
*
* gecko_cmd_mesh_generic_server_init_default_transition_time
*
* Initialize generic default transition time server models 
*
*
**/

static inline struct gecko_msg_mesh_generic_server_init_default_transition_time_rsp_t* gecko_cmd_mesh_generic_server_init_default_transition_time()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_server_init_default_transition_time_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_server_init_default_transition_time;
}

/** 
*
* gecko_cmd_mesh_generic_server_init_power_on_off
*
* Initialize generic power on/off server models, power on/off setup server
* models, and all models they extend 
*
*
**/

static inline struct gecko_msg_mesh_generic_server_init_power_on_off_rsp_t* gecko_cmd_mesh_generic_server_init_power_on_off()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_server_init_power_on_off_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_server_init_power_on_off;
}

/** 
*
* gecko_cmd_mesh_generic_server_init_power_level
*
* Initialize generic power level server models, power level setup server models,
* and all models they extend 
*
*
**/

static inline struct gecko_msg_mesh_generic_server_init_power_level_rsp_t* gecko_cmd_mesh_generic_server_init_power_level()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_server_init_power_level_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_server_init_power_level;
}

/** 
*
* gecko_cmd_mesh_generic_server_init_battery
*
* Initialize generic battery server models 
*
*
**/

static inline struct gecko_msg_mesh_generic_server_init_battery_rsp_t* gecko_cmd_mesh_generic_server_init_battery()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_server_init_battery_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_server_init_battery;
}

/** 
*
* gecko_cmd_mesh_generic_server_init_location
*
* Initialize generic location and generic location setup server models 
*
*
**/

static inline struct gecko_msg_mesh_generic_server_init_location_rsp_t* gecko_cmd_mesh_generic_server_init_location()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_server_init_location_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_server_init_location;
}

/** 
*
* gecko_cmd_mesh_generic_server_init_property
*
* Initialize generic property server models 
*
*
**/

static inline struct gecko_msg_mesh_generic_server_init_property_rsp_t* gecko_cmd_mesh_generic_server_init_property()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_server_init_property_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_server_init_property;
}

/** 
*
* gecko_cmd_mesh_generic_server_init_lightness
*
* Initialize light lightness server models, light lightness setup server models,
* and all models they extend 
*
*
**/

static inline struct gecko_msg_mesh_generic_server_init_lightness_rsp_t* gecko_cmd_mesh_generic_server_init_lightness()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_server_init_lightness_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_server_init_lightness;
}

/** 
*
* gecko_cmd_mesh_generic_server_init_ctl
*
* Initialize light CTL server models, light CTL temperature server models, light
* CTL setup server models, and all models they extend 
*
*
**/

static inline struct gecko_msg_mesh_generic_server_init_ctl_rsp_t* gecko_cmd_mesh_generic_server_init_ctl()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_generic_server_init_ctl_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_generic_server_init_ctl;
}

/** 
*
* gecko_cmd_coex_set_options
*
* Configure coexistence options at runtime. 
*
* @param mask   Mask defines which coexistence options are changed.
* @param options   Value of options to be changed. This parameter is used together with the mask
*  parameter.
*
**/

static inline struct gecko_msg_coex_set_options_rsp_t* gecko_cmd_coex_set_options(uint32 mask,uint32 options)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_coex_set_options.mask=mask;
    gecko_cmd_msg->data.cmd_coex_set_options.options=options;
    gecko_cmd_msg->header=(gecko_cmd_coex_set_options_id+(((8)&0xff)<<8)+(((8)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_coex_set_options;
}

/** 
*
* gecko_cmd_coex_get_counters
*
* Read coexistence statistic counters from the device. Response contains the
* list of uint32 type counter values. Counters in the list are in following
* order: low priority requested, high priority requested, low priority denied,
* high priority denied, low-priority TX aborted, and high-priority TX aborted.
* Passing a non-zero value also resets counters. 
*
* @param reset   Reset counters if parameter value is not zero.
*
**/

static inline struct gecko_msg_coex_get_counters_rsp_t* gecko_cmd_coex_get_counters(uint8 reset)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_coex_get_counters.reset=reset;
    gecko_cmd_msg->header=(gecko_cmd_coex_get_counters_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_coex_get_counters;
}

/** 
*
* gecko_cmd_coex_set_parameters
*
* Configure coexistence parameters. 
*
* @param priority   Coexistence priority threshold. Coexistence priority is toggled if priority is
*  below this value.
* @param request   Coexistence request threshold. Coexistence request is toggled if priority is
*  below this value.
* @param pwm_period   PWM functionality period length in 1ms units
* @param pwm_dutycycle   PWM functionality dutycycle in percentage
*
**/

static inline struct gecko_msg_coex_set_parameters_rsp_t* gecko_cmd_coex_set_parameters(uint8 priority,uint8 request,uint8 pwm_period,uint8 pwm_dutycycle)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_coex_set_parameters.priority=priority;
    gecko_cmd_msg->data.cmd_coex_set_parameters.request=request;
    gecko_cmd_msg->data.cmd_coex_set_parameters.pwm_period=pwm_period;
    gecko_cmd_msg->data.cmd_coex_set_parameters.pwm_dutycycle=pwm_dutycycle;
    gecko_cmd_msg->header=(gecko_cmd_coex_set_parameters_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_coex_set_parameters;
}

/** 
*
* gecko_cmd_coex_set_directional_priority_pulse
*
* Set Directional Priority Pulse Width 
*
* @param pulse   Directional priority pulse width in us
*
**/

static inline struct gecko_msg_coex_set_directional_priority_pulse_rsp_t* gecko_cmd_coex_set_directional_priority_pulse(uint8 pulse)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_coex_set_directional_priority_pulse.pulse=pulse;
    gecko_cmd_msg->header=(gecko_cmd_coex_set_directional_priority_pulse_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_coex_set_directional_priority_pulse;
}

/** 
*
* gecko_cmd_mesh_test_get_nettx
*
* Get the network transmit state of a node. 
*
*
**/

static inline struct gecko_msg_mesh_test_get_nettx_rsp_t* gecko_cmd_mesh_test_get_nettx()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_get_nettx_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_get_nettx;
}

/** 
*
* gecko_cmd_mesh_test_set_nettx
*
* Set the network transmit state of a node locally. Normally, the network
* transmit state is controlled by the Provisioner. This command overrides any
* setting done by the Provisioner. 
*
* @param count   Number of network layer transmissions beyond the initial one. Range: 0-7.
* @param interval   Transmit interval steps. The interval between transmissions is a random value
*  between 10*(1+steps) and 10*(2+steps) milliseconds. For example, for a value
*  of 2 the interval would be between 30 and 40 milliseconds. Range: 0-31.
*
**/

static inline struct gecko_msg_mesh_test_set_nettx_rsp_t* gecko_cmd_mesh_test_set_nettx(uint8 count,uint8 interval)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_test_set_nettx.count=count;
    gecko_cmd_msg->data.cmd_mesh_test_set_nettx.interval=interval;
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_set_nettx_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_set_nettx;
}

/** 
*
* gecko_cmd_mesh_test_get_relay
*
*  
*
*
**/

static inline struct gecko_msg_mesh_test_get_relay_rsp_t* gecko_cmd_mesh_test_get_relay()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_get_relay_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_get_relay;
}

/** 
*
* gecko_cmd_mesh_test_set_relay
*
* Set the relay state and the relay retransmit state of a node locally.
* Normally, these states are controlled by the Provisioner. This command
* overrides any settings done by the Provisioner. 
*
* @param enabled   Indicates whether the relay functionality is enabled on the node (1) or not
*  (0); value indicating disabled (2) can't be set.
* @param count   Number of relay transmissions beyond the initial one. Range: 0-7.
* @param interval   Relay retransmit interval steps. The interval between transmissions is
*  10*(1+steps) milliseconds. Range: 0-31.
*
**/

static inline struct gecko_msg_mesh_test_set_relay_rsp_t* gecko_cmd_mesh_test_set_relay(uint8 enabled,uint8 count,uint8 interval)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_test_set_relay.enabled=enabled;
    gecko_cmd_msg->data.cmd_mesh_test_set_relay.count=count;
    gecko_cmd_msg->data.cmd_mesh_test_set_relay.interval=interval;
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_set_relay_id+(((3)&0xff)<<8)+(((3)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_set_relay;
}

/** 
*
* gecko_cmd_mesh_test_set_adv_scan_params
*
* Set non-default advertisement and scanning parameters used in mesh
* communications. Call this command before node initialization or Provisioner
* initialization for the settings to take effect. 
*
* @param adv_interval_min   Minimum advertisement interval. Value is in units of 0.625 ms. Default value
*  is 1 (0.625 ms).
* @param adv_interval_max   Maximum advertisement interval. Value is in units of 0.625 ms. Must be equal
*  to or greater than the minimum interval. Default value is 32 (20 ms).
* @param adv_repeat_packets   Number of times to repeat each packet on all selected advertisement channels.
*  Range: 1-5. Default value is 1.
* @param adv_use_random_address   Bluetooth address type. Range: 0: use public address, 1: use random address.
*  Default value: 0 (public address).
* @param adv_channel_map   Advertisement channel selection bitmask. Range: 0x1-0x7. Default value: 7 (all
*  channels)
* @param scan_interval   Scan interval. Value is in units of 0.625 ms. Range: 0x0004 to 0x4000 (time
*  range of 2.5 ms to 10.24 s). Default value is 160 (100 ms).
* @param scan_window   Scan window. Value is in units of 0.625 ms. Must be equal to or less than the
*  scan interval.
*
**/

static inline struct gecko_msg_mesh_test_set_adv_scan_params_rsp_t* gecko_cmd_mesh_test_set_adv_scan_params(uint16 adv_interval_min,uint16 adv_interval_max,uint8 adv_repeat_packets,uint8 adv_use_random_address,uint8 adv_channel_map,uint16 scan_interval,uint16 scan_window)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_test_set_adv_scan_params.adv_interval_min=adv_interval_min;
    gecko_cmd_msg->data.cmd_mesh_test_set_adv_scan_params.adv_interval_max=adv_interval_max;
    gecko_cmd_msg->data.cmd_mesh_test_set_adv_scan_params.adv_repeat_packets=adv_repeat_packets;
    gecko_cmd_msg->data.cmd_mesh_test_set_adv_scan_params.adv_use_random_address=adv_use_random_address;
    gecko_cmd_msg->data.cmd_mesh_test_set_adv_scan_params.adv_channel_map=adv_channel_map;
    gecko_cmd_msg->data.cmd_mesh_test_set_adv_scan_params.scan_interval=scan_interval;
    gecko_cmd_msg->data.cmd_mesh_test_set_adv_scan_params.scan_window=scan_window;
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_set_adv_scan_params_id+(((11)&0xff)<<8)+(((11)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_set_adv_scan_params;
}

/** 
*
* gecko_cmd_mesh_test_set_ivupdate_test_mode
*
* By default, IV index update is limited in how often the update procedure can
* be performed. This test command can be called to set IV update test mode where
* any time limits are ignored. 
*
* @param mode   Whether test mode is enabled (1) or disabled (0).
*
**/

static inline struct gecko_msg_mesh_test_set_ivupdate_test_mode_rsp_t* gecko_cmd_mesh_test_set_ivupdate_test_mode(uint8 mode)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_test_set_ivupdate_test_mode.mode=mode;
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_set_ivupdate_test_mode_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_set_ivupdate_test_mode;
}

/** 
*
* gecko_cmd_mesh_test_get_ivupdate_test_mode
*
* Get the current IV update test mode. See set IV update test mode for details. 
*
*
**/

static inline struct gecko_msg_mesh_test_get_ivupdate_test_mode_rsp_t* gecko_cmd_mesh_test_get_ivupdate_test_mode()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_get_ivupdate_test_mode_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_get_ivupdate_test_mode;
}

/** 
*
* gecko_cmd_mesh_test_set_segment_send_delay
*
* Set delay in milliseconds between sending consecutive segments of a segmented
* message. The default value is 0. Note that this command needs to be called
* before node initialization or Provisioner initialization for the settings to
* take effect. 
*
* @param delay   Number of milliseconds to delay each segment after the first
*
**/

static inline struct gecko_msg_mesh_test_set_segment_send_delay_rsp_t* gecko_cmd_mesh_test_set_segment_send_delay(uint8 delay)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_test_set_segment_send_delay.delay=delay;
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_set_segment_send_delay_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_set_segment_send_delay;
}

/** 
*
* gecko_cmd_mesh_test_set_ivupdate_state
*
* Forcefully change the IV update state on the device. Normally, the state
* changes as a result of an IV index update procedure progressing from one state
* to the next. 
*
* @param state   Whether IV update state should be entered (1) or exited (0).
*
**/

static inline struct gecko_msg_mesh_test_set_ivupdate_state_rsp_t* gecko_cmd_mesh_test_set_ivupdate_state(uint8 state)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_test_set_ivupdate_state.state=state;
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_set_ivupdate_state_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_set_ivupdate_state;
}

/** 
*
* gecko_cmd_mesh_test_send_beacons
*
* Send secure network beacons for every network key on the device, regardless of
* beacon configuration state or how many beacons sent by other devices have been
* observed. 
*
*
**/

static inline struct gecko_msg_mesh_test_send_beacons_rsp_t* gecko_cmd_mesh_test_send_beacons()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_send_beacons_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_send_beacons;
}

/** 
*
* gecko_cmd_mesh_test_bind_local_model_app
*
* Bind a Model to an Appkey locally. 
*
* @param elem_index   The index of the target Element, 0 is primary element
* @param appkey_index   The Appkey to use for binding
* @param vendor_id   Vendor ID for vendor-specific models. Use 0xffff for SIG models.
* @param model_id   Model ID
*
**/

static inline struct gecko_msg_mesh_test_bind_local_model_app_rsp_t* gecko_cmd_mesh_test_bind_local_model_app(uint16 elem_index,uint16 appkey_index,uint16 vendor_id,uint16 model_id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_test_bind_local_model_app.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_test_bind_local_model_app.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_test_bind_local_model_app.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_test_bind_local_model_app.model_id=model_id;
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_bind_local_model_app_id+(((8)&0xff)<<8)+(((8)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_bind_local_model_app;
}

/** 
*
* gecko_cmd_mesh_test_unbind_local_model_app
*
* Remove a binding between a model and an application key locally. 
*
* @param elem_index   The index of the target element, 0 is primary element
* @param appkey_index   The Appkey to use for binding
* @param vendor_id   Vendor ID for vendor-specific models. Use 0xffff for SIG models.
* @param model_id   Model ID
*
**/

static inline struct gecko_msg_mesh_test_unbind_local_model_app_rsp_t* gecko_cmd_mesh_test_unbind_local_model_app(uint16 elem_index,uint16 appkey_index,uint16 vendor_id,uint16 model_id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_test_unbind_local_model_app.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_test_unbind_local_model_app.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_test_unbind_local_model_app.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_test_unbind_local_model_app.model_id=model_id;
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_unbind_local_model_app_id+(((8)&0xff)<<8)+(((8)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_unbind_local_model_app;
}

/** 
*
* gecko_cmd_mesh_test_add_local_model_sub
*
* Add an address to a local model's subscription list. 
*
* @param elem_index   The index of the target element, 0 is the primary element
* @param vendor_id   Vendor ID for vendor-specific models. Use 0xffff for Bluetooth SIG models.
* @param model_id   Model ID
* @param sub_address   The address to add to the subscription list
*
**/

static inline struct gecko_msg_mesh_test_add_local_model_sub_rsp_t* gecko_cmd_mesh_test_add_local_model_sub(uint16 elem_index,uint16 vendor_id,uint16 model_id,uint16 sub_address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_test_add_local_model_sub.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_test_add_local_model_sub.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_test_add_local_model_sub.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_test_add_local_model_sub.sub_address=sub_address;
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_add_local_model_sub_id+(((8)&0xff)<<8)+(((8)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_add_local_model_sub;
}

/** 
*
* gecko_cmd_mesh_test_del_local_model_sub
*
* Remove an address from a local model's subscription list. 
*
* @param elem_index   The index of the target element, 0 is the primary element
* @param vendor_id   Vendor ID for vendor-specific models. Use 0xffff for Bluetooth SIG models.
* @param model_id   Model ID
* @param sub_address   The address to remove from the subscription list
*
**/

static inline struct gecko_msg_mesh_test_del_local_model_sub_rsp_t* gecko_cmd_mesh_test_del_local_model_sub(uint16 elem_index,uint16 vendor_id,uint16 model_id,uint16 sub_address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_test_del_local_model_sub.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_test_del_local_model_sub.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_test_del_local_model_sub.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_test_del_local_model_sub.sub_address=sub_address;
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_del_local_model_sub_id+(((8)&0xff)<<8)+(((8)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_del_local_model_sub;
}

/** 
*
* gecko_cmd_mesh_test_add_local_model_sub_va
*
* Add a virtual address to a local model's subscription list. 
*
* @param elem_index   The index of the target element, 0 is the primary element
* @param vendor_id   Vendor ID for vendor-specific models. Use 0xffff for Bluetooth SIG models.
* @param model_id   Model ID
* @param sub_address_len   Array length
* @param sub_address_data   The Label UUID to add to the subscription list. The array must be exactly 16
*  bytes long.
*
**/

static inline struct gecko_msg_mesh_test_add_local_model_sub_va_rsp_t* gecko_cmd_mesh_test_add_local_model_sub_va(uint16 elem_index,uint16 vendor_id,uint16 model_id,uint8 sub_address_len, const uint8* sub_address_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)sub_address_len > 256 - 7)
    {
        gecko_rsp_msg->data.rsp_mesh_test_add_local_model_sub_va.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_test_add_local_model_sub_va;
    }

    
    gecko_cmd_msg->data.cmd_mesh_test_add_local_model_sub_va.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_test_add_local_model_sub_va.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_test_add_local_model_sub_va.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_test_add_local_model_sub_va.sub_address.len=sub_address_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_test_add_local_model_sub_va.sub_address.data,sub_address_data,sub_address_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_add_local_model_sub_va_id+(((7+sub_address_len)&0xff)<<8)+(((7+sub_address_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_add_local_model_sub_va;
}

/** 
*
* gecko_cmd_mesh_test_del_local_model_sub_va
*
* Remove a virtual address from a local model's subscription list. 
*
* @param elem_index   The index of the target element, 0 is the primary element
* @param vendor_id   Vendor ID for vendor-specific models. Use 0xffff for Bluetooth SIG models.
* @param model_id   Model ID
* @param sub_address_len   Array length
* @param sub_address_data   The Label UUID to remove from the subscription list. The array must be exactly
*  16 bytes long.
*
**/

static inline struct gecko_msg_mesh_test_del_local_model_sub_va_rsp_t* gecko_cmd_mesh_test_del_local_model_sub_va(uint16 elem_index,uint16 vendor_id,uint16 model_id,uint8 sub_address_len, const uint8* sub_address_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)sub_address_len > 256 - 7)
    {
        gecko_rsp_msg->data.rsp_mesh_test_del_local_model_sub_va.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_test_del_local_model_sub_va;
    }

    
    gecko_cmd_msg->data.cmd_mesh_test_del_local_model_sub_va.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_test_del_local_model_sub_va.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_test_del_local_model_sub_va.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_test_del_local_model_sub_va.sub_address.len=sub_address_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_test_del_local_model_sub_va.sub_address.data,sub_address_data,sub_address_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_del_local_model_sub_va_id+(((7+sub_address_len)&0xff)<<8)+(((7+sub_address_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_del_local_model_sub_va;
}

/** 
*
* gecko_cmd_mesh_test_get_local_model_sub
*
* Get all entries in a local model's subscription list. 
*
* @param elem_index   The index of the target element, 0 is the primary element
* @param vendor_id   Vendor ID for vendor-specific models. Use 0xffff for Bluetooth SIG models.
* @param model_id   Model ID
*
**/

static inline struct gecko_msg_mesh_test_get_local_model_sub_rsp_t* gecko_cmd_mesh_test_get_local_model_sub(uint16 elem_index,uint16 vendor_id,uint16 model_id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_test_get_local_model_sub.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_test_get_local_model_sub.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_test_get_local_model_sub.model_id=model_id;
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_get_local_model_sub_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_get_local_model_sub;
}

/** 
*
* gecko_cmd_mesh_test_set_local_model_pub
*
* Set a local model's publication address, key, and parameters. 
*
* @param elem_index   The index of the target element, 0 is the primary element
* @param appkey_index   The application key index to use for the application messages published
* @param vendor_id   Vendor ID for vendor-specific models. Use 0xffff for Bluetooth SIG models.
* @param model_id   Model ID
* @param pub_address   The address to publish to
* @param ttl   Time-to-Live value for published messages
* @param period   Publication period encoded as step count and step resolution. The encoding is
*  as follows:
*  
*      Bits 0..5: Step count
*      Bits 6..7: Step resolution: 
*      * 00: 100 milliseconds
*      * 01: 1 second
*      * 10: 10 seconds
*      * 11: 10 minutes
* @param retrans   Retransmission count and interval, which controls number of times that the
*  model re-publishes the same message after the initial publish transmission and
*  the cadence of retransmissions.
*  
*  Retransmission count is encoded in the three low bits of the value, ranging
*  from 0 to 7. Default value is 0 (no retransmissions).
*  
*  Retransmission interval is encoded in the five high bits of the value, ranging
*  from 0 to 31, in 50-millisecond units. Value of 0 corresponds to 50 ms, while
*  value of 31 corresponds to 1600 ms.
* @param credentials   Friendship credentials flag
*
**/

static inline struct gecko_msg_mesh_test_set_local_model_pub_rsp_t* gecko_cmd_mesh_test_set_local_model_pub(uint16 elem_index,uint16 appkey_index,uint16 vendor_id,uint16 model_id,uint16 pub_address,uint8 ttl,uint8 period,uint8 retrans,uint8 credentials)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_test_set_local_model_pub.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_test_set_local_model_pub.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_test_set_local_model_pub.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_test_set_local_model_pub.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_test_set_local_model_pub.pub_address=pub_address;
    gecko_cmd_msg->data.cmd_mesh_test_set_local_model_pub.ttl=ttl;
    gecko_cmd_msg->data.cmd_mesh_test_set_local_model_pub.period=period;
    gecko_cmd_msg->data.cmd_mesh_test_set_local_model_pub.retrans=retrans;
    gecko_cmd_msg->data.cmd_mesh_test_set_local_model_pub.credentials=credentials;
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_set_local_model_pub_id+(((14)&0xff)<<8)+(((14)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_set_local_model_pub;
}

/** 
*
* gecko_cmd_mesh_test_set_local_model_pub_va
*
* Set a model's publication virtual address, key, and parameters. 
*
* @param elem_index   The index of the target element, 0 is the primary element
* @param appkey_index   The application key index to use for the published messages
* @param vendor_id   Vendor ID of the configured model. Use 0xffff for Bluetooth SIG models.
* @param model_id   Model ID of the configured model
* @param ttl   Publication time-to-live value
* @param period   Publication period encoded as step count and step resolution. The encoding is
*  as follows:
*  
*      Bits 0..5: Step count
*      Bits 6..7: Step resolution: 
*      * 00: 100 milliseconds
*      * 01: 1 second
*      * 10: 10 seconds
*      * 11: 10 minutes
* @param retrans   See documentation of local model publication set command for details.
* @param credentials   Friendship credentials flag
* @param pub_address_len   Array length
* @param pub_address_data   The Label UUID to publish to. The byte array must be exactly 16 bytes long.
*
**/

static inline struct gecko_msg_mesh_test_set_local_model_pub_va_rsp_t* gecko_cmd_mesh_test_set_local_model_pub_va(uint16 elem_index,uint16 appkey_index,uint16 vendor_id,uint16 model_id,uint8 ttl,uint8 period,uint8 retrans,uint8 credentials,uint8 pub_address_len, const uint8* pub_address_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)pub_address_len > 256 - 13)
    {
        gecko_rsp_msg->data.rsp_mesh_test_set_local_model_pub_va.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_test_set_local_model_pub_va;
    }

    
    gecko_cmd_msg->data.cmd_mesh_test_set_local_model_pub_va.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_test_set_local_model_pub_va.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_test_set_local_model_pub_va.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_test_set_local_model_pub_va.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_test_set_local_model_pub_va.ttl=ttl;
    gecko_cmd_msg->data.cmd_mesh_test_set_local_model_pub_va.period=period;
    gecko_cmd_msg->data.cmd_mesh_test_set_local_model_pub_va.retrans=retrans;
    gecko_cmd_msg->data.cmd_mesh_test_set_local_model_pub_va.credentials=credentials;
    gecko_cmd_msg->data.cmd_mesh_test_set_local_model_pub_va.pub_address.len=pub_address_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_test_set_local_model_pub_va.pub_address.data,pub_address_data,pub_address_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_set_local_model_pub_va_id+(((13+pub_address_len)&0xff)<<8)+(((13+pub_address_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_set_local_model_pub_va;
}

/** 
*
* gecko_cmd_mesh_test_get_local_model_pub
*
* Get a local model's publication address, key, and parameters. 
*
* @param elem_index   The index of the target element, 0 is the primary element
* @param vendor_id   Vendor ID for vendor-specific models. Use 0xffff for Bluetooth SIG models.
* @param model_id   Model ID
*
**/

static inline struct gecko_msg_mesh_test_get_local_model_pub_rsp_t* gecko_cmd_mesh_test_get_local_model_pub(uint16 elem_index,uint16 vendor_id,uint16 model_id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_test_get_local_model_pub.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_test_get_local_model_pub.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_test_get_local_model_pub.model_id=model_id;
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_get_local_model_pub_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_get_local_model_pub;
}

/** 
*
* gecko_cmd_mesh_test_set_local_heartbeat_subscription
*
* Set local node heartbeat subscription parameters. Normally heartbeat
* subscription is controlled by the Provisioner. 
*
* @param subscription_source   Source address for heartbeat messages. Must be either a unicast address or the
*  unassigned address, in which case heartbeat messages are not processed.
* @param subscription_destination   Destination address for heartbeat messages. The address must be either the
*  unicast address of the primary element of the node, a group address, or the
*  unassigned address. If it is the unassigned address, heartbeat messages are
*  not processed.
* @param period_log   Heartbeat subscription period setting. Valid values are as follows:  
*  
*      0x00: Heartbeat messages are not received
*      0x01 .. 0x11: Node will receive heartbeat messages for 2^(n-1) seconds
*      0x12 .. 0xff: Prohibited
*
**/

static inline struct gecko_msg_mesh_test_set_local_heartbeat_subscription_rsp_t* gecko_cmd_mesh_test_set_local_heartbeat_subscription(uint16 subscription_source,uint16 subscription_destination,uint8 period_log)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_test_set_local_heartbeat_subscription.subscription_source=subscription_source;
    gecko_cmd_msg->data.cmd_mesh_test_set_local_heartbeat_subscription.subscription_destination=subscription_destination;
    gecko_cmd_msg->data.cmd_mesh_test_set_local_heartbeat_subscription.period_log=period_log;
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_set_local_heartbeat_subscription_id+(((5)&0xff)<<8)+(((5)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_set_local_heartbeat_subscription;
}

/** 
*
* gecko_cmd_mesh_test_get_local_heartbeat_subscription
*
* Get the local node heartbeat subscription. state 
*
*
**/

static inline struct gecko_msg_mesh_test_get_local_heartbeat_subscription_rsp_t* gecko_cmd_mesh_test_get_local_heartbeat_subscription()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_get_local_heartbeat_subscription_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_get_local_heartbeat_subscription;
}

/** 
*
* gecko_cmd_mesh_test_get_local_heartbeat_publication
*
* Get heartbeat publication state of a local node. 
*
*
**/

static inline struct gecko_msg_mesh_test_get_local_heartbeat_publication_rsp_t* gecko_cmd_mesh_test_get_local_heartbeat_publication()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_get_local_heartbeat_publication_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_get_local_heartbeat_publication;
}

/** 
*
* gecko_cmd_mesh_test_set_local_heartbeat_publication
*
* Set heartbeat publication state of a local node. 
*
* @param publication_address   Heartbeat publication address. The address can't be a virtual address. Note
*  that it can be the unassigned address, in which case the heartbeat publishing
*  is disabled.
* @param count_log   Heartbeat publication count setting. Valid values are as follows:  
*  
*      0x00: Heartbeat messages are not sent
*      0x01 .. 0x11: Node will send 2^(n-1) heartbeat messages
*      0x12 .. 0xfe: Prohibited
*      0xff: Hearbeat messages are sent indefinitely
* @param period_log   Heartbeat publication period setting. Valid values are as follows:  
*  
*      0x00: Heartbeat messages are not sent
*      0x01 .. 0x11: Node will send a heartbeat message every 2^(n-1) seconds
*      0x12 .. 0xff: Prohibited
* @param ttl   Time-to-live parameter for heartbeat messages
* @param features   Heartbeat trigger setting. For bits set in the bitmask, reconfiguration of the
*  node feature associated with the bit will result in the node emitting a
*  heartbeat message. Valid values are as follows:
*  
*      Bit 0: Relay feature
*      Bit 1: Proxy feature
*      Bit 2: Friend feature
*      Bit 3: Low power feature
*  
*  Remaining bits are reserved for future use.
* @param publication_netkey_index   Index of the network key used to encrypt heartbeat messages
*
**/

static inline struct gecko_msg_mesh_test_set_local_heartbeat_publication_rsp_t* gecko_cmd_mesh_test_set_local_heartbeat_publication(uint16 publication_address,uint8 count_log,uint8 period_log,uint8 ttl,uint16 features,uint16 publication_netkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_test_set_local_heartbeat_publication.publication_address=publication_address;
    gecko_cmd_msg->data.cmd_mesh_test_set_local_heartbeat_publication.count_log=count_log;
    gecko_cmd_msg->data.cmd_mesh_test_set_local_heartbeat_publication.period_log=period_log;
    gecko_cmd_msg->data.cmd_mesh_test_set_local_heartbeat_publication.ttl=ttl;
    gecko_cmd_msg->data.cmd_mesh_test_set_local_heartbeat_publication.features=features;
    gecko_cmd_msg->data.cmd_mesh_test_set_local_heartbeat_publication.publication_netkey_index=publication_netkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_set_local_heartbeat_publication_id+(((9)&0xff)<<8)+(((9)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_set_local_heartbeat_publication;
}

/** 
*
* gecko_cmd_mesh_test_set_local_config
*
* Set a state to a value in the local Configuration Server model. Use for
* testing and debugging purposes only. 
*
* @param id   The State to modify
* @param netkey_index   Network key index; ignored for node-wide states
* @param value_len   Array length
* @param value_data   The new value
*
**/

static inline struct gecko_msg_mesh_test_set_local_config_rsp_t* gecko_cmd_mesh_test_set_local_config(uint16 id,uint16 netkey_index,uint8 value_len, const uint8* value_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)value_len > 256 - 5)
    {
        gecko_rsp_msg->data.rsp_mesh_test_set_local_config.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_test_set_local_config;
    }

    
    gecko_cmd_msg->data.cmd_mesh_test_set_local_config.id=id;
    gecko_cmd_msg->data.cmd_mesh_test_set_local_config.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_test_set_local_config.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_test_set_local_config.value.data,value_data,value_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_set_local_config_id+(((5+value_len)&0xff)<<8)+(((5+value_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_set_local_config;
}

/** 
*
* gecko_cmd_mesh_test_get_local_config
*
* Get the value of a state in the Configuration Server model. Use this for
* testing and debugging purposes only. 
*
* @param id   The state to read
* @param netkey_index   Network key index; ignored for node-wide states
*
**/

static inline struct gecko_msg_mesh_test_get_local_config_rsp_t* gecko_cmd_mesh_test_get_local_config(uint16 id,uint16 netkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_test_get_local_config.id=id;
    gecko_cmd_msg->data.cmd_mesh_test_get_local_config.netkey_index=netkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_get_local_config_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_get_local_config;
}

/** 
*
* gecko_cmd_mesh_test_add_local_key
*
* Add a network or application key locally. 
*
* @param key_type   0 for network key, 1 for application key
* @param key   Key data
* @param key_index   Index for the added key (must be unused)
* @param netkey_index   Network key index to which the application key is bound; ignored for network
*  keys
*
**/

static inline struct gecko_msg_mesh_test_add_local_key_rsp_t* gecko_cmd_mesh_test_add_local_key(uint8 key_type,aes_key_128 key,uint16 key_index,uint16 netkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_test_add_local_key.key_type=key_type;
    gecko_cmd_msg->data.cmd_mesh_test_add_local_key.key=key;
    gecko_cmd_msg->data.cmd_mesh_test_add_local_key.key_index=key_index;
    gecko_cmd_msg->data.cmd_mesh_test_add_local_key.netkey_index=netkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_add_local_key_id+(((21)&0xff)<<8)+(((21)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_add_local_key;
}

/** 
*
* gecko_cmd_mesh_test_del_local_key
*
* Delete a network or application key locally. 
*
* @param key_type   0 for network key, 1 for application key
* @param key_index   Index of the key to delete
*
**/

static inline struct gecko_msg_mesh_test_del_local_key_rsp_t* gecko_cmd_mesh_test_del_local_key(uint8 key_type,uint16 key_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_test_del_local_key.key_type=key_type;
    gecko_cmd_msg->data.cmd_mesh_test_del_local_key.key_index=key_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_del_local_key_id+(((3)&0xff)<<8)+(((3)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_del_local_key;
}

/** 
*
* gecko_cmd_mesh_test_update_local_key
*
* Update network or application key value locally.
* 
* Copies the existing network key value to the old value and replaces the
* current value with the given key data.
* 
* Note that the standard way to update keys on Provisioner as well as on nodes
* is to run the key refresh procedure. This command is for debugging only. 
*
* @param key_type   0 for network key, 1 for application key
* @param key   Key data
* @param key_index   Index for the key to update
*
**/

static inline struct gecko_msg_mesh_test_update_local_key_rsp_t* gecko_cmd_mesh_test_update_local_key(uint8 key_type,aes_key_128 key,uint16 key_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_test_update_local_key.key_type=key_type;
    gecko_cmd_msg->data.cmd_mesh_test_update_local_key.key=key;
    gecko_cmd_msg->data.cmd_mesh_test_update_local_key.key_index=key_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_update_local_key_id+(((19)&0xff)<<8)+(((19)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_update_local_key;
}

/** 
*
* gecko_cmd_mesh_test_set_sar_config
*
* Changes the transport layer segmentation and reassembly configuration values.
* This command must be issued before initializing the Mesh stack or the changes
* will not take effect. 
*
* @param incomplete_timer_ms   Maximum timeout before a transaction expires, regardless of other parameters.
*  Value is in milliseconds. Default = 10000 (10 seconds).
* @param pending_ack_base_ms   Base time to wait at the receiver before sending a transport layer
*  acknowledgment. Value is in milliseconds. Default = 150.
* @param pending_ack_mul_ms   TTL multiplier to add to the base acknowledgment timer. Value is in
*  milliseconds. Default = 50.
* @param wait_for_ack_base_ms   Base time to wait for an acknowledgment at the sender before retransmission.
*  Value is in milliseconds. Default = 200.
* @param wait_for_ack_mul_ms   TTL multiplier to add to the base retransmission timer. Value is in
*  milliseconds. Default = 50.
* @param max_send_rounds   Number of attempts to send fragments of a segmented message, including the
*  initial TX. Default = 3.
*
**/

static inline struct gecko_msg_mesh_test_set_sar_config_rsp_t* gecko_cmd_mesh_test_set_sar_config(uint32 incomplete_timer_ms,uint32 pending_ack_base_ms,uint32 pending_ack_mul_ms,uint32 wait_for_ack_base_ms,uint32 wait_for_ack_mul_ms,uint8 max_send_rounds)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_test_set_sar_config.incomplete_timer_ms=incomplete_timer_ms;
    gecko_cmd_msg->data.cmd_mesh_test_set_sar_config.pending_ack_base_ms=pending_ack_base_ms;
    gecko_cmd_msg->data.cmd_mesh_test_set_sar_config.pending_ack_mul_ms=pending_ack_mul_ms;
    gecko_cmd_msg->data.cmd_mesh_test_set_sar_config.wait_for_ack_base_ms=wait_for_ack_base_ms;
    gecko_cmd_msg->data.cmd_mesh_test_set_sar_config.wait_for_ack_mul_ms=wait_for_ack_mul_ms;
    gecko_cmd_msg->data.cmd_mesh_test_set_sar_config.max_send_rounds=max_send_rounds;
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_set_sar_config_id+(((21)&0xff)<<8)+(((21)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_set_sar_config;
}

/** 
*
* gecko_cmd_mesh_test_get_element_seqnum
*
* Get current sequence number of an element. 
*
* @param elem_index   The index of the target element, 0 is the primary element
*
**/

static inline struct gecko_msg_mesh_test_get_element_seqnum_rsp_t* gecko_cmd_mesh_test_get_element_seqnum(uint16 elem_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_test_get_element_seqnum.elem_index=elem_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_get_element_seqnum_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_get_element_seqnum;
}

/** 
*
* gecko_cmd_mesh_test_set_adv_bearer_state
*
* Disable or enable advertisement bearer for sending. 
*
* @param state   0: disable advertisement, 1: enable advertisement.
*
**/

static inline struct gecko_msg_mesh_test_set_adv_bearer_state_rsp_t* gecko_cmd_mesh_test_set_adv_bearer_state(uint8 state)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_test_set_adv_bearer_state.state=state;
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_set_adv_bearer_state_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_set_adv_bearer_state;
}

/** 
*
* gecko_cmd_mesh_test_get_key_count
*
* Get total number of keys in node. 
*
* @param type   0 for network key, 1 for application key
*
**/

static inline struct gecko_msg_mesh_test_get_key_count_rsp_t* gecko_cmd_mesh_test_get_key_count(uint8 type)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_test_get_key_count.type=type;
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_get_key_count_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_get_key_count;
}

/** 
*
* gecko_cmd_mesh_test_get_key
*
* Get key by position. Only current key data exits in normal mode. Old key data
* can be queried only during key refresh. 
*
* @param type   0 for network key, 1 for application key
* @param index   Key position, ranging from zero to key count minus one
* @param current   1: Current key, 0: Old key
*
**/

static inline struct gecko_msg_mesh_test_get_key_rsp_t* gecko_cmd_mesh_test_get_key(uint8 type,uint32 index,uint8 current)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_test_get_key.type=type;
    gecko_cmd_msg->data.cmd_mesh_test_get_key.index=index;
    gecko_cmd_msg->data.cmd_mesh_test_get_key.current=current;
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_get_key_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_get_key;
}

/** 
*
* gecko_cmd_mesh_test_prov_get_device_key
*
* Get device key by the address of the nodes primary element. 
*
* @param address   Address of the node
*
**/

static inline struct gecko_msg_mesh_test_prov_get_device_key_rsp_t* gecko_cmd_mesh_test_prov_get_device_key(uint16 address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_test_prov_get_device_key.address=address;
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_prov_get_device_key_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_prov_get_device_key;
}

/** 
*
* gecko_cmd_mesh_test_prov_prepare_key_refresh
*
* Prepare key refresh by feeding the new network key and all needed application
* keys. The function can be called multiple times to include more application
* keys. The network key must be the same in all calls. If the network key is
* changed, the network key from the 1st command is used.  
* Sending application key data with length zero results in all initialization
* data being forgotten unless this is done in the first prepare command i.e.,
* trying to update only the network key. Also starting the key refresh procedure
* results in all the preparation data being forgotten. 
*
* @param net_key   New net key
* @param app_keys_len   Array length
* @param app_keys_data   list of new application keys, 16-bytes each
*
**/

static inline struct gecko_msg_mesh_test_prov_prepare_key_refresh_rsp_t* gecko_cmd_mesh_test_prov_prepare_key_refresh(aes_key_128 net_key,uint8 app_keys_len, const uint8* app_keys_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)app_keys_len > 256 - 17)
    {
        gecko_rsp_msg->data.rsp_mesh_test_prov_prepare_key_refresh.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_test_prov_prepare_key_refresh;
    }

    
    gecko_cmd_msg->data.cmd_mesh_test_prov_prepare_key_refresh.net_key=net_key;
    gecko_cmd_msg->data.cmd_mesh_test_prov_prepare_key_refresh.app_keys.len=app_keys_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_test_prov_prepare_key_refresh.app_keys.data,app_keys_data,app_keys_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_prov_prepare_key_refresh_id+(((17+app_keys_len)&0xff)<<8)+(((17+app_keys_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_prov_prepare_key_refresh;
}

/** 
*
* gecko_cmd_mesh_test_cancel_segmented_tx
*
* Cancel sending a segmented message. 
*
* @param src_addr   Source address for the segmented message
* @param dst_addr   Destination address for the segmented message
*
**/

static inline struct gecko_msg_mesh_test_cancel_segmented_tx_rsp_t* gecko_cmd_mesh_test_cancel_segmented_tx(uint16 src_addr,uint16 dst_addr)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_test_cancel_segmented_tx.src_addr=src_addr;
    gecko_cmd_msg->data.cmd_mesh_test_cancel_segmented_tx.dst_addr=dst_addr;
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_cancel_segmented_tx_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_cancel_segmented_tx;
}

/** 
*
* gecko_cmd_mesh_test_set_iv_index
*
* Set IV index value of the node. 
*
* @param iv_index   IV Index value to use
*
**/

static inline struct gecko_msg_mesh_test_set_iv_index_rsp_t* gecko_cmd_mesh_test_set_iv_index(uint32 iv_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_test_set_iv_index.iv_index=iv_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_set_iv_index_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_set_iv_index;
}

/** 
*
* gecko_cmd_mesh_test_set_element_seqnum
*
* Set current sequence number of an element. 
*
* @param elem_index   The index of the target element, 0 is the primary element
* @param seqnum   Sequence number to set on the target element
*
**/

static inline struct gecko_msg_mesh_test_set_element_seqnum_rsp_t* gecko_cmd_mesh_test_set_element_seqnum(uint16 elem_index,uint32 seqnum)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_test_set_element_seqnum.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_test_set_element_seqnum.seqnum=seqnum;
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_set_element_seqnum_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_set_element_seqnum;
}

/** 
*
* gecko_cmd_mesh_test_set_model_option
*
* Set model-specific option. 
*
* @param elem_index   The index of the target element, 0 is the primary element
* @param vendor_id   Vendor ID for vendor-specific models. Use 0xffff for Bluetooth SIG models.
* @param model_id   Model ID
* @param option   Option to set
* @param value   Value for the option
*
**/

static inline struct gecko_msg_mesh_test_set_model_option_rsp_t* gecko_cmd_mesh_test_set_model_option(uint16 elem_index,uint16 vendor_id,uint16 model_id,uint8 option,uint32 value)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_test_set_model_option.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_test_set_model_option.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_test_set_model_option.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_test_set_model_option.option=option;
    gecko_cmd_msg->data.cmd_mesh_test_set_model_option.value=value;
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_set_model_option_id+(((11)&0xff)<<8)+(((11)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_set_model_option;
}

/** 
*
* gecko_cmd_mesh_test_get_local_model_app_bindings
*
* Get application key bindings of a model. 
*
* @param elem_index   The index of the target element, 0 is the primary element
* @param vendor_id   Vendor ID for vendor-specific models. Use 0xffff for Bluetooth SIG models.
* @param model_id   Model ID
*
**/

static inline struct gecko_msg_mesh_test_get_local_model_app_bindings_rsp_t* gecko_cmd_mesh_test_get_local_model_app_bindings(uint16 elem_index,uint16 vendor_id,uint16 model_id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_test_get_local_model_app_bindings.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_test_get_local_model_app_bindings.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_test_get_local_model_app_bindings.model_id=model_id;
    gecko_cmd_msg->header=(gecko_cmd_mesh_test_get_local_model_app_bindings_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_test_get_local_model_app_bindings;
}

/** 
*
* gecko_cmd_mesh_lpn_init
*
* Initialize the Low Power node (LPN) mode. The node needs to be provisioned
* before calling this command. After the LPN mode is initialized, the node can't
* operate in the network without a Friend node. To establish a friendship with a
* nearby Friend node, use the establish friendship command. Make this call
* before calling the other commands in this class. 
*
*
**/

static inline struct gecko_msg_mesh_lpn_init_rsp_t* gecko_cmd_mesh_lpn_init()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_lpn_init_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_lpn_init;
}

/** 
*
* gecko_cmd_mesh_lpn_deinit
*
* Deinitialize the LPN functionality. After calling this command, a possible
* friendship with a Friend node is terminated and the node can operate in the
* network independently. After calling this command, do not call any other
* command in this class before the Low Power mode is initialized again. 
*
*
**/

static inline struct gecko_msg_mesh_lpn_deinit_rsp_t* gecko_cmd_mesh_lpn_deinit()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_lpn_deinit_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_lpn_deinit;
}

/** 
*
* gecko_cmd_mesh_lpn_configure
*
* Deprecated and replaced by mesh_lpn_config command. Configure the parameters
* for friendship establishment. 
*
* @param queue_length   Minimum queue length the friend must support. Choose an appropriate value
*  based on the expected message frequency and LPN sleep period, because messages
*  that do not fit into the friend queue are dropped. Note that the given value
*  is rounded up to the nearest power of 2. Range: 2..128
* @param poll_timeout   Poll timeout in milliseconds, which is the longest time that LPN sleeps in
*  between querying its friend for queued messages. Long poll timeout allows the
*  LPN to sleep for longer periods, at the expense of increased latency for
*  receiving messages. Note that the given value is rounded up to the nearest 100
*  ms Range: 1 s to 95 h 59 min 59 s 900 ms
*
**/
BGLIB_DEPRECATED_API 
static inline struct gecko_msg_mesh_lpn_configure_rsp_t* gecko_cmd_mesh_lpn_configure(uint8 queue_length,uint32 poll_timeout)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_lpn_configure.queue_length=queue_length;
    gecko_cmd_msg->data.cmd_mesh_lpn_configure.poll_timeout=poll_timeout;
    gecko_cmd_msg->header=(gecko_cmd_mesh_lpn_configure_id+(((5)&0xff)<<8)+(((5)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_lpn_configure;
}

/** 
*
* gecko_cmd_mesh_lpn_establish_friendship
*
* Establish a friendship. After a friendship has been established the node can
* start saving power. 
*
* @param netkey_index   Network key index used in friendship request
*
**/

static inline struct gecko_msg_mesh_lpn_establish_friendship_rsp_t* gecko_cmd_mesh_lpn_establish_friendship(uint16 netkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_lpn_establish_friendship.netkey_index=netkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_lpn_establish_friendship_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_lpn_establish_friendship;
}

/** 
*
* gecko_cmd_mesh_lpn_poll
*
* Poll the Friend node for stored messages and security updates. This command
* may be used if the application is expecting to receive messages at a specific
* time. However, it is not required for correct operation, because the procedure
* will be performed autonomously before the poll timeout expires. 
*
*
**/

static inline struct gecko_msg_mesh_lpn_poll_rsp_t* gecko_cmd_mesh_lpn_poll()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_lpn_poll_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_lpn_poll;
}

/** 
*
* gecko_cmd_mesh_lpn_terminate_friendship
*
* Terminate an already established friendship. Friendship terminated event will
* be emitted when the friendship termination has been completed. 
*
*
**/

static inline struct gecko_msg_mesh_lpn_terminate_friendship_rsp_t* gecko_cmd_mesh_lpn_terminate_friendship()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_lpn_terminate_friendship_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_lpn_terminate_friendship;
}

/** 
*
* gecko_cmd_mesh_lpn_config
*
* Configure the parameters for friendship establishment and LPN behavior. 
*
* @param setting_id   Identifies the LPN setting to be updated.
* @param value   New value for the given setting
*
**/

static inline struct gecko_msg_mesh_lpn_config_rsp_t* gecko_cmd_mesh_lpn_config(uint8 setting_id,uint32 value)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_lpn_config.setting_id=setting_id;
    gecko_cmd_msg->data.cmd_mesh_lpn_config.value=value;
    gecko_cmd_msg->header=(gecko_cmd_mesh_lpn_config_id+(((5)&0xff)<<8)+(((5)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_lpn_config;
}

/** 
*
* gecko_cmd_mesh_friend_init
*
* Initialize the Friend mode. The node needs to be provisioned before calling
* this command. After the Friend mode is initialized, it is ready to accept
* friend requests from low-power nodes. This call has to be made before calling
* the other commands in this class. 
*
*
**/

static inline struct gecko_msg_mesh_friend_init_rsp_t* gecko_cmd_mesh_friend_init()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_friend_init_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_friend_init;
}

/** 
*
* gecko_cmd_mesh_friend_deinit
*
* Deinitialize the Friend functionality. After calling this command, a possible
* friendship with a Low Power node is terminated and all friendships are
* terminated. After calling this command, don't call other commands in this
* class before the Friend mode is initialized again. 
*
*
**/

static inline struct gecko_msg_mesh_friend_deinit_rsp_t* gecko_cmd_mesh_friend_deinit()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_friend_deinit_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_friend_deinit;
}

/** 
*
* gecko_cmd_mesh_config_client_cancel_request
*
* Cancel an ongoing request releasing resources allocated at the Configuration
* Client. Note that this call does no undo any setting a node may have made if
* it had received the request already. 
*
* @param handle   Request handle
*
**/

static inline struct gecko_msg_mesh_config_client_cancel_request_rsp_t* gecko_cmd_mesh_config_client_cancel_request(uint32 handle)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_cancel_request.handle=handle;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_cancel_request_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_cancel_request;
}

/** 
*
* gecko_cmd_mesh_config_client_get_request_status
*
* Get the status of a pending request. 
*
* @param handle   Request handle
*
**/

static inline struct gecko_msg_mesh_config_client_get_request_status_rsp_t* gecko_cmd_mesh_config_client_get_request_status(uint32 handle)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_get_request_status.handle=handle;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_get_request_status_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_get_request_status;
}

/** 
*
* gecko_cmd_mesh_config_client_get_default_timeout
*
* Get the default timeout for configuration client requests. If there is no
* response when the timeout expires, a configuration request is considered to
* have failed and an event with an error result will be generated. Note that if
* the Bluetooth mesh stack notices the request is destined to an LPN by
* receiving an on-behalf-of acknowledgment from a Friend node, the timeout in
* use will be changed to the LPN default timeout. 
*
*
**/

static inline struct gecko_msg_mesh_config_client_get_default_timeout_rsp_t* gecko_cmd_mesh_config_client_get_default_timeout()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_get_default_timeout_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_get_default_timeout;
}

/** 
*
* gecko_cmd_mesh_config_client_set_default_timeout
*
* Set the default timeout for configuration client requests. 
*
* @param timeout_ms   Timeout in milliseconds. Default timeout is 5 s (5000 ms).
* @param lpn_timeout_ms   Timeout in milliseconds when communicating with an LPN node. Default LPN
*  timeout is 120 s (120000 ms).
*
**/

static inline struct gecko_msg_mesh_config_client_set_default_timeout_rsp_t* gecko_cmd_mesh_config_client_set_default_timeout(uint32 timeout_ms,uint32 lpn_timeout_ms)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_set_default_timeout.timeout_ms=timeout_ms;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_default_timeout.lpn_timeout_ms=lpn_timeout_ms;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_set_default_timeout_id+(((8)&0xff)<<8)+(((8)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_set_default_timeout;
}

/** 
*
* gecko_cmd_mesh_config_client_add_netkey
*
* Add a network key to a node. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param netkey_index   Index of the network key to add
*
* Events generated
*
* gecko_evt_mesh_config_client_netkey_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_add_netkey_rsp_t* gecko_cmd_mesh_config_client_add_netkey(uint16 enc_netkey_index,uint16 server_address,uint16 netkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_add_netkey.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_add_netkey.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_add_netkey.netkey_index=netkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_add_netkey_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_add_netkey;
}

/** 
*
* gecko_cmd_mesh_config_client_remove_netkey
*
* Remove a network key from a node. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param netkey_index   Index of the network key to remove
*
* Events generated
*
* gecko_evt_mesh_config_client_netkey_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_remove_netkey_rsp_t* gecko_cmd_mesh_config_client_remove_netkey(uint16 enc_netkey_index,uint16 server_address,uint16 netkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_remove_netkey.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_remove_netkey.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_remove_netkey.netkey_index=netkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_remove_netkey_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_remove_netkey;
}

/** 
*
* gecko_cmd_mesh_config_client_list_netkeys
*
* List the network keys on a node. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
*
* Events generated
*
* gecko_evt_mesh_config_client_netkey_list - 
* gecko_evt_mesh_config_client_netkey_list_end - 
*
**/

static inline struct gecko_msg_mesh_config_client_list_netkeys_rsp_t* gecko_cmd_mesh_config_client_list_netkeys(uint16 enc_netkey_index,uint16 server_address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_list_netkeys.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_list_netkeys.server_address=server_address;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_list_netkeys_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_list_netkeys;
}

/** 
*
* gecko_cmd_mesh_config_client_add_appkey
*
* Add an application key to a node. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param appkey_index   Index of the application key to add
* @param netkey_index   Index of the network key to bind the application key to on the node. Note that
*  this may be different from the binding on other nodes or on the Configuration
*  Client if desired.
*
* Events generated
*
* gecko_evt_mesh_config_client_appkey_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_add_appkey_rsp_t* gecko_cmd_mesh_config_client_add_appkey(uint16 enc_netkey_index,uint16 server_address,uint16 appkey_index,uint16 netkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_add_appkey.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_add_appkey.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_add_appkey.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_add_appkey.netkey_index=netkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_add_appkey_id+(((8)&0xff)<<8)+(((8)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_add_appkey;
}

/** 
*
* gecko_cmd_mesh_config_client_remove_appkey
*
* Remove an application key from a node. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param appkey_index   Index of the application key to remove
* @param netkey_index   Index of the network key bound to the application key to on the node. Note
*  that this may be different from the binding on other nodes or on the
*  Configuration Client.
*
* Events generated
*
* gecko_evt_mesh_config_client_appkey_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_remove_appkey_rsp_t* gecko_cmd_mesh_config_client_remove_appkey(uint16 enc_netkey_index,uint16 server_address,uint16 appkey_index,uint16 netkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_remove_appkey.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_remove_appkey.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_remove_appkey.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_remove_appkey.netkey_index=netkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_remove_appkey_id+(((8)&0xff)<<8)+(((8)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_remove_appkey;
}

/** 
*
* gecko_cmd_mesh_config_client_list_appkeys
*
* List the application keys on a node. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param netkey_index   Network key index for the key used as the query parameter. The result contains
*  the indices of the application keys bound to this network key on the node.
*
* Events generated
*
* gecko_evt_mesh_config_client_appkey_list - 
* gecko_evt_mesh_config_client_appkey_list_end - 
*
**/

static inline struct gecko_msg_mesh_config_client_list_appkeys_rsp_t* gecko_cmd_mesh_config_client_list_appkeys(uint16 enc_netkey_index,uint16 server_address,uint16 netkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_list_appkeys.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_list_appkeys.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_list_appkeys.netkey_index=netkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_list_appkeys_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_list_appkeys;
}

/** 
*
* gecko_cmd_mesh_config_client_bind_model
*
* Bind an application key to a model. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param element_index   Index of the element where the model to be configured resides on the node
* @param appkey_index   Index of the application key to bind to the model
* @param vendor_id   Vendor ID for the model to configure. Use 0xFFFF for Bluetooth SIG models.
* @param model_id   Model ID for the model to configure
*
* Events generated
*
* gecko_evt_mesh_config_client_binding_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_bind_model_rsp_t* gecko_cmd_mesh_config_client_bind_model(uint16 enc_netkey_index,uint16 server_address,uint8 element_index,uint16 appkey_index,uint16 vendor_id,uint16 model_id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_bind_model.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_bind_model.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_bind_model.element_index=element_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_bind_model.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_bind_model.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_config_client_bind_model.model_id=model_id;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_bind_model_id+(((11)&0xff)<<8)+(((11)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_bind_model;
}

/** 
*
* gecko_cmd_mesh_config_client_unbind_model
*
* Unbind an application key from a model 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param element_index   Index of the element where the model to be configured resides on the node
* @param appkey_index   Index of the application key to unbind from the model
* @param vendor_id   Vendor ID for the model to configure. Use 0xFFFF for Bluetooth SIG models.
* @param model_id   Model ID for the model to configure
*
* Events generated
*
* gecko_evt_mesh_config_client_binding_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_unbind_model_rsp_t* gecko_cmd_mesh_config_client_unbind_model(uint16 enc_netkey_index,uint16 server_address,uint8 element_index,uint16 appkey_index,uint16 vendor_id,uint16 model_id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_unbind_model.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_unbind_model.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_unbind_model.element_index=element_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_unbind_model.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_unbind_model.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_config_client_unbind_model.model_id=model_id;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_unbind_model_id+(((11)&0xff)<<8)+(((11)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_unbind_model;
}

/** 
*
* gecko_cmd_mesh_config_client_list_bindings
*
* List application key bindings of a model. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param element_index   Index of the element where the model to be queried resides on the node
* @param vendor_id   Vendor ID for the model to query. Use 0xFFFF for Bluetooth SIG models.
* @param model_id   Model ID for the model to query
*
* Events generated
*
* gecko_evt_mesh_config_client_bindings_list - 
* gecko_evt_mesh_config_client_bindings_list_end - 
*
**/

static inline struct gecko_msg_mesh_config_client_list_bindings_rsp_t* gecko_cmd_mesh_config_client_list_bindings(uint16 enc_netkey_index,uint16 server_address,uint8 element_index,uint16 vendor_id,uint16 model_id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_list_bindings.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_list_bindings.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_list_bindings.element_index=element_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_list_bindings.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_config_client_list_bindings.model_id=model_id;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_list_bindings_id+(((9)&0xff)<<8)+(((9)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_list_bindings;
}

/** 
*
* gecko_cmd_mesh_config_client_get_model_pub
*
* Get model publication state. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param element_index   Index of the element where the model to be queried resides on the node
* @param vendor_id   Vendor ID for the model to query. Use 0xFFFF for Bluetooth SIG models.
* @param model_id   Model ID for the model to query
*
* Events generated
*
* gecko_evt_mesh_config_client_model_pub_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_get_model_pub_rsp_t* gecko_cmd_mesh_config_client_get_model_pub(uint16 enc_netkey_index,uint16 server_address,uint8 element_index,uint16 vendor_id,uint16 model_id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_get_model_pub.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_get_model_pub.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_get_model_pub.element_index=element_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_get_model_pub.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_config_client_get_model_pub.model_id=model_id;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_get_model_pub_id+(((9)&0xff)<<8)+(((9)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_get_model_pub;
}

/** 
*
* gecko_cmd_mesh_config_client_set_model_pub
*
* Set model publication state. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param element_index   Index of the element where the model to be configured resides on the node
* @param vendor_id   Vendor ID for the model to configure. Use 0xFFFF for Bluetooth SIG models.
* @param model_id   Model ID for the model to configure
* @param address   The address to publish to. Can be a unicast address, a virtual address, or a
*  group address; can also be the unassigned address to stop the model from
*  publishing.
* @param appkey_index   The application key index to use for the published messages.
* @param credentials   Friendship credential flag. If zero, publication is done using normal
*  credentials. If one, it is done with friendship credentials, meaning only the
*  friend can decrypt the published message and relay it forward using the normal
*  credentials. The default value is 0.
* @param ttl   Publication time-to-live value
* @param period_ms   Publication period in milliseconds. Note that the resolution of the
*  publication period is limited by the specification to 100 ms up to a period of
*  6.3 s, 1 s up to a period of 63 s, 10 s up to a period of 630 s, and 10
*  minutes above that. Maximum period allowed is 630 minutes.
* @param retransmit_count   Publication retransmission count. Valid values range from 0 to 7.
* @param retransmit_interval_ms   Publication retransmission interval in millisecond units. The range of value
*  is 50 to 1600 ms, and the resolution of the value is 50 milliseconds.
*
* Events generated
*
* gecko_evt_mesh_config_client_model_pub_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_set_model_pub_rsp_t* gecko_cmd_mesh_config_client_set_model_pub(uint16 enc_netkey_index,uint16 server_address,uint8 element_index,uint16 vendor_id,uint16 model_id,uint16 address,uint16 appkey_index,uint8 credentials,uint8 ttl,uint32 period_ms,uint8 retransmit_count,uint16 retransmit_interval_ms)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_pub.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_pub.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_pub.element_index=element_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_pub.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_pub.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_pub.address=address;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_pub.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_pub.credentials=credentials;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_pub.ttl=ttl;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_pub.period_ms=period_ms;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_pub.retransmit_count=retransmit_count;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_pub.retransmit_interval_ms=retransmit_interval_ms;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_set_model_pub_id+(((22)&0xff)<<8)+(((22)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_set_model_pub;
}

/** 
*
* gecko_cmd_mesh_config_client_set_model_pub_va
*
* Set model publication state, with a full virtual publication address. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param element_index   Index of the element where the model to be configured resides on the node
* @param vendor_id   Vendor ID for the model to configure. Use 0xFFFF for Bluetooth SIG models.
* @param model_id   Model ID for the model to configure
* @param address   The Label UUID (full virtual address) to publish to
* @param appkey_index   The application key index to use for the published messages
* @param credentials   Friendship credential flag. If zero, publication is done using normal
*  credentials. If one, it is done with friendship credentials, meaning only the
*  friend can decrypt the published message and relay it forward using the normal
*  credentials. The default value is 0.
* @param ttl   Publication time-to-live value
* @param period_ms   Publication period in milliseconds. Note that the resolution of the
*  publication period is limited by the specification to 100 ms up to a period of
*  6.3 s, 1 s up to a period of 63 s, 10 s up to a period of 630 s, and 10
*  minutes above that. Maximum period allowed is 630 minutes.
* @param retransmit_count   Publication retransmission count. Valid values range from 0 to 7.
* @param retransmit_interval_ms   Publication retransmission interval in millisecond units. The range of value
*  is 50 to 1600 ms. The resolution of the value is 50 milliseconds.
*
* Events generated
*
* gecko_evt_mesh_config_client_model_pub_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_set_model_pub_va_rsp_t* gecko_cmd_mesh_config_client_set_model_pub_va(uint16 enc_netkey_index,uint16 server_address,uint8 element_index,uint16 vendor_id,uint16 model_id,uuid_128 address,uint16 appkey_index,uint8 credentials,uint8 ttl,uint32 period_ms,uint8 retransmit_count,uint16 retransmit_interval_ms)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_pub_va.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_pub_va.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_pub_va.element_index=element_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_pub_va.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_pub_va.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_pub_va.address=address;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_pub_va.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_pub_va.credentials=credentials;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_pub_va.ttl=ttl;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_pub_va.period_ms=period_ms;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_pub_va.retransmit_count=retransmit_count;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_pub_va.retransmit_interval_ms=retransmit_interval_ms;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_set_model_pub_va_id+(((36)&0xff)<<8)+(((36)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_set_model_pub_va;
}

/** 
*
* gecko_cmd_mesh_config_client_add_model_sub
*
* Add an address to model subscription list. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param element_index   Index of the element where the model to be configured resides on the node
* @param vendor_id   Vendor ID for the model to configure. Use 0xFFFF for Bluetooth SIG models.
* @param model_id   Model ID for the model to configure
* @param sub_address   The address to add to the subscription list. Note that the address has to be a
*  group address.
*
* Events generated
*
* gecko_evt_mesh_config_client_model_sub_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_add_model_sub_rsp_t* gecko_cmd_mesh_config_client_add_model_sub(uint16 enc_netkey_index,uint16 server_address,uint8 element_index,uint16 vendor_id,uint16 model_id,uint16 sub_address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_add_model_sub.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_add_model_sub.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_add_model_sub.element_index=element_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_add_model_sub.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_config_client_add_model_sub.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_config_client_add_model_sub.sub_address=sub_address;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_add_model_sub_id+(((11)&0xff)<<8)+(((11)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_add_model_sub;
}

/** 
*
* gecko_cmd_mesh_config_client_add_model_sub_va
*
* Add a Label UUID (full virtual address) to model subscription list 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param element_index   Index of the element where the model to be configured resides on the node
* @param vendor_id   Vendor ID for the model to configure. Use 0xFFFF for Bluetooth SIG models.
* @param model_id   Model ID for the model to configure
* @param sub_address   The full virtual address to add to the subscription list
*
* Events generated
*
* gecko_evt_mesh_config_client_model_sub_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_add_model_sub_va_rsp_t* gecko_cmd_mesh_config_client_add_model_sub_va(uint16 enc_netkey_index,uint16 server_address,uint8 element_index,uint16 vendor_id,uint16 model_id,uuid_128 sub_address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_add_model_sub_va.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_add_model_sub_va.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_add_model_sub_va.element_index=element_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_add_model_sub_va.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_config_client_add_model_sub_va.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_config_client_add_model_sub_va.sub_address=sub_address;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_add_model_sub_va_id+(((25)&0xff)<<8)+(((25)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_add_model_sub_va;
}

/** 
*
* gecko_cmd_mesh_config_client_remove_model_sub
*
* Remove an address from the model subscription list. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param element_index   Index of the element where the model to be configured resides on the node
* @param vendor_id   Vendor ID for the model to configure. Use 0xFFFF for Bluetooth SIG models.
* @param model_id   Model ID for the model to configure
* @param sub_address   The address to remove from the subscription list
*
* Events generated
*
* gecko_evt_mesh_config_client_model_sub_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_remove_model_sub_rsp_t* gecko_cmd_mesh_config_client_remove_model_sub(uint16 enc_netkey_index,uint16 server_address,uint8 element_index,uint16 vendor_id,uint16 model_id,uint16 sub_address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_remove_model_sub.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_remove_model_sub.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_remove_model_sub.element_index=element_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_remove_model_sub.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_config_client_remove_model_sub.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_config_client_remove_model_sub.sub_address=sub_address;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_remove_model_sub_id+(((11)&0xff)<<8)+(((11)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_remove_model_sub;
}

/** 
*
* gecko_cmd_mesh_config_client_remove_model_sub_va
*
* Remove a Label UUID (full virtual address) from model subscription list. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param element_index   Index of the element where the model to be configured resides on the node
* @param vendor_id   Vendor ID for the model to configure. Use 0xFFFF for Bluetooth SIG models.
* @param model_id   Model ID for the model to configure
* @param sub_address   The full virtual address to remove from the subscription list
*
* Events generated
*
* gecko_evt_mesh_config_client_model_sub_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_remove_model_sub_va_rsp_t* gecko_cmd_mesh_config_client_remove_model_sub_va(uint16 enc_netkey_index,uint16 server_address,uint8 element_index,uint16 vendor_id,uint16 model_id,uuid_128 sub_address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_remove_model_sub_va.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_remove_model_sub_va.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_remove_model_sub_va.element_index=element_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_remove_model_sub_va.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_config_client_remove_model_sub_va.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_config_client_remove_model_sub_va.sub_address=sub_address;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_remove_model_sub_va_id+(((25)&0xff)<<8)+(((25)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_remove_model_sub_va;
}

/** 
*
* gecko_cmd_mesh_config_client_set_model_sub
*
* Set (overwrite) model subscription address list to a single address. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param element_index   Index of the element where the model to be configured resides on the node
* @param vendor_id   Vendor ID for the model to configure. Use 0xFFFF for Bluetooth SIG models.
* @param model_id   Model ID for the model to configure
* @param sub_address   The address to set as the subscription list
*
* Events generated
*
* gecko_evt_mesh_config_client_model_sub_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_set_model_sub_rsp_t* gecko_cmd_mesh_config_client_set_model_sub(uint16 enc_netkey_index,uint16 server_address,uint8 element_index,uint16 vendor_id,uint16 model_id,uint16 sub_address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_sub.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_sub.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_sub.element_index=element_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_sub.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_sub.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_sub.sub_address=sub_address;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_set_model_sub_id+(((11)&0xff)<<8)+(((11)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_set_model_sub;
}

/** 
*
* gecko_cmd_mesh_config_client_set_model_sub_va
*
* Set (overwrite) model subscription address list to a single virtual address. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param element_index   Index of the element where the model to be configured resides on the node
* @param vendor_id   Vendor ID for the model to configure. Use 0xFFFF for Bluetooth SIG models.
* @param model_id   Model ID for the model to configure
* @param sub_address   The full virtual address to set as the subscription list
*
* Events generated
*
* gecko_evt_mesh_config_client_model_sub_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_set_model_sub_va_rsp_t* gecko_cmd_mesh_config_client_set_model_sub_va(uint16 enc_netkey_index,uint16 server_address,uint8 element_index,uint16 vendor_id,uint16 model_id,uuid_128 sub_address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_sub_va.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_sub_va.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_sub_va.element_index=element_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_sub_va.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_sub_va.model_id=model_id;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_model_sub_va.sub_address=sub_address;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_set_model_sub_va_id+(((25)&0xff)<<8)+(((25)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_set_model_sub_va;
}

/** 
*
* gecko_cmd_mesh_config_client_clear_model_sub
*
* Clear (empty) the model subscription address list. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param element_index   Index of the element where the model to be configured resides on the node
* @param vendor_id   Vendor ID for the model to configure. Use 0xFFFF for Bluetooth SIG models.
* @param model_id   Model ID for the model to configure
*
* Events generated
*
* gecko_evt_mesh_config_client_model_sub_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_clear_model_sub_rsp_t* gecko_cmd_mesh_config_client_clear_model_sub(uint16 enc_netkey_index,uint16 server_address,uint8 element_index,uint16 vendor_id,uint16 model_id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_clear_model_sub.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_clear_model_sub.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_clear_model_sub.element_index=element_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_clear_model_sub.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_config_client_clear_model_sub.model_id=model_id;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_clear_model_sub_id+(((9)&0xff)<<8)+(((9)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_clear_model_sub;
}

/** 
*
* gecko_cmd_mesh_config_client_list_subs
*
* Get the subscription address list of a model. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param element_index   Index of the element where the model to be queried resides on the node
* @param vendor_id   Vendor ID for the model to query. Use 0xFFFF for Bluetooth SIG models.
* @param model_id   Model ID for the model to query
*
* Events generated
*
* gecko_evt_mesh_config_client_subs_list - 
* gecko_evt_mesh_config_client_subs_list_end - 
*
**/

static inline struct gecko_msg_mesh_config_client_list_subs_rsp_t* gecko_cmd_mesh_config_client_list_subs(uint16 enc_netkey_index,uint16 server_address,uint8 element_index,uint16 vendor_id,uint16 model_id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_list_subs.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_list_subs.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_list_subs.element_index=element_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_list_subs.vendor_id=vendor_id;
    gecko_cmd_msg->data.cmd_mesh_config_client_list_subs.model_id=model_id;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_list_subs_id+(((9)&0xff)<<8)+(((9)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_list_subs;
}

/** 
*
* gecko_cmd_mesh_config_client_get_heartbeat_pub
*
* Get the heartbeat publication state of a node. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
*
* Events generated
*
* gecko_evt_mesh_config_client_heartbeat_pub_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_get_heartbeat_pub_rsp_t* gecko_cmd_mesh_config_client_get_heartbeat_pub(uint16 enc_netkey_index,uint16 server_address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_get_heartbeat_pub.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_get_heartbeat_pub.server_address=server_address;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_get_heartbeat_pub_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_get_heartbeat_pub;
}

/** 
*
* gecko_cmd_mesh_config_client_set_heartbeat_pub
*
* Set the heartbeat publication state of a node. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param destination_address   Heartbeat publication destination address. The address can't be a virtual
*  address. Note that it can be the unassigned address, in which case the
*  heartbeat publishing is disabled.
* @param netkey_index   Index of the network key used to encrypt heartbeat messages
* @param count_log   Heartbeat publication count logarithm-of-2 setting. Valid values are as
*  follows:  
*  
*      0x00: Heartbeat messages are not sent
*      0x01 .. 0x11: Node will send 2^(n-1) heartbeat messages
*      0x12 .. 0xfe: Prohibited
*      0xff: Hearbeat messages are sent indefinitely
* @param period_log   Heartbeat publication period logarithm-of-2 setting. Valid values are as
*  follows:  
*  
*      0x00: Heartbeat messages are not sent
*      0x01 .. 0x11: Node will send a heartbeat message every 2^(n-1) seconds
*      0x12 .. 0xff: Prohibited
* @param ttl   Time-to-live value for heartbeat messages
* @param features   Heartbeat trigger setting. For bits set in the bitmask, reconfiguration of the
*  node feature associated with the bit will result in the node emitting a
*  heartbeat message. Valid values are as follows:
*  
*      Bit 0: Relay feature
*      Bit 1: Proxy feature
*      Bit 2: Friend feature
*      Bit 3: Low power feature
*  
*  Remaining bits are reserved for future use.
*
* Events generated
*
* gecko_evt_mesh_config_client_heartbeat_pub_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_set_heartbeat_pub_rsp_t* gecko_cmd_mesh_config_client_set_heartbeat_pub(uint16 enc_netkey_index,uint16 server_address,uint16 destination_address,uint16 netkey_index,uint8 count_log,uint8 period_log,uint8 ttl,uint16 features)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_set_heartbeat_pub.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_heartbeat_pub.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_heartbeat_pub.destination_address=destination_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_heartbeat_pub.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_heartbeat_pub.count_log=count_log;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_heartbeat_pub.period_log=period_log;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_heartbeat_pub.ttl=ttl;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_heartbeat_pub.features=features;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_set_heartbeat_pub_id+(((13)&0xff)<<8)+(((13)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_set_heartbeat_pub;
}

/** 
*
* gecko_cmd_mesh_config_client_get_heartbeat_sub
*
* Get the heartbeat subscription state of a node. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
*
* Events generated
*
* gecko_evt_mesh_config_client_heartbeat_sub_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_get_heartbeat_sub_rsp_t* gecko_cmd_mesh_config_client_get_heartbeat_sub(uint16 enc_netkey_index,uint16 server_address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_get_heartbeat_sub.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_get_heartbeat_sub.server_address=server_address;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_get_heartbeat_sub_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_get_heartbeat_sub;
}

/** 
*
* gecko_cmd_mesh_config_client_set_heartbeat_sub
*
* Set the heartbeat subscription state of a node. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param source_address   Source address for heartbeat messages, which must be either a unicast address
*  or the unassigned address, in which case heartbeat messages are not processed.
* @param destination_address   Destination address for heartbeat messages. The address must be either the
*  unicast address of the primary element of the node, a group address, or the
*  unassigned address. If it is the unassigned address, heartbeat messages are
*  not processed.
* @param period_log   Heartbeat subscription period logarithm-of-2 setting. Valid values are as
*  follows:  
*  
*      0x00: Heartbeat messages are not received
*      0x01 .. 0x11: Node will receive heartbeat messages for 2^(n-1) seconds
*      0x12 .. 0xff: Prohibited
*
* Events generated
*
* gecko_evt_mesh_config_client_heartbeat_sub_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_set_heartbeat_sub_rsp_t* gecko_cmd_mesh_config_client_set_heartbeat_sub(uint16 enc_netkey_index,uint16 server_address,uint16 source_address,uint16 destination_address,uint8 period_log)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_set_heartbeat_sub.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_heartbeat_sub.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_heartbeat_sub.source_address=source_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_heartbeat_sub.destination_address=destination_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_heartbeat_sub.period_log=period_log;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_set_heartbeat_sub_id+(((9)&0xff)<<8)+(((9)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_set_heartbeat_sub;
}

/** 
*
* gecko_cmd_mesh_config_client_get_beacon
*
* Get node secure network beacon state. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
*
* Events generated
*
* gecko_evt_mesh_config_client_beacon_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_get_beacon_rsp_t* gecko_cmd_mesh_config_client_get_beacon(uint16 enc_netkey_index,uint16 server_address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_get_beacon.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_get_beacon.server_address=server_address;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_get_beacon_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_get_beacon;
}

/** 
*
* gecko_cmd_mesh_config_client_set_beacon
*
* Set node secure network beacon state. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param value   Secure network beacon value to set. Valid values are:
*  
*      0: Node is not broadcasting secure network beacons
*      1: Node is broadcasting secure network beacons
*
* Events generated
*
* gecko_evt_mesh_config_client_beacon_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_set_beacon_rsp_t* gecko_cmd_mesh_config_client_set_beacon(uint16 enc_netkey_index,uint16 server_address,uint8 value)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_set_beacon.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_beacon.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_beacon.value=value;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_set_beacon_id+(((5)&0xff)<<8)+(((5)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_set_beacon;
}

/** 
*
* gecko_cmd_mesh_config_client_get_default_ttl
*
* Get node default TTL state. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
*
* Events generated
*
* gecko_evt_mesh_config_client_default_ttl_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_get_default_ttl_rsp_t* gecko_cmd_mesh_config_client_get_default_ttl(uint16 enc_netkey_index,uint16 server_address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_get_default_ttl.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_get_default_ttl.server_address=server_address;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_get_default_ttl_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_get_default_ttl;
}

/** 
*
* gecko_cmd_mesh_config_client_set_default_ttl
*
* Set node default TTL state. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param value   Default TTL value. Valid value range is from 2 to 127 for relayed PDUs, and 0
*  to indicate non-relayed PDUs
*
* Events generated
*
* gecko_evt_mesh_config_client_default_ttl_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_set_default_ttl_rsp_t* gecko_cmd_mesh_config_client_set_default_ttl(uint16 enc_netkey_index,uint16 server_address,uint8 value)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_set_default_ttl.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_default_ttl.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_default_ttl.value=value;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_set_default_ttl_id+(((5)&0xff)<<8)+(((5)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_set_default_ttl;
}

/** 
*
* gecko_cmd_mesh_config_client_get_gatt_proxy
*
* Get node GATT proxy state. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
*
* Events generated
*
* gecko_evt_mesh_config_client_gatt_proxy_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_get_gatt_proxy_rsp_t* gecko_cmd_mesh_config_client_get_gatt_proxy(uint16 enc_netkey_index,uint16 server_address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_get_gatt_proxy.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_get_gatt_proxy.server_address=server_address;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_get_gatt_proxy_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_get_gatt_proxy;
}

/** 
*
* gecko_cmd_mesh_config_client_set_gatt_proxy
*
* Set node GATT proxy state. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param value   GATT proxy value to set. Valid values are:
*  
*      0: Proxy feature is disabled
*      1: Proxy feature is enabled
*
* Events generated
*
* gecko_evt_mesh_config_client_gatt_proxy_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_set_gatt_proxy_rsp_t* gecko_cmd_mesh_config_client_set_gatt_proxy(uint16 enc_netkey_index,uint16 server_address,uint8 value)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_set_gatt_proxy.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_gatt_proxy.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_gatt_proxy.value=value;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_set_gatt_proxy_id+(((5)&0xff)<<8)+(((5)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_set_gatt_proxy;
}

/** 
*
* gecko_cmd_mesh_config_client_get_relay
*
* Get node relay state. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
*
* Events generated
*
* gecko_evt_mesh_config_client_relay_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_get_relay_rsp_t* gecko_cmd_mesh_config_client_get_relay(uint16 enc_netkey_index,uint16 server_address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_get_relay.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_get_relay.server_address=server_address;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_get_relay_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_get_relay;
}

/** 
*
* gecko_cmd_mesh_config_client_set_relay
*
* Set node relay state. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param value   Relay value to set. Valid values are:
*  
*      0: Relay feature is disabled
*      1: Relay feature is enabled
* @param retransmit_count   Relay retransmit count. Valid values range from 0 to 7; default value is 0 (no
*  retransmissions).
* @param retransmit_interval_ms   Relay retransmit interval in milliseconds. Valid values range from 10 ms to
*  320 ms, with a resolution of 10 ms. Value is ignored if retransmission count
*  is set to zero.
*
* Events generated
*
* gecko_evt_mesh_config_client_relay_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_set_relay_rsp_t* gecko_cmd_mesh_config_client_set_relay(uint16 enc_netkey_index,uint16 server_address,uint8 value,uint8 retransmit_count,uint16 retransmit_interval_ms)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_set_relay.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_relay.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_relay.value=value;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_relay.retransmit_count=retransmit_count;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_relay.retransmit_interval_ms=retransmit_interval_ms;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_set_relay_id+(((8)&0xff)<<8)+(((8)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_set_relay;
}

/** 
*
* gecko_cmd_mesh_config_client_get_network_transmit
*
* Get node network transmit state. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
*
* Events generated
*
* gecko_evt_mesh_config_client_network_transmit_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_get_network_transmit_rsp_t* gecko_cmd_mesh_config_client_get_network_transmit(uint16 enc_netkey_index,uint16 server_address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_get_network_transmit.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_get_network_transmit.server_address=server_address;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_get_network_transmit_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_get_network_transmit;
}

/** 
*
* gecko_cmd_mesh_config_client_set_network_transmit
*
* Set node network transmit state. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param transmit_count   Network transmit count. Valid values range from 1 to 8; default value is 1
*  (single transmission; no retransmissions).
* @param transmit_interval_ms   Network transmit interval in milliseconds. Valid values range from 10 ms to
*  320 ms, with a resolution of 10 ms. Value is ignored if the transmission count
*  is set to one.
*
* Events generated
*
* gecko_evt_mesh_config_client_network_transmit_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_set_network_transmit_rsp_t* gecko_cmd_mesh_config_client_set_network_transmit(uint16 enc_netkey_index,uint16 server_address,uint8 transmit_count,uint16 transmit_interval_ms)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_set_network_transmit.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_network_transmit.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_network_transmit.transmit_count=transmit_count;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_network_transmit.transmit_interval_ms=transmit_interval_ms;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_set_network_transmit_id+(((7)&0xff)<<8)+(((7)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_set_network_transmit;
}

/** 
*
* gecko_cmd_mesh_config_client_get_identity
*
* Get node identity state. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param netkey_index   Network key index for which the state is queried
*
* Events generated
*
* gecko_evt_mesh_config_client_identity_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_get_identity_rsp_t* gecko_cmd_mesh_config_client_get_identity(uint16 enc_netkey_index,uint16 server_address,uint16 netkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_get_identity.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_get_identity.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_get_identity.netkey_index=netkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_get_identity_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_get_identity;
}

/** 
*
* gecko_cmd_mesh_config_client_set_identity
*
* Set node identity state. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param netkey_index   Network key index for which the state is configured
* @param value   Identity value to set. Valid values are:
*  
*      0: Node identity advertising is disabled
*      1: Node identity advertising is enabled
*
* Events generated
*
* gecko_evt_mesh_config_client_identity_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_set_identity_rsp_t* gecko_cmd_mesh_config_client_set_identity(uint16 enc_netkey_index,uint16 server_address,uint16 netkey_index,uint8 value)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_set_identity.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_identity.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_identity.netkey_index=netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_identity.value=value;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_set_identity_id+(((7)&0xff)<<8)+(((7)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_set_identity;
}

/** 
*
* gecko_cmd_mesh_config_client_get_friend
*
* Get node friend state. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
*
* Events generated
*
* gecko_evt_mesh_config_client_friend_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_get_friend_rsp_t* gecko_cmd_mesh_config_client_get_friend(uint16 enc_netkey_index,uint16 server_address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_get_friend.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_get_friend.server_address=server_address;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_get_friend_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_get_friend;
}

/** 
*
* gecko_cmd_mesh_config_client_set_friend
*
* Set node friend state. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param value   Friend value to set. Valid values are:
*  
*      0: Friend feature is not enabled
*      1: Friend feature is enabled
*
* Events generated
*
* gecko_evt_mesh_config_client_friend_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_set_friend_rsp_t* gecko_cmd_mesh_config_client_set_friend(uint16 enc_netkey_index,uint16 server_address,uint8 value)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_set_friend.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_friend.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_set_friend.value=value;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_set_friend_id+(((5)&0xff)<<8)+(((5)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_set_friend;
}

/** 
*
* gecko_cmd_mesh_config_client_get_lpn_polltimeout
*
* Get the LPN poll timeout from a Friend node. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param lpn_address   LPN address
*
* Events generated
*
* gecko_evt_mesh_config_client_lpn_polltimeout_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_get_lpn_polltimeout_rsp_t* gecko_cmd_mesh_config_client_get_lpn_polltimeout(uint16 enc_netkey_index,uint16 server_address,uint16 lpn_address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_get_lpn_polltimeout.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_get_lpn_polltimeout.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_get_lpn_polltimeout.lpn_address=lpn_address;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_get_lpn_polltimeout_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_get_lpn_polltimeout;
}

/** 
*
* gecko_cmd_mesh_config_client_get_dcd
*
* Get composition data of a device. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
* @param page   Composition data page to query
*
* Events generated
*
* gecko_evt_mesh_config_client_dcd_data - 
* gecko_evt_mesh_config_client_dcd_data_end - 
*
**/

static inline struct gecko_msg_mesh_config_client_get_dcd_rsp_t* gecko_cmd_mesh_config_client_get_dcd(uint16 enc_netkey_index,uint16 server_address,uint8 page)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_get_dcd.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_get_dcd.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_config_client_get_dcd.page=page;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_get_dcd_id+(((5)&0xff)<<8)+(((5)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_get_dcd;
}

/** 
*
* gecko_cmd_mesh_config_client_reset_node
*
* Request a node to unprovision itself. Use when a node is removed from the
* network. 
*
* @param enc_netkey_index   Network key used to encrypt the request on the network layer
* @param server_address   Destination node primary element address
*
* Events generated
*
* gecko_evt_mesh_config_client_reset_status - 
*
**/

static inline struct gecko_msg_mesh_config_client_reset_node_rsp_t* gecko_cmd_mesh_config_client_reset_node(uint16 enc_netkey_index,uint16 server_address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_config_client_reset_node.enc_netkey_index=enc_netkey_index;
    gecko_cmd_msg->data.cmd_mesh_config_client_reset_node.server_address=server_address;
    gecko_cmd_msg->header=(gecko_cmd_mesh_config_client_reset_node_id+(((4)&0xff)<<8)+(((4)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_config_client_reset_node;
}

/** 
*
* gecko_cmd_l2cap_coc_send_connection_request
*
* Send LE credit-based connection request. 
*
* @param connection   Handle of the LE connection to be used for opening connection-oriented
*  channel.
* @param le_psm   LE Protocol/Service Multiplexer - LE_PSM
* @param mtu   The maximum size of payload data that the application on the device sending
*  the request can accept, i.e., the MTU corresponds to the maximum SDU size.
*  
*  Range: 23 to 65533.
*  
*  Application needs to handle segmentation and reassembly from PDU to SDU.
* @param mps   The maximum size of payload data that the L2CAP layer on the device sending
*  the request can accept, i.e., the MPS corresponds to the maximum PDU payload
*  size.
*  
*  Range: 23 to 250.
*  
*  That is the maximum size of data that the application can send using
*  l2cap_coc_send_data command or receive by l2cap_coc_data event.
* @param initial_credit   The initial credit value indicates the number of PDUs that the peer device can
*  send.
*
* Events generated
*
* gecko_evt_l2cap_coc_connection_response - Triggered when a LE credit-based connection connection response has been
*  received in response to this command.
* gecko_evt_l2cap_coc_channel_disconnected - Triggered when a LE credit-based connection connection response has not been
*  received within the 30 seconds timeout in response to this command.
*
**/

static inline struct gecko_msg_l2cap_coc_send_connection_request_rsp_t* gecko_cmd_l2cap_coc_send_connection_request(uint8 connection,uint16 le_psm,uint16 mtu,uint16 mps,uint16 initial_credit)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_l2cap_coc_send_connection_request.connection=connection;
    gecko_cmd_msg->data.cmd_l2cap_coc_send_connection_request.le_psm=le_psm;
    gecko_cmd_msg->data.cmd_l2cap_coc_send_connection_request.mtu=mtu;
    gecko_cmd_msg->data.cmd_l2cap_coc_send_connection_request.mps=mps;
    gecko_cmd_msg->data.cmd_l2cap_coc_send_connection_request.initial_credit=initial_credit;
    gecko_cmd_msg->header=(gecko_cmd_l2cap_coc_send_connection_request_id+(((9)&0xff)<<8)+(((9)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_l2cap_coc_send_connection_request;
}

/** 
*
* gecko_cmd_l2cap_coc_send_connection_response
*
* Send LE credit-based connection response. 
*
* @param connection   Handle of the LE connection to be used for opening connection-oriented channel
* @param cid   The CID represents the destination channel endpoint of the device sending the
*  response which is same as source CID field of corresponding request message
* @param mtu   The maximum size of payload data that the application on the device sending
*  the response can accept, i.e., the MTU corresponds to the maximum SDU size.
*  
*  Range: 23 to 65533.
*  
*  Application needs to handle segmentation and reassembly from PDU to SDU.
* @param mps   The maximum size of payload data that the L2CAP layer on the device sending
*  the response can accept, i.e., the MPS corresponds to the maximum PDU payload
*  size.
*  
*  Range: 23 to 250.
*  
*  That is the maximum size of data that the application is able to send using
*  l2cap_coc_send_data command or receive by l2cap_coc_data event.
* @param initial_credit   The initial credit value indicates the number of PDUs that the peer device can
*  send
* @param result   The result field indicates the outcome of the connection request.
*
**/

static inline struct gecko_msg_l2cap_coc_send_connection_response_rsp_t* gecko_cmd_l2cap_coc_send_connection_response(uint8 connection,uint16 cid,uint16 mtu,uint16 mps,uint16 initial_credit,uint16 result)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_l2cap_coc_send_connection_response.connection=connection;
    gecko_cmd_msg->data.cmd_l2cap_coc_send_connection_response.cid=cid;
    gecko_cmd_msg->data.cmd_l2cap_coc_send_connection_response.mtu=mtu;
    gecko_cmd_msg->data.cmd_l2cap_coc_send_connection_response.mps=mps;
    gecko_cmd_msg->data.cmd_l2cap_coc_send_connection_response.initial_credit=initial_credit;
    gecko_cmd_msg->data.cmd_l2cap_coc_send_connection_response.result=result;
    gecko_cmd_msg->header=(gecko_cmd_l2cap_coc_send_connection_response_id+(((11)&0xff)<<8)+(((11)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_l2cap_coc_send_connection_response;
}

/** 
*
* gecko_cmd_l2cap_coc_send_le_flow_control_credit
*
* Send LE flow control credit indicating that the channel endpoint on local
* device is capable of receiving more data. 
*
* @param connection   Handle of the LE connection for sending flow control credit.
* @param cid   The CID represents the destination channel endpoint of the device sending the
*  flow control credit.
* @param credits   The credit value indicates the additional number of PDUs that the peer device
*  can send.
*
**/

static inline struct gecko_msg_l2cap_coc_send_le_flow_control_credit_rsp_t* gecko_cmd_l2cap_coc_send_le_flow_control_credit(uint8 connection,uint16 cid,uint16 credits)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_l2cap_coc_send_le_flow_control_credit.connection=connection;
    gecko_cmd_msg->data.cmd_l2cap_coc_send_le_flow_control_credit.cid=cid;
    gecko_cmd_msg->data.cmd_l2cap_coc_send_le_flow_control_credit.credits=credits;
    gecko_cmd_msg->header=(gecko_cmd_l2cap_coc_send_le_flow_control_credit_id+(((5)&0xff)<<8)+(((5)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_l2cap_coc_send_le_flow_control_credit;
}

/** 
*
* gecko_cmd_l2cap_coc_send_disconnection_request
*
* Send L2CAP connection-oriented channel disconnection request. 
*
* @param connection   Handle of the LE connection for terminating the connection-oriented channel
* @param cid   The CID represents the destination channel endpoint of the device sending the
*  disconnection request.
*
* Events generated
*
* gecko_evt_l2cap_coc_channel_disconnected - Triggered when a L2CAP channel is disconnected in response to this command.
*
**/

static inline struct gecko_msg_l2cap_coc_send_disconnection_request_rsp_t* gecko_cmd_l2cap_coc_send_disconnection_request(uint8 connection,uint16 cid)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_l2cap_coc_send_disconnection_request.connection=connection;
    gecko_cmd_msg->data.cmd_l2cap_coc_send_disconnection_request.cid=cid;
    gecko_cmd_msg->header=(gecko_cmd_l2cap_coc_send_disconnection_request_id+(((3)&0xff)<<8)+(((3)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_l2cap_coc_send_disconnection_request;
}

/** 
*
* gecko_cmd_l2cap_coc_send_data
*
* Send data to a L2CAP LE connection-oriented channel. 
*
* @param connection   Handle of the LE connection for sending data
* @param cid   The CID represents the destination channel endpoint of the device sending
*  data.
* @param data_len   Array length
* @param data_data   Data to be sent. Data length must be within the range of destination channel
*  endpoint's MPS value.
*
**/

static inline struct gecko_msg_l2cap_coc_send_data_rsp_t* gecko_cmd_l2cap_coc_send_data(uint8 connection,uint16 cid,uint8 data_len, const uint8* data_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)data_len > 256 - 4)
    {
        gecko_rsp_msg->data.rsp_l2cap_coc_send_data.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_l2cap_coc_send_data;
    }

    
    gecko_cmd_msg->data.cmd_l2cap_coc_send_data.connection=connection;
    gecko_cmd_msg->data.cmd_l2cap_coc_send_data.cid=cid;
    gecko_cmd_msg->data.cmd_l2cap_coc_send_data.data.len=data_len;
    memcpy(gecko_cmd_msg->data.cmd_l2cap_coc_send_data.data.data,data_data,data_len);
    gecko_cmd_msg->header=(gecko_cmd_l2cap_coc_send_data_id+(((4+data_len)&0xff)<<8)+(((4+data_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_l2cap_coc_send_data;
}

/** 
*
* gecko_cmd_cte_transmitter_enable_connection_cte
*
* Enable different types of CTE responses on a connection. CTE response will be
* sent once requested by the peer device using the CTE Request procedure. 
*
* @param connection   Connection handle
* @param cte_types   CTE types. Bitmask of the following:
*  
*      Bit 0: AoA CTE response
*      Bit 1: AoD CTE response with 1 us slots
*      Bit 2: AoD CTE response with 2 us slots
* @param switching_pattern_len   Array length
* @param switching_pattern_data   Antenna switching pattern. Antennas will be switched in this order with the
*  antenna switch pins during CTE. If the CTE is longer than the switching
*  pattern, the pattern starts over.
*
**/

static inline struct gecko_msg_cte_transmitter_enable_connection_cte_rsp_t* gecko_cmd_cte_transmitter_enable_connection_cte(uint8 connection,uint8 cte_types,uint8 switching_pattern_len, const uint8* switching_pattern_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)switching_pattern_len > 256 - 3)
    {
        gecko_rsp_msg->data.rsp_cte_transmitter_enable_connection_cte.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_cte_transmitter_enable_connection_cte;
    }

    
    gecko_cmd_msg->data.cmd_cte_transmitter_enable_connection_cte.connection=connection;
    gecko_cmd_msg->data.cmd_cte_transmitter_enable_connection_cte.cte_types=cte_types;
    gecko_cmd_msg->data.cmd_cte_transmitter_enable_connection_cte.switching_pattern.len=switching_pattern_len;
    memcpy(gecko_cmd_msg->data.cmd_cte_transmitter_enable_connection_cte.switching_pattern.data,switching_pattern_data,switching_pattern_len);
    gecko_cmd_msg->header=(gecko_cmd_cte_transmitter_enable_connection_cte_id+(((3+switching_pattern_len)&0xff)<<8)+(((3+switching_pattern_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_cte_transmitter_enable_connection_cte;
}

/** 
*
* gecko_cmd_cte_transmitter_disable_connection_cte
*
* Disable CTE responses on a connection. 
*
* @param connection   Connection handle
*
**/

static inline struct gecko_msg_cte_transmitter_disable_connection_cte_rsp_t* gecko_cmd_cte_transmitter_disable_connection_cte(uint8 connection)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_cte_transmitter_disable_connection_cte.connection=connection;
    gecko_cmd_msg->header=(gecko_cmd_cte_transmitter_disable_connection_cte_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_cte_transmitter_disable_connection_cte;
}

/** 
*
* gecko_cmd_cte_transmitter_enable_connectionless_cte
*
* Start connectionless CTE transmit. CTEs will be transmitted in periodic
* advertisement packets. As a result, a periodic advertising has to be started
* prior this command. 
*
* @param handle   Periodic advertising handle
* @param cte_length   CTE length in 8 us units.
*  
*      Range: 0x02 to 0x14
*      Time Range: 16 us to 160 us
* @param cte_type   CTE type
*  
*      0: AoA CTE
*      1: AoD CTE with 1 us slots
*      2: AoD CTE with 2 us slots
* @param cte_count   The number of CTEs to be transmitted in each periodic advertising interval
* @param switching_pattern_len   Array length
* @param switching_pattern_data   Antenna switching pattern. Antennas will be switched in this order with the
*  antenna switch pins during CTE. If the CTE is longer than the switching
*  pattern, the pattern starts over.
*
**/

static inline struct gecko_msg_cte_transmitter_enable_connectionless_cte_rsp_t* gecko_cmd_cte_transmitter_enable_connectionless_cte(uint8 handle,uint8 cte_length,uint8 cte_type,uint8 cte_count,uint8 switching_pattern_len, const uint8* switching_pattern_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)switching_pattern_len > 256 - 5)
    {
        gecko_rsp_msg->data.rsp_cte_transmitter_enable_connectionless_cte.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_cte_transmitter_enable_connectionless_cte;
    }

    
    gecko_cmd_msg->data.cmd_cte_transmitter_enable_connectionless_cte.handle=handle;
    gecko_cmd_msg->data.cmd_cte_transmitter_enable_connectionless_cte.cte_length=cte_length;
    gecko_cmd_msg->data.cmd_cte_transmitter_enable_connectionless_cte.cte_type=cte_type;
    gecko_cmd_msg->data.cmd_cte_transmitter_enable_connectionless_cte.cte_count=cte_count;
    gecko_cmd_msg->data.cmd_cte_transmitter_enable_connectionless_cte.switching_pattern.len=switching_pattern_len;
    memcpy(gecko_cmd_msg->data.cmd_cte_transmitter_enable_connectionless_cte.switching_pattern.data,switching_pattern_data,switching_pattern_len);
    gecko_cmd_msg->header=(gecko_cmd_cte_transmitter_enable_connectionless_cte_id+(((5+switching_pattern_len)&0xff)<<8)+(((5+switching_pattern_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_cte_transmitter_enable_connectionless_cte;
}

/** 
*
* gecko_cmd_cte_transmitter_disable_connectionless_cte
*
* Stop the connectionless CTE transmit. 
*
* @param handle   Periodic advertising handle
*
**/

static inline struct gecko_msg_cte_transmitter_disable_connectionless_cte_rsp_t* gecko_cmd_cte_transmitter_disable_connectionless_cte(uint8 handle)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_cte_transmitter_disable_connectionless_cte.handle=handle;
    gecko_cmd_msg->header=(gecko_cmd_cte_transmitter_disable_connectionless_cte_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_cte_transmitter_disable_connectionless_cte;
}

/** 
*
* gecko_cmd_cte_transmitter_set_dtm_parameters
*
* Set the CTE-related parameters of the LE transmitter test. 
*
* @param cte_length   Length of the Constant Tone Extension in 8 us units
*  
*      0: No CTE
*      0x02 to 0x14: CTE length
*  
*  Default: 0 (no CTE)
* @param cte_type   CTE type
*  
*      0: AoA CTE
*      1: AoD CTE with 1 us slots
*      2: AoD CTE with 2 us slots
*  
*  Default: 0
* @param switching_pattern_len   Array length
* @param switching_pattern_data   Antenna switching pattern. Antennas will be switched in this order with the
*  antenna switch pins during CTE. If the CTE is longer than the switching
*  pattern, the pattern starts over. Default is the empty array.
*
**/

static inline struct gecko_msg_cte_transmitter_set_dtm_parameters_rsp_t* gecko_cmd_cte_transmitter_set_dtm_parameters(uint8 cte_length,uint8 cte_type,uint8 switching_pattern_len, const uint8* switching_pattern_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)switching_pattern_len > 256 - 3)
    {
        gecko_rsp_msg->data.rsp_cte_transmitter_set_dtm_parameters.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_cte_transmitter_set_dtm_parameters;
    }

    
    gecko_cmd_msg->data.cmd_cte_transmitter_set_dtm_parameters.cte_length=cte_length;
    gecko_cmd_msg->data.cmd_cte_transmitter_set_dtm_parameters.cte_type=cte_type;
    gecko_cmd_msg->data.cmd_cte_transmitter_set_dtm_parameters.switching_pattern.len=switching_pattern_len;
    memcpy(gecko_cmd_msg->data.cmd_cte_transmitter_set_dtm_parameters.switching_pattern.data,switching_pattern_data,switching_pattern_len);
    gecko_cmd_msg->header=(gecko_cmd_cte_transmitter_set_dtm_parameters_id+(((3+switching_pattern_len)&0xff)<<8)+(((3+switching_pattern_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_cte_transmitter_set_dtm_parameters;
}

/** 
*
* gecko_cmd_cte_transmitter_clear_dtm_parameters
*
* Clear CTE-related parameters that were previously set for LE transmitter test.
* Default values will be restored for these parameters. 
*
*
**/

static inline struct gecko_msg_cte_transmitter_clear_dtm_parameters_rsp_t* gecko_cmd_cte_transmitter_clear_dtm_parameters()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_cte_transmitter_clear_dtm_parameters_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_cte_transmitter_clear_dtm_parameters;
}

/** 
*
* gecko_cmd_cte_transmitter_enable_silabs_cte
*
* Enable Silicon Labs CTE transmit. CTEs will be transmitted in extended
* advertisement packets. As a result, extended advertising has to be started
* prior this command. 
*
* @param handle   Advertising handle
* @param cte_length   CTE length in 8 us units.
*  
*      Range: 0x02 to 0x14
*      Time Range: 16 us to 160 us
* @param cte_type   CTE type
*  
*      0: AoA CTE
*      1: AoD CTE with 1 us slots
*      2: AoD CTE with 2 us slots
* @param cte_count   The number of CTEs to be transmitted in each extended advertising interval.
*  Currently only cte_count = 1 is supported.
* @param switching_pattern_len   Array length
* @param switching_pattern_data   Antenna switching pattern. Antennas will be switched in this order with the
*  antenna switch pins during CTE. If the CTE is longer than the switching
*  pattern, the pattern starts over.
*
**/

static inline struct gecko_msg_cte_transmitter_enable_silabs_cte_rsp_t* gecko_cmd_cte_transmitter_enable_silabs_cte(uint8 handle,uint8 cte_length,uint8 cte_type,uint8 cte_count,uint8 switching_pattern_len, const uint8* switching_pattern_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)switching_pattern_len > 256 - 5)
    {
        gecko_rsp_msg->data.rsp_cte_transmitter_enable_silabs_cte.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_cte_transmitter_enable_silabs_cte;
    }

    
    gecko_cmd_msg->data.cmd_cte_transmitter_enable_silabs_cte.handle=handle;
    gecko_cmd_msg->data.cmd_cte_transmitter_enable_silabs_cte.cte_length=cte_length;
    gecko_cmd_msg->data.cmd_cte_transmitter_enable_silabs_cte.cte_type=cte_type;
    gecko_cmd_msg->data.cmd_cte_transmitter_enable_silabs_cte.cte_count=cte_count;
    gecko_cmd_msg->data.cmd_cte_transmitter_enable_silabs_cte.switching_pattern.len=switching_pattern_len;
    memcpy(gecko_cmd_msg->data.cmd_cte_transmitter_enable_silabs_cte.switching_pattern.data,switching_pattern_data,switching_pattern_len);
    gecko_cmd_msg->header=(gecko_cmd_cte_transmitter_enable_silabs_cte_id+(((5+switching_pattern_len)&0xff)<<8)+(((5+switching_pattern_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_cte_transmitter_enable_silabs_cte;
}

/** 
*
* gecko_cmd_cte_transmitter_disable_silabs_cte
*
* Disable Silicon Labs CTE transmit. 
*
* @param handle   Advertising handle
*
**/

static inline struct gecko_msg_cte_transmitter_disable_silabs_cte_rsp_t* gecko_cmd_cte_transmitter_disable_silabs_cte(uint8 handle)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_cte_transmitter_disable_silabs_cte.handle=handle;
    gecko_cmd_msg->header=(gecko_cmd_cte_transmitter_disable_silabs_cte_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_cte_transmitter_disable_silabs_cte;
}

/** 
*
* gecko_cmd_cte_receiver_configure
*
* Configure the CTE sampling mode. 
*
* @param flags   Values:
*  
*      0: Disable raw sample mode, only picked IQ samples are reported (1 IQ sample pair / slot)
*      1: Enable raw sample mode, every IQ sample is reported.
*  
*  Default: 0
*
**/

static inline struct gecko_msg_cte_receiver_configure_rsp_t* gecko_cmd_cte_receiver_configure(uint8 flags)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_cte_receiver_configure.flags=flags;
    gecko_cmd_msg->header=(gecko_cmd_cte_receiver_configure_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_cte_receiver_configure;
}

/** 
*
* gecko_cmd_cte_receiver_enable_connection_cte
*
* Start IQ samplings on a connection. A CTE requests will be initiated
* periodically on the given connection and IQ sampling will be made on the
* received CTE responses. 
*
* @param connection   Connection handle
* @param interval   Measurement interval
*  
*      0: No interval. The request is initiated only once.
*      Other values N: Initiate the request every N-th connection events
* @param cte_length   Minimum CTE length requested in 8 us units.
*  
*      Range: 0x02 to 0x14
*      Time Range: 16 us to 160 us
* @param cte_type   Requested CTE type
*  
*      0: AoA CTE
*      1: AoD CTE with 1 us slots
*      2: AoD CTE with 2 us slots
* @param slot_durations   Slot durations
*  
*      1: Switching and sampling slots are 1 us each
*      2: Switching and sampling slots are 2 us each
* @param switching_pattern_len   Array length
* @param switching_pattern_data   Antenna switching pattern. Antennas will be switched in this order with the
*  antenna switch pins during CTE. If the CTE is longer than the switching
*  pattern, the pattern starts over.
*
* Events generated
*
* gecko_evt_cte_receiver_connection_iq_report - Triggered when IQ samples have been received.
*
**/

static inline struct gecko_msg_cte_receiver_enable_connection_cte_rsp_t* gecko_cmd_cte_receiver_enable_connection_cte(uint8 connection,uint16 interval,uint8 cte_length,uint8 cte_type,uint8 slot_durations,uint8 switching_pattern_len, const uint8* switching_pattern_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)switching_pattern_len > 256 - 7)
    {
        gecko_rsp_msg->data.rsp_cte_receiver_enable_connection_cte.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_cte_receiver_enable_connection_cte;
    }

    
    gecko_cmd_msg->data.cmd_cte_receiver_enable_connection_cte.connection=connection;
    gecko_cmd_msg->data.cmd_cte_receiver_enable_connection_cte.interval=interval;
    gecko_cmd_msg->data.cmd_cte_receiver_enable_connection_cte.cte_length=cte_length;
    gecko_cmd_msg->data.cmd_cte_receiver_enable_connection_cte.cte_type=cte_type;
    gecko_cmd_msg->data.cmd_cte_receiver_enable_connection_cte.slot_durations=slot_durations;
    gecko_cmd_msg->data.cmd_cte_receiver_enable_connection_cte.switching_pattern.len=switching_pattern_len;
    memcpy(gecko_cmd_msg->data.cmd_cte_receiver_enable_connection_cte.switching_pattern.data,switching_pattern_data,switching_pattern_len);
    gecko_cmd_msg->header=(gecko_cmd_cte_receiver_enable_connection_cte_id+(((7+switching_pattern_len)&0xff)<<8)+(((7+switching_pattern_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_cte_receiver_enable_connection_cte;
}

/** 
*
* gecko_cmd_cte_receiver_disable_connection_cte
*
* Stop the IQ sampling on a connection. CTEs will not be requested on the given
* connection. 
*
* @param connection   Connection handle
*
**/

static inline struct gecko_msg_cte_receiver_disable_connection_cte_rsp_t* gecko_cmd_cte_receiver_disable_connection_cte(uint8 connection)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_cte_receiver_disable_connection_cte.connection=connection;
    gecko_cmd_msg->header=(gecko_cmd_cte_receiver_disable_connection_cte_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_cte_receiver_disable_connection_cte;
}

/** 
*
* gecko_cmd_cte_receiver_enable_connectionless_cte
*
* Start IQ sampling on a periodic advertising synchronization. IQ samples are
* taken on each CTE found in the periodic advertisements. 
*
* @param sync   Periodic advertising synchronization handle
* @param slot_durations   Slot durations
*  
*      1: Switching and sampling slots are 1 us each
*      2: Switching and sampling slots are 2 us each
* @param cte_count   * 0: Sample and report all available CTEs
*      Other values: Maximum number of sampled CTEs in each periodic advertising interval
* @param switching_pattern_len   Array length
* @param switching_pattern_data   Antenna switching pattern. Antennas will be switched in this order with the
*  antenna switch pins during CTE. If the CTE is longer than the switching
*  pattern, the pattern starts over.
*
* Events generated
*
* gecko_evt_cte_receiver_connectionless_iq_report - Triggered when IQ samples have been received.
*
**/

static inline struct gecko_msg_cte_receiver_enable_connectionless_cte_rsp_t* gecko_cmd_cte_receiver_enable_connectionless_cte(uint8 sync,uint8 slot_durations,uint8 cte_count,uint8 switching_pattern_len, const uint8* switching_pattern_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)switching_pattern_len > 256 - 4)
    {
        gecko_rsp_msg->data.rsp_cte_receiver_enable_connectionless_cte.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_cte_receiver_enable_connectionless_cte;
    }

    
    gecko_cmd_msg->data.cmd_cte_receiver_enable_connectionless_cte.sync=sync;
    gecko_cmd_msg->data.cmd_cte_receiver_enable_connectionless_cte.slot_durations=slot_durations;
    gecko_cmd_msg->data.cmd_cte_receiver_enable_connectionless_cte.cte_count=cte_count;
    gecko_cmd_msg->data.cmd_cte_receiver_enable_connectionless_cte.switching_pattern.len=switching_pattern_len;
    memcpy(gecko_cmd_msg->data.cmd_cte_receiver_enable_connectionless_cte.switching_pattern.data,switching_pattern_data,switching_pattern_len);
    gecko_cmd_msg->header=(gecko_cmd_cte_receiver_enable_connectionless_cte_id+(((4+switching_pattern_len)&0xff)<<8)+(((4+switching_pattern_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_cte_receiver_enable_connectionless_cte;
}

/** 
*
* gecko_cmd_cte_receiver_disable_connectionless_cte
*
* Stop IQ sampling on a periodic advertising synchronization. 
*
* @param sync   Periodic advertising synchronization handle
*
**/

static inline struct gecko_msg_cte_receiver_disable_connectionless_cte_rsp_t* gecko_cmd_cte_receiver_disable_connectionless_cte(uint8 sync)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_cte_receiver_disable_connectionless_cte.sync=sync;
    gecko_cmd_msg->header=(gecko_cmd_cte_receiver_disable_connectionless_cte_id+(((1)&0xff)<<8)+(((1)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_cte_receiver_disable_connectionless_cte;
}

/** 
*
* gecko_cmd_cte_receiver_set_dtm_parameters
*
* Set CTE-related parameters of LE receiver test. 
*
* @param cte_length   Expected CTE length in 8 us units
*  
*      0: No CTE
*      0x02 to 0x14: Expected CTE length
*  
*  Default: 0 (no CTE)
* @param cte_type   Expected CTE type
*  
*      0: Expect AoA CTE
*      1: Expect AoD CTE with 1 us slots
*      2: Expect AoD CTE with 2 us slots
*  
*  Default: 0
* @param slot_durations   Slot durations
*  
*      1: Switching and sampling slots are 1 us each
*      2: Switching and sampling slots are 2 us each
*  
*  Default: 1
* @param switching_pattern_len   Array length
* @param switching_pattern_data   Antenna switching pattern. Antennas will be switched in this order with the
*  antenna switch pins during CTE. If the CTE is longer than the switching
*  pattern, the pattern starts over. Default: empty array
*
* Events generated
*
* gecko_evt_cte_receiver_dtm_iq_report - Triggered when IQ samples have been received.
*
**/

static inline struct gecko_msg_cte_receiver_set_dtm_parameters_rsp_t* gecko_cmd_cte_receiver_set_dtm_parameters(uint8 cte_length,uint8 cte_type,uint8 slot_durations,uint8 switching_pattern_len, const uint8* switching_pattern_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)switching_pattern_len > 256 - 4)
    {
        gecko_rsp_msg->data.rsp_cte_receiver_set_dtm_parameters.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_cte_receiver_set_dtm_parameters;
    }

    
    gecko_cmd_msg->data.cmd_cte_receiver_set_dtm_parameters.cte_length=cte_length;
    gecko_cmd_msg->data.cmd_cte_receiver_set_dtm_parameters.cte_type=cte_type;
    gecko_cmd_msg->data.cmd_cte_receiver_set_dtm_parameters.slot_durations=slot_durations;
    gecko_cmd_msg->data.cmd_cte_receiver_set_dtm_parameters.switching_pattern.len=switching_pattern_len;
    memcpy(gecko_cmd_msg->data.cmd_cte_receiver_set_dtm_parameters.switching_pattern.data,switching_pattern_data,switching_pattern_len);
    gecko_cmd_msg->header=(gecko_cmd_cte_receiver_set_dtm_parameters_id+(((4+switching_pattern_len)&0xff)<<8)+(((4+switching_pattern_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_cte_receiver_set_dtm_parameters;
}

/** 
*
* gecko_cmd_cte_receiver_clear_dtm_parameters
*
* Clear CTE-related parameters that were previously set for LE receiver test.
* Default values will be restored for these parameters. 
*
*
**/

static inline struct gecko_msg_cte_receiver_clear_dtm_parameters_rsp_t* gecko_cmd_cte_receiver_clear_dtm_parameters()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_cte_receiver_clear_dtm_parameters_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_cte_receiver_clear_dtm_parameters;
}

/** 
*
* gecko_cmd_cte_receiver_enable_silabs_cte
*
* Enable IQ sampling of Silicon Labs CTE found in extended advertisements. 
*
* @param slot_durations   Slot durations
*  
*      1: Switching and sampling slots are 1 us each
*      2: Switching and sampling slots are 2 us each
* @param cte_count   * 0: Sample and report all available CTEs
*      Other values: Maximum number of sampled CTEs in each extended advertising interval
* @param switching_pattern_len   Array length
* @param switching_pattern_data   Antenna switching pattern. Antennas will be switched in this order with the
*  antenna switch pins during CTE. If the CTE is longer than the switching
*  pattern, the pattern starts over.
*
* Events generated
*
* gecko_evt_cte_receiver_silabs_iq_report - Triggered when IQ samples of Silicon Labs CTE have been received.
*
**/

static inline struct gecko_msg_cte_receiver_enable_silabs_cte_rsp_t* gecko_cmd_cte_receiver_enable_silabs_cte(uint8 slot_durations,uint8 cte_count,uint8 switching_pattern_len, const uint8* switching_pattern_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)switching_pattern_len > 256 - 3)
    {
        gecko_rsp_msg->data.rsp_cte_receiver_enable_silabs_cte.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_cte_receiver_enable_silabs_cte;
    }

    
    gecko_cmd_msg->data.cmd_cte_receiver_enable_silabs_cte.slot_durations=slot_durations;
    gecko_cmd_msg->data.cmd_cte_receiver_enable_silabs_cte.cte_count=cte_count;
    gecko_cmd_msg->data.cmd_cte_receiver_enable_silabs_cte.switching_pattern.len=switching_pattern_len;
    memcpy(gecko_cmd_msg->data.cmd_cte_receiver_enable_silabs_cte.switching_pattern.data,switching_pattern_data,switching_pattern_len);
    gecko_cmd_msg->header=(gecko_cmd_cte_receiver_enable_silabs_cte_id+(((3+switching_pattern_len)&0xff)<<8)+(((3+switching_pattern_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_cte_receiver_enable_silabs_cte;
}

/** 
*
* gecko_cmd_cte_receiver_disable_silabs_cte
*
* Disable IQ sampling of Silicon Labs CTE. 
*
*
**/

static inline struct gecko_msg_cte_receiver_disable_silabs_cte_rsp_t* gecko_cmd_cte_receiver_disable_silabs_cte()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_cte_receiver_disable_silabs_cte_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_cte_receiver_disable_silabs_cte;
}

/** 
*
* gecko_cmd_mesh_sensor_server_init
*
* Initializes the Sensor Server model with Sensor Descriptors present at the
* element. The descriptors are cached and Descriptor Get queries are served
* without propagating it to the application. All incoming client queries are
* checked against the cached data, only valid requests related to existing
* sensors are propagated to the the application. 
*
* @param elem_index   Server model element index
* @param descriptors_len   Array length
* @param descriptors_data   Sensor Descriptor State structures submitted as a byte array
*  
*  A sensor descriptor represents the attributes describing the sensor data. It
*  does not change throughout the lifetime of the element.  
*    
*  The following fields are required:  
*  
*      Sensor Property ID: 16 bits
*      Sensor Positive Tolerance: 12 bits
*      Sensor Negative Tolerance: 12 bits
*      Sensor Sampling Function: 8 bits
*      Sensor Measurement Period: 8 bits
*      Sensor Update Interval: 8 bits
*  
*  Sensor Property ID is a 2-octet value referencing a device property that
*  describes the meaning and the format of data reported by the sensor. The value
*  0x0000 is prohibited. Valid range is 0x0001 to 0xFFFF.
*
**/

static inline struct gecko_msg_mesh_sensor_server_init_rsp_t* gecko_cmd_mesh_sensor_server_init(uint16 elem_index,uint8 descriptors_len, const uint8* descriptors_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)descriptors_len > 256 - 3)
    {
        gecko_rsp_msg->data.rsp_mesh_sensor_server_init.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_sensor_server_init;
    }

    
    gecko_cmd_msg->data.cmd_mesh_sensor_server_init.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_server_init.descriptors.len=descriptors_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_sensor_server_init.descriptors.data,descriptors_data,descriptors_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_sensor_server_init_id+(((3+descriptors_len)&0xff)<<8)+(((3+descriptors_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_sensor_server_init;
}

/** 
*
* gecko_cmd_mesh_sensor_server_deinit
*
* Deinitializes the Sensor Server functionality.  
* Note that the heap reserved space cannot be freed or reallocated.
* Reinitializing with greater number of sensors than before will eventually
* return an out of memory error until the device is reset. 
*
* @param elem_index   Server model element index
*
**/

static inline struct gecko_msg_mesh_sensor_server_deinit_rsp_t* gecko_cmd_mesh_sensor_server_deinit(uint16 elem_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_sensor_server_deinit.elem_index=elem_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_sensor_server_deinit_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_sensor_server_deinit;
}

/** 
*
* gecko_cmd_mesh_sensor_server_send_descriptor_status
*
* Send a Descriptor Status message either as a reply to a Get Descriptor client
* request. 
*
* @param elem_index   Server model element index
* @param client_address   Destination client address. The address 0x0000 can be used to publish the
*  message according to model configuration
* @param appkey_index   The application key index to use.
* @param flags   No flags defined currently
* @param descriptors_len   Array length
* @param descriptors_data   Serialized Sensor Descriptor states for all sensors within the element
*  consisting one or more 8 bytes structures as follows:
*  
*      Sensor Property ID: 16 bits
*      Sensor Positive Tolerance: 12 bits
*      Sensor Negative Tolerance: 12 bits
*      Sensor Sampling Function: 8 bits
*      Sensor Measurement Period: 8 bits
*
**/

static inline struct gecko_msg_mesh_sensor_server_send_descriptor_status_rsp_t* gecko_cmd_mesh_sensor_server_send_descriptor_status(uint16 elem_index,uint16 client_address,uint16 appkey_index,uint8 flags,uint8 descriptors_len, const uint8* descriptors_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)descriptors_len > 256 - 8)
    {
        gecko_rsp_msg->data.rsp_mesh_sensor_server_send_descriptor_status.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_sensor_server_send_descriptor_status;
    }

    
    gecko_cmd_msg->data.cmd_mesh_sensor_server_send_descriptor_status.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_server_send_descriptor_status.client_address=client_address;
    gecko_cmd_msg->data.cmd_mesh_sensor_server_send_descriptor_status.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_server_send_descriptor_status.flags=flags;
    gecko_cmd_msg->data.cmd_mesh_sensor_server_send_descriptor_status.descriptors.len=descriptors_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_sensor_server_send_descriptor_status.descriptors.data,descriptors_data,descriptors_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_sensor_server_send_descriptor_status_id+(((8+descriptors_len)&0xff)<<8)+(((8+descriptors_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_sensor_server_send_descriptor_status;
}

/** 
*
* gecko_cmd_mesh_sensor_server_send_status
*
* Send Sensor Status message as a reply to a Get client request or as an
* unsolicited message. 
*
* @param elem_index   Setup Server model element index
* @param client_address   Destination client address. The address 0x0000 can be used to publish the
*  message according to model configuration
* @param appkey_index   The application key index to use
* @param flags   No flags defined currently
* @param sensor_data_len   Array length
* @param sensor_data_data   Serialized Sensor Data consisting of one or more Sensor state for each sensor
*  within the element. To simplify processing, the byte array is in TLV format:
*  
*      1st Property ID: 16 bits
*      Value Length: 8 bits
*      Value: variable 
*      2nd Property ID: 16 bits
*      Value Length: 8 bits
*      Value: variable 
*      ...
*  
*  If sensor data was requested for a Property ID that does not exist within the
*  element, the reply must contain the given Property ID with zero length.
*
**/

static inline struct gecko_msg_mesh_sensor_server_send_status_rsp_t* gecko_cmd_mesh_sensor_server_send_status(uint16 elem_index,uint16 client_address,uint16 appkey_index,uint8 flags,uint8 sensor_data_len, const uint8* sensor_data_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)sensor_data_len > 256 - 8)
    {
        gecko_rsp_msg->data.rsp_mesh_sensor_server_send_status.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_sensor_server_send_status;
    }

    
    gecko_cmd_msg->data.cmd_mesh_sensor_server_send_status.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_server_send_status.client_address=client_address;
    gecko_cmd_msg->data.cmd_mesh_sensor_server_send_status.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_server_send_status.flags=flags;
    gecko_cmd_msg->data.cmd_mesh_sensor_server_send_status.sensor_data.len=sensor_data_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_sensor_server_send_status.sensor_data.data,sensor_data_data,sensor_data_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_sensor_server_send_status_id+(((8+sensor_data_len)&0xff)<<8)+(((8+sensor_data_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_sensor_server_send_status;
}

/** 
*
* gecko_cmd_mesh_sensor_server_send_column_status
*
* Send Column Status message as a response to a Column Get client request or as
* an unsolicited message 
*
* @param elem_index   Client model element index
* @param client_address   Destination client address. The address 0x0000 can be used to publish the
*  message according to model configuration
* @param appkey_index   The application key index to use.
* @param flags   No flags defined currently
* @param property_id   Property ID for the sensor. Range: 0x0001 - 0x0ffff for a specific device
*  property, the value 0x0000 is prohibited.
* @param sensor_data_len   Array length
* @param sensor_data_data   Byte array containing the serialized Sensor Series Column state in the
*  following format:
*  
*      Sensor Raw Value X, variable length raw value representing the left corner of a column
*      Sensor Column Width, variable length raw value representing the width of the column
*      Sensor Raw Value Y, variable length raw value representing the height of the column
*  
*  If the Property ID or the column ID (Raw value X) does not exist, the reply
*  must contain only these two fields, omitting the optional Column Width and Raw
*  Value Y fields.
*
**/

static inline struct gecko_msg_mesh_sensor_server_send_column_status_rsp_t* gecko_cmd_mesh_sensor_server_send_column_status(uint16 elem_index,uint16 client_address,uint16 appkey_index,uint8 flags,uint16 property_id,uint8 sensor_data_len, const uint8* sensor_data_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)sensor_data_len > 256 - 10)
    {
        gecko_rsp_msg->data.rsp_mesh_sensor_server_send_column_status.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_sensor_server_send_column_status;
    }

    
    gecko_cmd_msg->data.cmd_mesh_sensor_server_send_column_status.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_server_send_column_status.client_address=client_address;
    gecko_cmd_msg->data.cmd_mesh_sensor_server_send_column_status.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_server_send_column_status.flags=flags;
    gecko_cmd_msg->data.cmd_mesh_sensor_server_send_column_status.property_id=property_id;
    gecko_cmd_msg->data.cmd_mesh_sensor_server_send_column_status.sensor_data.len=sensor_data_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_sensor_server_send_column_status.sensor_data.data,sensor_data_data,sensor_data_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_sensor_server_send_column_status_id+(((10+sensor_data_len)&0xff)<<8)+(((10+sensor_data_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_sensor_server_send_column_status;
}

/** 
*
* gecko_cmd_mesh_sensor_server_send_series_status
*
* Send Series Status message as a response to a Series Get client request or as
* an unsolicited message 
*
* @param elem_index   Client model element index
* @param client_address   Destination client address. The address 0x0000 can be used to publish the
*  message according to model configuration
* @param appkey_index   The application key index to use.
* @param flags   No flags defined currently
* @param property_id   Property ID for the sensor. Range: 0x0001 - 0x0ffff for a specific device
*  property, the value 0x0000 is prohibited.
* @param sensor_data_len   Array length
* @param sensor_data_data   Byte array containing the serialized sequence of Sensor Series Column states
*  in the following format:
*  
*      1st Sensor Raw Value X, variable length raw value representing the left corner of a column
*      1st Sensor Column Width, variable length raw value representing the width of the column
*      1st Sensor Raw Value Y, variable length raw value representing the height of the column
*      ...
*      Nth Sensor Raw Value X, variable length raw value representing the left corner of a column
*      Nth Sensor Column Width, variable length raw value representing the width of the column
*      Nth Sensor Raw Value Y, variable length raw value representing the height of the column
*  
*  If Property ID does not exist in the element, the reply must contain only the
*  given Property ID, omitting the other optional fields to column identifiers
*  and column values.
*
**/

static inline struct gecko_msg_mesh_sensor_server_send_series_status_rsp_t* gecko_cmd_mesh_sensor_server_send_series_status(uint16 elem_index,uint16 client_address,uint16 appkey_index,uint8 flags,uint16 property_id,uint8 sensor_data_len, const uint8* sensor_data_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)sensor_data_len > 256 - 10)
    {
        gecko_rsp_msg->data.rsp_mesh_sensor_server_send_series_status.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_sensor_server_send_series_status;
    }

    
    gecko_cmd_msg->data.cmd_mesh_sensor_server_send_series_status.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_server_send_series_status.client_address=client_address;
    gecko_cmd_msg->data.cmd_mesh_sensor_server_send_series_status.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_server_send_series_status.flags=flags;
    gecko_cmd_msg->data.cmd_mesh_sensor_server_send_series_status.property_id=property_id;
    gecko_cmd_msg->data.cmd_mesh_sensor_server_send_series_status.sensor_data.len=sensor_data_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_sensor_server_send_series_status.sensor_data.data,sensor_data_data,sensor_data_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_sensor_server_send_series_status_id+(((10+sensor_data_len)&0xff)<<8)+(((10+sensor_data_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_sensor_server_send_series_status;
}

/** 
*
* gecko_cmd_mesh_sensor_setup_server_send_cadence_status
*
* Replies to a Get/Set Cadence client request with a Cadence Status message.
* Only Cadence Set (acknowledged) must be answered by sending the status message
* to the client. In addition, configuration changes must be published according
* to model publishing configuration. 
*
* @param elem_index   Client model element index
* @param client_address   Destination client address The address 0x0000 can be used to publish the
*  message according model configuration instead of a direct reply.
* @param appkey_index   The application key index to use
* @param flags   No flags defined currently
* @param property_id   Property ID for the sensor. Range: 0x0001 - 0x0ffff for a specific device
*  property, the value 0x0000 is prohibited.
* @param params_len   Array length
* @param params_data   Optional byte array containing the serialized Sensor Cadence state, excluding
*  the property ID. If not empty, the state consists of the following fields:
*  
*      Fast Cadence Period Divisor, 7 bits
*      Status Trigger type, 1 bits (0 = discrete value, 1 = percentage)
*      Status Trigger Delta Down, variable length
*      Status Trigger Delta Up, variable length
*      Status Min Interval, 8 bits, representing a power of 2 milliseconds. Valid range is 0-26 
*      Fast Cadence Low, variable length, lower bound for the fast cadence range
*      Low Cadence Low, variable length, higher bound for the fast cadence range
*
**/

static inline struct gecko_msg_mesh_sensor_setup_server_send_cadence_status_rsp_t* gecko_cmd_mesh_sensor_setup_server_send_cadence_status(uint16 elem_index,uint16 client_address,uint16 appkey_index,uint8 flags,uint16 property_id,uint8 params_len, const uint8* params_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)params_len > 256 - 10)
    {
        gecko_rsp_msg->data.rsp_mesh_sensor_setup_server_send_cadence_status.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_sensor_setup_server_send_cadence_status;
    }

    
    gecko_cmd_msg->data.cmd_mesh_sensor_setup_server_send_cadence_status.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_setup_server_send_cadence_status.client_address=client_address;
    gecko_cmd_msg->data.cmd_mesh_sensor_setup_server_send_cadence_status.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_setup_server_send_cadence_status.flags=flags;
    gecko_cmd_msg->data.cmd_mesh_sensor_setup_server_send_cadence_status.property_id=property_id;
    gecko_cmd_msg->data.cmd_mesh_sensor_setup_server_send_cadence_status.params.len=params_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_sensor_setup_server_send_cadence_status.params.data,params_data,params_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_sensor_setup_server_send_cadence_status_id+(((10+params_len)&0xff)<<8)+(((10+params_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_sensor_setup_server_send_cadence_status;
}

/** 
*
* gecko_cmd_mesh_sensor_setup_server_send_settings_status
*
* Replies to a Get Settings client request with a Settings Status message. 
*
* @param elem_index   Client model element index
* @param client_address   Destination client model address
* @param appkey_index   The application key index to use
* @param flags   No flags defined currently
* @param property_id   Property ID for the sensor. Range: 0x0001 - 0x0ffff for a specific device
*  property, the value 0x0000 is prohibited.
* @param setting_ids_len   Array length
* @param setting_ids_data   Array of 16-bit Setting Property IDs of the settings the given sensor has
*
**/

static inline struct gecko_msg_mesh_sensor_setup_server_send_settings_status_rsp_t* gecko_cmd_mesh_sensor_setup_server_send_settings_status(uint16 elem_index,uint16 client_address,uint16 appkey_index,uint8 flags,uint16 property_id,uint8 setting_ids_len, const uint8* setting_ids_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)setting_ids_len > 256 - 10)
    {
        gecko_rsp_msg->data.rsp_mesh_sensor_setup_server_send_settings_status.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_sensor_setup_server_send_settings_status;
    }

    
    gecko_cmd_msg->data.cmd_mesh_sensor_setup_server_send_settings_status.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_setup_server_send_settings_status.client_address=client_address;
    gecko_cmd_msg->data.cmd_mesh_sensor_setup_server_send_settings_status.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_setup_server_send_settings_status.flags=flags;
    gecko_cmd_msg->data.cmd_mesh_sensor_setup_server_send_settings_status.property_id=property_id;
    gecko_cmd_msg->data.cmd_mesh_sensor_setup_server_send_settings_status.setting_ids.len=setting_ids_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_sensor_setup_server_send_settings_status.setting_ids.data,setting_ids_data,setting_ids_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_sensor_setup_server_send_settings_status_id+(((10+setting_ids_len)&0xff)<<8)+(((10+setting_ids_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_sensor_setup_server_send_settings_status;
}

/** 
*
* gecko_cmd_mesh_sensor_setup_server_send_setting_status
*
* Replies to a Get/Set Setting client request with a Setting Status message.
* Only Set Setting (acknowledged) request must be answered by sending a reply to
* the unicast address of the sender. In addition, configuration changes must be
* published if model publishing is set up. 
*
* @param elem_index   Client model element index
* @param client_address   Destination client model address
* @param appkey_index   The application key index to use
* @param flags   No flags defined currently
* @param property_id   Property ID for the sensor. Range: 0x0001 - 0x0ffff for a specific device
*  property, the value 0x0000 is prohibited.
* @param setting_id   Sensor Setting Property ID field identifying the device property of a setting.
*  Range: 0x0001 - 0xffff, 0x0000 is prohibited.
* @param raw_value_len   Array length
* @param raw_value_data   Sensor Setting raw value. Size and representation depends on the type defined
*  by the Sensor Setting Property ID.
*
**/

static inline struct gecko_msg_mesh_sensor_setup_server_send_setting_status_rsp_t* gecko_cmd_mesh_sensor_setup_server_send_setting_status(uint16 elem_index,uint16 client_address,uint16 appkey_index,uint8 flags,uint16 property_id,uint16 setting_id,uint8 raw_value_len, const uint8* raw_value_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)raw_value_len > 256 - 12)
    {
        gecko_rsp_msg->data.rsp_mesh_sensor_setup_server_send_setting_status.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_sensor_setup_server_send_setting_status;
    }

    
    gecko_cmd_msg->data.cmd_mesh_sensor_setup_server_send_setting_status.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_setup_server_send_setting_status.client_address=client_address;
    gecko_cmd_msg->data.cmd_mesh_sensor_setup_server_send_setting_status.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_setup_server_send_setting_status.flags=flags;
    gecko_cmd_msg->data.cmd_mesh_sensor_setup_server_send_setting_status.property_id=property_id;
    gecko_cmd_msg->data.cmd_mesh_sensor_setup_server_send_setting_status.setting_id=setting_id;
    gecko_cmd_msg->data.cmd_mesh_sensor_setup_server_send_setting_status.raw_value.len=raw_value_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_sensor_setup_server_send_setting_status.raw_value.data,raw_value_data,raw_value_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_sensor_setup_server_send_setting_status_id+(((12+raw_value_len)&0xff)<<8)+(((12+raw_value_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_sensor_setup_server_send_setting_status;
}

/** 
*
* gecko_cmd_mesh_sensor_client_init
*
* Initializes the Sensor Client model. Sensor Client does not have any internal
* configuration, it only activates the model in the Bluetooth mesh stack. 
*
*
**/

static inline struct gecko_msg_mesh_sensor_client_init_rsp_t* gecko_cmd_mesh_sensor_client_init()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_sensor_client_init_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_sensor_client_init;
}

/** 
*
* gecko_cmd_mesh_sensor_client_deinit
*
* Deinitializes the Sensor Client model. There are no sensor-specific
* configurations to reset. Normally, models are initialized at boot and never
* deinitialized. 
*
*
**/

static inline struct gecko_msg_mesh_sensor_client_deinit_rsp_t* gecko_cmd_mesh_sensor_client_deinit()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=(gecko_cmd_mesh_sensor_client_deinit_id+(((0)&0xff)<<8)+(((0)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_sensor_client_deinit;
}

/** 
*
* gecko_cmd_mesh_sensor_client_get_descriptor
*
* Get the Sensor Descriptor state of one specific sensor or all sensors within a
* model. Results in a Sensor Descriptor Status event 
*
* @param elem_index   Client model element index
* @param server_address   Destination server model address. The address 0x0000 can be used to publish
*  the message according to model configuration
* @param appkey_index   The application key index to use.
* @param flags   No flags defined currently
* @param property_id   ProperyID for the sensor (optional). Range: 0x0001 - 0xffff for a specific
*  device property ID or 0x0000 to get all (the value 0x0000 is prohibited as a
*  real ID).
*
**/

static inline struct gecko_msg_mesh_sensor_client_get_descriptor_rsp_t* gecko_cmd_mesh_sensor_client_get_descriptor(uint16 elem_index,uint16 server_address,uint16 appkey_index,uint8 flags,uint16 property_id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_descriptor.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_descriptor.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_descriptor.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_descriptor.flags=flags;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_descriptor.property_id=property_id;
    gecko_cmd_msg->header=(gecko_cmd_mesh_sensor_client_get_descriptor_id+(((9)&0xff)<<8)+(((9)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_sensor_client_get_descriptor;
}

/** 
*
* gecko_cmd_mesh_sensor_client_get
*
* Sends a Sensor Get message to fetch the Sensor Data state of one specific
* sensor given by its Property ID, results in a Sensor Status event. The
* Property ID 0x0000 can be used to fetch all sensor values present at a server
* element. 
*
* @param elem_index   Client model element index
* @param server_address   Destination server model address. The address 0x0000 can be used to publish
*  the message according to model configuration
* @param appkey_index   The application key index to use.
* @param flags   No flags defined currently
* @param property_id   Property ID for the sensor. Range: 0x0001 - 0x0ffff for a specific device
*  property, or 0x0000 when not used to get values for all sensors present in the
*  element.
*
**/

static inline struct gecko_msg_mesh_sensor_client_get_rsp_t* gecko_cmd_mesh_sensor_client_get(uint16 elem_index,uint16 server_address,uint16 appkey_index,uint8 flags,uint16 property_id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get.flags=flags;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get.property_id=property_id;
    gecko_cmd_msg->header=(gecko_cmd_mesh_sensor_client_get_id+(((9)&0xff)<<8)+(((9)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_sensor_client_get;
}

/** 
*
* gecko_cmd_mesh_sensor_client_get_column
*
* Get a Sensor Series Column state, results in a Sensor Column Status event. 
*
* @param elem_index   Client model element index
* @param server_address   Destination server model address. The address 0x0000 can be used to publish
*  the message according to model configuration
* @param appkey_index   The application key index to use.
* @param flags   No flags defined currently
* @param property_id   Property ID for the sensor. Range: 0x0001 - 0x0ffff for a specific device
*  property, the value 0x0000 is prohibited.
* @param column_id_len   Array length
* @param column_id_data   Raw value identifying a column
*
**/

static inline struct gecko_msg_mesh_sensor_client_get_column_rsp_t* gecko_cmd_mesh_sensor_client_get_column(uint16 elem_index,uint16 server_address,uint16 appkey_index,uint8 flags,uint16 property_id,uint8 column_id_len, const uint8* column_id_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)column_id_len > 256 - 10)
    {
        gecko_rsp_msg->data.rsp_mesh_sensor_client_get_column.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_sensor_client_get_column;
    }

    
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_column.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_column.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_column.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_column.flags=flags;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_column.property_id=property_id;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_column.column_id.len=column_id_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_sensor_client_get_column.column_id.data,column_id_data,column_id_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_sensor_client_get_column_id+(((10+column_id_len)&0xff)<<8)+(((10+column_id_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_sensor_client_get_column;
}

/** 
*
* gecko_cmd_mesh_sensor_client_get_series
*
* Get a Sensor Series Column state, which results in a Sensor Series Status
* event. 
*
* @param elem_index   Client model element index
* @param server_address   Destination server model address. The address 0x0000 can be used to publish
*  the message according to model configuration
* @param appkey_index   The application key index to use.
* @param flags   No flags defined currently
* @param property_id   Property ID for the sensor. Range: 0x0001 - 0x0ffff for a specific device
*  property, the value 0x0000 is prohibited.
* @param column_ids_len   Array length
* @param column_ids_data   Raw values identifying starting and ending columns
*
**/

static inline struct gecko_msg_mesh_sensor_client_get_series_rsp_t* gecko_cmd_mesh_sensor_client_get_series(uint16 elem_index,uint16 server_address,uint16 appkey_index,uint8 flags,uint16 property_id,uint8 column_ids_len, const uint8* column_ids_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)column_ids_len > 256 - 10)
    {
        gecko_rsp_msg->data.rsp_mesh_sensor_client_get_series.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_sensor_client_get_series;
    }

    
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_series.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_series.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_series.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_series.flags=flags;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_series.property_id=property_id;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_series.column_ids.len=column_ids_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_sensor_client_get_series.column_ids.data,column_ids_data,column_ids_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_sensor_client_get_series_id+(((10+column_ids_len)&0xff)<<8)+(((10+column_ids_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_sensor_client_get_series;
}

/** 
*
* gecko_cmd_mesh_sensor_client_get_cadence
*
* Sends a Sensor Get Cadence message to get the Sensor Cadence state, which
* results in a Sensor Cadence Status message. 
*
* @param elem_index   Client model element index
* @param server_address   Destination server model address. The address 0x0000 can be used to publish
*  the message according to model configuration
* @param appkey_index   The application key index to use
* @param flags   No flags defined currently
* @param property_id   Property ID for the sensor. Range: 0x0001 - 0x0ffff for a specific device
*  property, the value 0x0000 is prohibited.
*
**/

static inline struct gecko_msg_mesh_sensor_client_get_cadence_rsp_t* gecko_cmd_mesh_sensor_client_get_cadence(uint16 elem_index,uint16 server_address,uint16 appkey_index,uint8 flags,uint16 property_id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_cadence.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_cadence.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_cadence.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_cadence.flags=flags;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_cadence.property_id=property_id;
    gecko_cmd_msg->header=(gecko_cmd_mesh_sensor_client_get_cadence_id+(((9)&0xff)<<8)+(((9)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_sensor_client_get_cadence;
}

/** 
*
* gecko_cmd_mesh_sensor_client_set_cadence
*
* Sends a Sensor Cadence Set message, either acknowledged or unacknowledged,
* depending on the message flags. Acknowledged message results in a Cadence
* Status reply message and event. The server must publish its new state in any
* case. 
*
* @param elem_index   Client model element index
* @param server_address   Destination server model address. The address 0x0000 can be used to publish
*  the message according to model configuration
* @param appkey_index   The application key index to use
* @param flags   Bit 1 (0x02) defines whether response is required.  
*  If set to 1, SET CADENCE message will be sent, zero will send SET CADENCE
*  UNACKNOWLEDGED
* @param property_id   Property ID for the sensor. Range: 0x0001 - 0x0ffff for a specific device
*  property, the value 0x0000 is prohibited.
* @param params_len   Array length
* @param params_data   Byte array containing serialized fields of Sensor Cadence state, excluding the
*  property ID
*  
*      Fast Cadence Period Divisor, 7 bits
*      Status Trigger type, 1 bit (0 = discrete value, 1 = percentage)
*      Status Trigger Delta Down, variable length
*      Status Trigger Delta Up, variable length
*      Status Min Interval, 8 bits, representing a power of 2 milliseconds. Valid range is 0-26 
*      Fast Cadence Low, variable length, lower bound for the fast cadence range
*      Low Cadence Low, variable length, higher bound for the fast cadence range
*
**/

static inline struct gecko_msg_mesh_sensor_client_set_cadence_rsp_t* gecko_cmd_mesh_sensor_client_set_cadence(uint16 elem_index,uint16 server_address,uint16 appkey_index,uint8 flags,uint16 property_id,uint8 params_len, const uint8* params_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)params_len > 256 - 10)
    {
        gecko_rsp_msg->data.rsp_mesh_sensor_client_set_cadence.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_sensor_client_set_cadence;
    }

    
    gecko_cmd_msg->data.cmd_mesh_sensor_client_set_cadence.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_set_cadence.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_set_cadence.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_set_cadence.flags=flags;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_set_cadence.property_id=property_id;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_set_cadence.params.len=params_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_sensor_client_set_cadence.params.data,params_data,params_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_sensor_client_set_cadence_id+(((10+params_len)&0xff)<<8)+(((10+params_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_sensor_client_set_cadence;
}

/** 
*
* gecko_cmd_mesh_sensor_client_get_settings
*
* Sends a Sensor Settings Get message to fetch the Sensor Property IDs present
* for the given sensor, which results in a Sensor Settings Status event. 
*
* @param elem_index   Client model element index
* @param server_address   Destination server model address. The address 0x0000 can be used to publish
*  the message according to model configuration
* @param appkey_index   The application key index to use
* @param flags   No flags defined currently
* @param property_id   Property ID for the sensor. Range: 0x0001 - 0x0ffff for a specific device
*  property, the value 0x0000 is prohibited.
*
**/

static inline struct gecko_msg_mesh_sensor_client_get_settings_rsp_t* gecko_cmd_mesh_sensor_client_get_settings(uint16 elem_index,uint16 server_address,uint16 appkey_index,uint8 flags,uint16 property_id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_settings.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_settings.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_settings.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_settings.flags=flags;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_settings.property_id=property_id;
    gecko_cmd_msg->header=(gecko_cmd_mesh_sensor_client_get_settings_id+(((9)&0xff)<<8)+(((9)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_sensor_client_get_settings;
}

/** 
*
* gecko_cmd_mesh_sensor_client_get_setting
*
* Sends a Sensor Get Setting message to get the value of a specific setting for
* the given sensor, which results in a Sensor Setting Status event. 
*
* @param elem_index   Client model element index
* @param server_address   Destination server model address. The address 0x0000 can be used to publish
*  the message according to model configuration
* @param appkey_index   The application key index to use.
* @param flags   No flags defined currently
* @param property_id   Property ID for the sensor. Range: 0x0001 - 0x0ffff for a specific device
*  property, the value 0x0000 is prohibited.
* @param setting_id   Sensor Setting Property ID field identifying the device property of a setting.
*  Range: 0x0001 - 0xffff, 0x0000 is prohibited.
*
**/

static inline struct gecko_msg_mesh_sensor_client_get_setting_rsp_t* gecko_cmd_mesh_sensor_client_get_setting(uint16 elem_index,uint16 server_address,uint16 appkey_index,uint8 flags,uint16 property_id,uint16 setting_id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_setting.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_setting.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_setting.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_setting.flags=flags;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_setting.property_id=property_id;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_get_setting.setting_id=setting_id;
    gecko_cmd_msg->header=(gecko_cmd_mesh_sensor_client_get_setting_id+(((11)&0xff)<<8)+(((11)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_sensor_client_get_setting;
}

/** 
*
* gecko_cmd_mesh_sensor_client_set_setting
*
* Sends Sensor Setting Set message to update the value of a specific setting for
* the given sensor, either acknowledged or unacknowledged depending on the
* message flags. Only acknowledged requests will have a direct Sensor Setting
* Status reply. The server must publish its new state in any case. 
*
* @param elem_index   Client model element index
* @param server_address   Destination server model address. The address 0x0000 can be used to publish
*  the message according to model configuration
* @param appkey_index   The application key index to use
* @param flags   Bit 1 (0x02) defines whether response is required.  
*  If set to 1, SET SETTING message is sent, zero will use SET SETTING
*  UNACKNOWLEDGED.
* @param property_id   Property ID for the sensor. Range: 0x0001 - 0x0ffff for a specific device
*  property, the value 0x0000 is prohibited.
* @param setting_id   Sensor Setting Property ID field identifying the device property of a setting.
*  Range: 0x0001 - 0xffff, 0x0000 is prohibited.
* @param raw_value_len   Array length
* @param raw_value_data   Sensor Setting raw value. Size and representation depends on the type defined
*  by the Sensor Setting Property ID.
*
**/

static inline struct gecko_msg_mesh_sensor_client_set_setting_rsp_t* gecko_cmd_mesh_sensor_client_set_setting(uint16 elem_index,uint16 server_address,uint16 appkey_index,uint8 flags,uint16 property_id,uint16 setting_id,uint8 raw_value_len, const uint8* raw_value_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)raw_value_len > 256 - 12)
    {
        gecko_rsp_msg->data.rsp_mesh_sensor_client_set_setting.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_sensor_client_set_setting;
    }

    
    gecko_cmd_msg->data.cmd_mesh_sensor_client_set_setting.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_set_setting.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_set_setting.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_set_setting.flags=flags;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_set_setting.property_id=property_id;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_set_setting.setting_id=setting_id;
    gecko_cmd_msg->data.cmd_mesh_sensor_client_set_setting.raw_value.len=raw_value_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_sensor_client_set_setting.raw_value.data,raw_value_data,raw_value_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_sensor_client_set_setting_id+(((12+raw_value_len)&0xff)<<8)+(((12+raw_value_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_sensor_client_set_setting;
}

/** 
*
* gecko_cmd_mesh_lc_client_init
*
* Initializes the LC Client model. LC Client does not have any internal
* configuration, it only activates the model in the mesh stack. 
*
* @param elem_index   Index of the client element.
*
**/

static inline struct gecko_msg_mesh_lc_client_init_rsp_t* gecko_cmd_mesh_lc_client_init(uint16 elem_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_lc_client_init.elem_index=elem_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_lc_client_init_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_lc_client_init;
}

/** 
*
* gecko_cmd_mesh_lc_client_get_mode
*
* Get the mode status. 
*
* @param elem_index   Index of the client element.
* @param server_address   Device to be queried. The address 0x0000 can be used to publish the message
*  according to model configuration
* @param appkey_index   Appkey used by server_address.
*
* Events generated
*
* gecko_evt_mesh_lc_client_mode_status - 
*
**/

static inline struct gecko_msg_mesh_lc_client_get_mode_rsp_t* gecko_cmd_mesh_lc_client_get_mode(uint16 elem_index,uint16 server_address,uint16 appkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_lc_client_get_mode.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_lc_client_get_mode.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_lc_client_get_mode.appkey_index=appkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_lc_client_get_mode_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_lc_client_get_mode;
}

/** 
*
* gecko_cmd_mesh_lc_client_set_mode
*
* Set mode 
*
* @param elem_index   Client model element index
* @param server_address   Destination server model address. The address 0x0000 can be used to publish
*  the message according to model configuration
* @param appkey_index   The application key index to use.
* @param flags   Bit 1 (0x02) defines whether response is required.  
*  If set to 1, SET PROPERTY message will be sent, zero will send SET PROPERTY
*  UNACKNOWLEDGED
* @param mode   Mode value to set
*
* Events generated
*
* gecko_evt_mesh_lc_client_mode_status - 
*
**/

static inline struct gecko_msg_mesh_lc_client_set_mode_rsp_t* gecko_cmd_mesh_lc_client_set_mode(uint16 elem_index,uint16 server_address,uint16 appkey_index,uint8 flags,uint8 mode)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_lc_client_set_mode.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_lc_client_set_mode.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_lc_client_set_mode.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_lc_client_set_mode.flags=flags;
    gecko_cmd_msg->data.cmd_mesh_lc_client_set_mode.mode=mode;
    gecko_cmd_msg->header=(gecko_cmd_mesh_lc_client_set_mode_id+(((8)&0xff)<<8)+(((8)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_lc_client_set_mode;
}

/** 
*
* gecko_cmd_mesh_lc_client_get_om
*
* Get the OM status. 
*
* @param elem_index   Index of the client element.
* @param server_address   Device to be queried. The address 0x0000 can be used to publish the message
*  according to model configuration
* @param appkey_index   Appkey used by server_address.
*
* Events generated
*
* gecko_evt_mesh_lc_client_om_status - 
*
**/

static inline struct gecko_msg_mesh_lc_client_get_om_rsp_t* gecko_cmd_mesh_lc_client_get_om(uint16 elem_index,uint16 server_address,uint16 appkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_lc_client_get_om.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_lc_client_get_om.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_lc_client_get_om.appkey_index=appkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_lc_client_get_om_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_lc_client_get_om;
}

/** 
*
* gecko_cmd_mesh_lc_client_set_om
*
* Set occupancy mode 
*
* @param elem_index   Client model element index
* @param server_address   Destination server model address. The address 0x0000 can be used to publish
*  the message according to model configuration
* @param appkey_index   The application key index to use.
* @param flags   Bit 1 (0x02) defines whether response is required.  
*  If set to 1, SET PROPERTY message will be sent, zero will send SET PROPERTY
*  UNACKNOWLEDGED
* @param mode   Mode value to set
*
* Events generated
*
* gecko_evt_mesh_lc_client_om_status - 
*
**/

static inline struct gecko_msg_mesh_lc_client_set_om_rsp_t* gecko_cmd_mesh_lc_client_set_om(uint16 elem_index,uint16 server_address,uint16 appkey_index,uint8 flags,uint8 mode)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_lc_client_set_om.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_lc_client_set_om.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_lc_client_set_om.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_lc_client_set_om.flags=flags;
    gecko_cmd_msg->data.cmd_mesh_lc_client_set_om.mode=mode;
    gecko_cmd_msg->header=(gecko_cmd_mesh_lc_client_set_om_id+(((8)&0xff)<<8)+(((8)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_lc_client_set_om;
}

/** 
*
* gecko_cmd_mesh_lc_client_get_light_onoff
*
* Get the Light OnOff status. 
*
* @param elem_index   Index of the client element.
* @param server_address   Device to be queried. The address 0x0000 can be used to publish the message
*  according to model configuration
* @param appkey_index   Appkey used by server_address.
*
* Events generated
*
* gecko_evt_mesh_lc_client_light_onoff_status - 
*
**/

static inline struct gecko_msg_mesh_lc_client_get_light_onoff_rsp_t* gecko_cmd_mesh_lc_client_get_light_onoff(uint16 elem_index,uint16 server_address,uint16 appkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_lc_client_get_light_onoff.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_lc_client_get_light_onoff.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_lc_client_get_light_onoff.appkey_index=appkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_lc_client_get_light_onoff_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_lc_client_get_light_onoff;
}

/** 
*
* gecko_cmd_mesh_lc_client_set_light_onoff
*
* Set Light OnOff 
*
* @param elem_index   Client model element index
* @param server_address   Destination server model address. The address 0x0000 can be used to publish
*  the message according to model configuration
* @param appkey_index   The application key index to use.
* @param flags   Bit 1 (0x02) defines whether response is required.  
*  If set to 1, SET PROPERTY message will be sent, zero will send SET PROPERTY
*  UNACKNOWLEDGED
* @param target_state   The target value of the Light LC Light OnOff state
* @param tid   Transaction identifier
* @param transition_time   Transition time in milliseconds. Value of 0xFFFFFFFF will cause this parameter
*  as well as the "delay" parameter to be omitted.
* @param message_delay   Message execution delay in milliseconds. If the "transition_time" is
*  0xFFFFFFFF, this parameter is ignored. If both the transition time and the
*  delay are zero the transition is immediate.
*
* Events generated
*
* gecko_evt_mesh_lc_client_light_onoff_status - 
*
**/

static inline struct gecko_msg_mesh_lc_client_set_light_onoff_rsp_t* gecko_cmd_mesh_lc_client_set_light_onoff(uint16 elem_index,uint16 server_address,uint16 appkey_index,uint8 flags,uint8 target_state,uint8 tid,uint32 transition_time,uint16 message_delay)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_lc_client_set_light_onoff.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_lc_client_set_light_onoff.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_lc_client_set_light_onoff.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_lc_client_set_light_onoff.flags=flags;
    gecko_cmd_msg->data.cmd_mesh_lc_client_set_light_onoff.target_state=target_state;
    gecko_cmd_msg->data.cmd_mesh_lc_client_set_light_onoff.tid=tid;
    gecko_cmd_msg->data.cmd_mesh_lc_client_set_light_onoff.transition_time=transition_time;
    gecko_cmd_msg->data.cmd_mesh_lc_client_set_light_onoff.message_delay=message_delay;
    gecko_cmd_msg->header=(gecko_cmd_mesh_lc_client_set_light_onoff_id+(((15)&0xff)<<8)+(((15)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_lc_client_set_light_onoff;
}

/** 
*
* gecko_cmd_mesh_lc_client_get_property
*
* Get the Property status. 
*
* @param elem_index   Index of the client element.
* @param server_address   Device to be queried. The address 0x0000 can be used to publish the message
*  according to model configuration
* @param appkey_index   Appkey used by server_address.
* @param property_id   The property ID to query.
*
* Events generated
*
* gecko_evt_mesh_lc_client_property_status - 
*
**/

static inline struct gecko_msg_mesh_lc_client_get_property_rsp_t* gecko_cmd_mesh_lc_client_get_property(uint16 elem_index,uint16 server_address,uint16 appkey_index,uint16 property_id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_lc_client_get_property.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_lc_client_get_property.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_lc_client_get_property.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_lc_client_get_property.property_id=property_id;
    gecko_cmd_msg->header=(gecko_cmd_mesh_lc_client_get_property_id+(((8)&0xff)<<8)+(((8)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_lc_client_get_property;
}

/** 
*
* gecko_cmd_mesh_lc_client_set_property
*
* Set a particular property 
*
* @param elem_index   Client model element index
* @param server_address   Destination server model address. The address 0x0000 can be used to publish
*  the message according to model configuration
* @param appkey_index   The application key index to use.
* @param flags   Bit 1 (0x02) defines whether response is required.  
*  If set to 1, SET PROPERTY message will be sent, zero will send SET PROPERTY
*  UNACKNOWLEDGED
* @param property_id   Property ID for the LC Server. Range: 0x0001 - 0x0ffff for a specific device
*  property, the value 0x0000 is prohibited.
* @param params_len   Array length
* @param params_data   Byte array containing serialized fields of LC Property, excluding the property
*  ID
*
* Events generated
*
* gecko_evt_mesh_lc_client_property_status - 
*
**/

static inline struct gecko_msg_mesh_lc_client_set_property_rsp_t* gecko_cmd_mesh_lc_client_set_property(uint16 elem_index,uint16 server_address,uint16 appkey_index,uint8 flags,uint16 property_id,uint8 params_len, const uint8* params_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)params_len > 256 - 10)
    {
        gecko_rsp_msg->data.rsp_mesh_lc_client_set_property.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_lc_client_set_property;
    }

    
    gecko_cmd_msg->data.cmd_mesh_lc_client_set_property.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_lc_client_set_property.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_lc_client_set_property.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_lc_client_set_property.flags=flags;
    gecko_cmd_msg->data.cmd_mesh_lc_client_set_property.property_id=property_id;
    gecko_cmd_msg->data.cmd_mesh_lc_client_set_property.params.len=params_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_lc_client_set_property.params.data,params_data,params_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_lc_client_set_property_id+(((10+params_len)&0xff)<<8)+(((10+params_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_lc_client_set_property;
}

/** 
*
* gecko_cmd_mesh_lc_server_init
*
* Initializes the LC Server model. Server does not have any internal
* configuration, command only activates the model in the mesh stack.
* 
* Each LC Server instance requires that a Lightness Server is initialized in the
* element preceding the LC Server element: LC Server controls the Lightness
* Server residing in the preceding element. Each LC Server instance requires
* that a generic OnOff Server is initialized in the same element as the LC
* Server.
* 
* LC properties are initialized as follows:
* 
* PropertyID: PropertyValue 0x002B: 0x111111, 0x002C: 0x011111, 0x002D:
* 0x001111, 0x002E: 0xf000, 0x002F: 0x0f00, 0x0030: 0x00f0, 0x031: 50, 0x032:
* 25.0, 0x0033: 250.0, 0x0034: 80.0, 0x0035: 80.0, 0x0036: 3000, 0x0037: 3000,
* 0x0038: 3000, 0x0039: 3000, 0x003A: 0, 0x003B: 3000, 0x003C: 3000
* 
* PI Regulator interval (T) is initialized to 50ms
* 
* The rest of the state values are initialized to zero 
*
* @param elem_index   Index of the element.
*
**/

static inline struct gecko_msg_mesh_lc_server_init_rsp_t* gecko_cmd_mesh_lc_server_init(uint16 elem_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_lc_server_init.elem_index=elem_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_lc_server_init_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_lc_server_init;
}

/** 
*
* gecko_cmd_mesh_lc_server_deinit
*
* De-initializes the LC Server model. 
*
* @param elem_index   Index of the element.
*
**/

static inline struct gecko_msg_mesh_lc_server_deinit_rsp_t* gecko_cmd_mesh_lc_server_deinit(uint16 elem_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_lc_server_deinit.elem_index=elem_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_lc_server_deinit_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_lc_server_deinit;
}

/** 
*
* gecko_cmd_mesh_lc_server_update_mode
*
* Command for updating LC Server model Mode state in the stack. Application may
* choose to directly set the model state in the stack, this function will pass
* the state value to the LC Server model. 
*
* @param elem_index   Index of the element.
* @param mode   Mode value
*
**/

static inline struct gecko_msg_mesh_lc_server_update_mode_rsp_t* gecko_cmd_mesh_lc_server_update_mode(uint16 elem_index,uint8 mode)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_lc_server_update_mode.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_lc_server_update_mode.mode=mode;
    gecko_cmd_msg->header=(gecko_cmd_mesh_lc_server_update_mode_id+(((3)&0xff)<<8)+(((3)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_lc_server_update_mode;
}

/** 
*
* gecko_cmd_mesh_lc_server_update_om
*
* Command for updating LC Server model Occupancy Mode state in the stack.
* Application may choose to directly set the model state in the stack, this
* function will pass the state value to the LC Server model. 
*
* @param elem_index   Index of the element.
* @param om   Occupancy Mode value
*
**/

static inline struct gecko_msg_mesh_lc_server_update_om_rsp_t* gecko_cmd_mesh_lc_server_update_om(uint16 elem_index,uint8 om)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_lc_server_update_om.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_lc_server_update_om.om=om;
    gecko_cmd_msg->header=(gecko_cmd_mesh_lc_server_update_om_id+(((3)&0xff)<<8)+(((3)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_lc_server_update_om;
}

/** 
*
* gecko_cmd_mesh_lc_server_update_light_onoff
*
* Command for updating LC Server model Light OnOff state in the stack.
* Application may choose to directly set the model state in the stack, this
* function will pass the state value to the LC Server model. 
*
* @param elem_index   Index of the element.
* @param light_onoff   Light OnOff value
* @param transition_time_ms   Amount of time (in milliseconds) the element will take to transition to the
*  target state from the present state. If set to 0 the transition will be
*  immediate.
*
**/

static inline struct gecko_msg_mesh_lc_server_update_light_onoff_rsp_t* gecko_cmd_mesh_lc_server_update_light_onoff(uint16 elem_index,uint8 light_onoff,uint32 transition_time_ms)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_lc_server_update_light_onoff.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_lc_server_update_light_onoff.light_onoff=light_onoff;
    gecko_cmd_msg->data.cmd_mesh_lc_server_update_light_onoff.transition_time_ms=transition_time_ms;
    gecko_cmd_msg->header=(gecko_cmd_mesh_lc_server_update_light_onoff_id+(((7)&0xff)<<8)+(((7)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_lc_server_update_light_onoff;
}

/** 
*
* gecko_cmd_mesh_lc_server_init_all_properties
*
* Initialize all LC properties in one shot. Following values are used:
* 
* PropertyID: PropertyValue 0x002B: 0x111111, 0x002C: 0x011111, 0x002D:
* 0x001111, 0x002E: 0xf000, 0x002F: 0x0f00, 0x0030: 0x00f0, 0x031: 50, 0x032:
* 25.0, 0x0033: 250.0, 0x0034: 80.0, 0x0035: 80.0, 0x0036: 3000, 0x0037: 3000,
* 0x0038: 3000, 0x0039: 3000, 0x003A: 0, 0x003B: 3000, 0x003C: 3000 
*
* @param elem_index   Index of the element.
*
**/

static inline struct gecko_msg_mesh_lc_server_init_all_properties_rsp_t* gecko_cmd_mesh_lc_server_init_all_properties(uint16 elem_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_lc_server_init_all_properties.elem_index=elem_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_lc_server_init_all_properties_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_lc_server_init_all_properties;
}

/** 
*
* gecko_cmd_mesh_lc_server_set_publish_mask
*
* This command will update the bitmask that controls what messages are sent when
* the LC Server publishes. By default, the bitmask will be enabled to publish
* all three status messages. 
*
* @param elem_index   Index of the element.
* @param status_type   The type of status message to turn on/off. Options for this are:
*  
*  LC Mode Status 0x8294 LC Occupancy Mode Status 0x8298 LC Light On Off Status
*  0x829C
* @param value   Turn on or off the status message.
*
**/

static inline struct gecko_msg_mesh_lc_server_set_publish_mask_rsp_t* gecko_cmd_mesh_lc_server_set_publish_mask(uint16 elem_index,uint16 status_type,uint8 value)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_lc_server_set_publish_mask.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_lc_server_set_publish_mask.status_type=status_type;
    gecko_cmd_msg->data.cmd_mesh_lc_server_set_publish_mask.value=value;
    gecko_cmd_msg->header=(gecko_cmd_mesh_lc_server_set_publish_mask_id+(((5)&0xff)<<8)+(((5)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_lc_server_set_publish_mask;
}

/** 
*
* gecko_cmd_mesh_lc_server_set_regulator_interval
*
* This command will update the summation interval (T) at which the PI regulator
* is run. Only valid when regulator is disabled (Light LC Mode is 0). 
*
* @param elem_index   Index of the element.
* @param value   Valid values are 1ms-100ms. (Default: 50ms)
*
**/

static inline struct gecko_msg_mesh_lc_server_set_regulator_interval_rsp_t* gecko_cmd_mesh_lc_server_set_regulator_interval(uint16 elem_index,uint8 value)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_lc_server_set_regulator_interval.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_lc_server_set_regulator_interval.value=value;
    gecko_cmd_msg->header=(gecko_cmd_mesh_lc_server_set_regulator_interval_id+(((3)&0xff)<<8)+(((3)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_lc_server_set_regulator_interval;
}

/** 
*
* gecko_cmd_mesh_lc_server_set_event_mask
*
* This command will enable or disable additional diagnostics events. See
* lc_debug_events. 
*
* @param elem_index   Index of the element.
* @param event_type   The type of event to enable/disable. Options are:
*  
*  lc_event_state_updated = 0x01, state_updated event report state changes
*  lc_event_regulator_debug_info = 0x02, regulator_debug_info Regulator
*  calculation details
* @param value   Valid values are 0 and 1 to disable or enable the event
*
**/

static inline struct gecko_msg_mesh_lc_server_set_event_mask_rsp_t* gecko_cmd_mesh_lc_server_set_event_mask(uint16 elem_index,uint16 event_type,uint8 value)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_lc_server_set_event_mask.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_lc_server_set_event_mask.event_type=event_type;
    gecko_cmd_msg->data.cmd_mesh_lc_server_set_event_mask.value=value;
    gecko_cmd_msg->header=(gecko_cmd_mesh_lc_server_set_event_mask_id+(((5)&0xff)<<8)+(((5)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_lc_server_set_event_mask;
}

/** 
*
* gecko_cmd_mesh_lc_server_get_lc_state
*
* This command will fetch the current LC state. States can be as Off, Standby,
* Fade On, Run, Fade, Prolong, Fade Standby Auto, Fade Standby Manual 
*
* @param elem_index   Index of the element.
*
**/

static inline struct gecko_msg_mesh_lc_server_get_lc_state_rsp_t* gecko_cmd_mesh_lc_server_get_lc_state(uint16 elem_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_lc_server_get_lc_state.elem_index=elem_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_lc_server_get_lc_state_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_lc_server_get_lc_state;
}

/** 
*
* gecko_cmd_mesh_lc_setup_server_update_property
*
* Command for updating LC Server property. Application may choose to directly
* set model properties in the stack, this function will pass the property value
* to the LC Setup Server and on to the LC Server model. 
*
* @param elem_index   Client model element index
* @param property_id   Property ID for the LC Server. Range: 0x0001 - 0x0ffff for a specific device
*  property, the value 0x0000 is prohibited.
* @param params_len   Array length
* @param params_data   Byte array containing serialized fields of LC Property, excluding the property
*  ID
*
**/

static inline struct gecko_msg_mesh_lc_setup_server_update_property_rsp_t* gecko_cmd_mesh_lc_setup_server_update_property(uint16 elem_index,uint16 property_id,uint8 params_len, const uint8* params_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)params_len > 256 - 5)
    {
        gecko_rsp_msg->data.rsp_mesh_lc_setup_server_update_property.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_mesh_lc_setup_server_update_property;
    }

    
    gecko_cmd_msg->data.cmd_mesh_lc_setup_server_update_property.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_lc_setup_server_update_property.property_id=property_id;
    gecko_cmd_msg->data.cmd_mesh_lc_setup_server_update_property.params.len=params_len;
    memcpy(gecko_cmd_msg->data.cmd_mesh_lc_setup_server_update_property.params.data,params_data,params_len);
    gecko_cmd_msg->header=(gecko_cmd_mesh_lc_setup_server_update_property_id+(((5+params_len)&0xff)<<8)+(((5+params_len)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_lc_setup_server_update_property;
}

/** 
*
* gecko_cmd_mesh_scene_client_init
*
* Initializes the Scene Client model. Scene Client does not have any internal
* configuration, it only activates the model in the mesh stack. 
*
* @param elem_index   Index of the client element.
*
**/

static inline struct gecko_msg_mesh_scene_client_init_rsp_t* gecko_cmd_mesh_scene_client_init(uint16 elem_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_scene_client_init.elem_index=elem_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_scene_client_init_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_scene_client_init;
}

/** 
*
* gecko_cmd_mesh_scene_client_get
*
* Scene Get command. 
*
* @param elem_index   Index of the client element.
* @param server_address   Device to be queried. The address 0x0000 can be used to publish the message
*  according to model configuration
* @param appkey_index   Appkey used by server_address.
*
* Events generated
*
* gecko_evt_mesh_scene_client_status - 
*
**/

static inline struct gecko_msg_mesh_scene_client_get_rsp_t* gecko_cmd_mesh_scene_client_get(uint16 elem_index,uint16 server_address,uint16 appkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_scene_client_get.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_scene_client_get.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_scene_client_get.appkey_index=appkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_scene_client_get_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_scene_client_get;
}

/** 
*
* gecko_cmd_mesh_scene_client_get_register
*
* Scene Register Get command 
*
* @param elem_index   Client model element index
* @param server_address   Destination server model address. The address 0x0000 can be used to publish
*  the message according to model configuration
* @param appkey_index   The application key index to use.
*
* Events generated
*
* gecko_evt_mesh_scene_client_register_status - 
*
**/

static inline struct gecko_msg_mesh_scene_client_get_register_rsp_t* gecko_cmd_mesh_scene_client_get_register(uint16 elem_index,uint16 server_address,uint16 appkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_scene_client_get_register.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_scene_client_get_register.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_scene_client_get_register.appkey_index=appkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_scene_client_get_register_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_scene_client_get_register;
}

/** 
*
* gecko_cmd_mesh_scene_client_recall
*
* Recall a scene. 
*
* @param elem_index   Index of the client element.
* @param server_address   Destination server model address. The address 0x0000 can be used to publish
*  the message according to model configuration
* @param appkey_index   Appkey used by server_address.
* @param flags   Bit 1 (0x02) defines whether response is required.  
*  If set to 1, SET PROPERTY message will be sent, zero will send SET PROPERTY
*  UNACKNOWLEDGED
* @param selected_scene   Scene of interest
* @param tid   Transaction ID
* @param transition_time   Amount of time (in milliseconds) allotted for the transition to take place.
*  Value of 0xFFFFFFFF will cause this parameter as well as the "delay" parameter
*  to be omitted. The transition will be immediate if both the transition time
*  and the delay are zero.
* @param delay   Message execution delay in milliseconds. If the "transition_time" is
*  0xFFFFFFFF, this parameter is ignored. If both the transition time and the
*  delay are zero the transition is immediate.
*
**/

static inline struct gecko_msg_mesh_scene_client_recall_rsp_t* gecko_cmd_mesh_scene_client_recall(uint16 elem_index,uint16 server_address,uint16 appkey_index,uint8 flags,uint16 selected_scene,uint8 tid,uint32 transition_time,uint32 delay)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_scene_client_recall.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_scene_client_recall.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_scene_client_recall.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_scene_client_recall.flags=flags;
    gecko_cmd_msg->data.cmd_mesh_scene_client_recall.selected_scene=selected_scene;
    gecko_cmd_msg->data.cmd_mesh_scene_client_recall.tid=tid;
    gecko_cmd_msg->data.cmd_mesh_scene_client_recall.transition_time=transition_time;
    gecko_cmd_msg->data.cmd_mesh_scene_client_recall.delay=delay;
    gecko_cmd_msg->header=(gecko_cmd_mesh_scene_client_recall_id+(((18)&0xff)<<8)+(((18)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_scene_client_recall;
}

/** 
*
* gecko_cmd_mesh_scene_client_store
*
* Store a scene. 
*
* @param elem_index   Client model element index
* @param server_address   Destination server model address. The address 0x0000 can be used to publish
*  the message according to model configuration
* @param appkey_index   The application key index to use.
* @param flags   Bit 1 (0x02) defines whether response is required.  
*  If set to 1, SET PROPERTY message will be sent, zero will send SET PROPERTY
*  UNACKNOWLEDGED
* @param selected_scene   Scene of interest
*
**/

static inline struct gecko_msg_mesh_scene_client_store_rsp_t* gecko_cmd_mesh_scene_client_store(uint16 elem_index,uint16 server_address,uint16 appkey_index,uint8 flags,uint16 selected_scene)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_scene_client_store.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_scene_client_store.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_scene_client_store.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_scene_client_store.flags=flags;
    gecko_cmd_msg->data.cmd_mesh_scene_client_store.selected_scene=selected_scene;
    gecko_cmd_msg->header=(gecko_cmd_mesh_scene_client_store_id+(((9)&0xff)<<8)+(((9)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_scene_client_store;
}

/** 
*
* gecko_cmd_mesh_scene_client_delete
*
* Delete a scene. 
*
* @param elem_index   Client model element index
* @param server_address   Destination server model address. The address 0x0000 can be used to publish
*  the message according to model configuration
* @param appkey_index   The application key index to use.
* @param flags   Bit 1 (0x02) defines whether response is required.  
*  If set to 1, SET PROPERTY message will be sent, zero will send SET PROPERTY
*  UNACKNOWLEDGED
* @param selected_scene   Scene of interest
*
**/

static inline struct gecko_msg_mesh_scene_client_delete_rsp_t* gecko_cmd_mesh_scene_client_delete(uint16 elem_index,uint16 server_address,uint16 appkey_index,uint8 flags,uint16 selected_scene)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_scene_client_delete.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_scene_client_delete.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_scene_client_delete.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_scene_client_delete.flags=flags;
    gecko_cmd_msg->data.cmd_mesh_scene_client_delete.selected_scene=selected_scene;
    gecko_cmd_msg->header=(gecko_cmd_mesh_scene_client_delete_id+(((9)&0xff)<<8)+(((9)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_scene_client_delete;
}

/** 
*
* gecko_cmd_mesh_scene_server_init
*
* Initializes the Scene Server model. Server does not have any internal
* configuration, command only activates the model in the mesh stack. 
*
* @param elem_index   Index of the element.
*
**/

static inline struct gecko_msg_mesh_scene_server_init_rsp_t* gecko_cmd_mesh_scene_server_init(uint16 elem_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_scene_server_init.elem_index=elem_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_scene_server_init_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_scene_server_init;
}

/** 
*
* gecko_cmd_mesh_scene_server_deinit
*
* De-initializes the Scene Server model. 
*
* @param elem_index   Index of the element.
*
**/

static inline struct gecko_msg_mesh_scene_server_deinit_rsp_t* gecko_cmd_mesh_scene_server_deinit(uint16 elem_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_scene_server_deinit.elem_index=elem_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_scene_server_deinit_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_scene_server_deinit;
}

/** 
*
* gecko_cmd_mesh_scene_server_reset_register
*
* Reset register value. This commmand should be invoked if state of a model has
* been modified in such a manner that it cannot no longer considered to be in
* scene indicated by the scene register. 
*
* @param elem_index   Index of the element. This can be either element of the updated model or the
*  element of the scene model responsible for controlling scene of the updated
*  model.
*
**/

static inline struct gecko_msg_mesh_scene_server_reset_register_rsp_t* gecko_cmd_mesh_scene_server_reset_register(uint16 elem_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_scene_server_reset_register.elem_index=elem_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_scene_server_reset_register_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_scene_server_reset_register;
}

/** 
*
* gecko_cmd_mesh_scene_setup_server_init
*
* Initializes the Scene Setup Server model. Server does not have any internal
* configuration, command only activates the model in the mesh stack. 
*
* @param elem_index   Index of the element.
*
**/

static inline struct gecko_msg_mesh_scene_setup_server_init_rsp_t* gecko_cmd_mesh_scene_setup_server_init(uint16 elem_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_scene_setup_server_init.elem_index=elem_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_scene_setup_server_init_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_scene_setup_server_init;
}

/** 
*
* gecko_cmd_mesh_scheduler_client_init
*
* Initializes the Scheduler Client model 
*
* @param elem_index   Client model element index
*
**/

static inline struct gecko_msg_mesh_scheduler_client_init_rsp_t* gecko_cmd_mesh_scheduler_client_init(uint16 elem_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_scheduler_client_init.elem_index=elem_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_scheduler_client_init_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_scheduler_client_init;
}

/** 
*
* gecko_cmd_mesh_scheduler_client_deinit
*
* Deinitializes the Scheduler Client model 
*
* @param elem_index   Client model element index
*
**/

static inline struct gecko_msg_mesh_scheduler_client_deinit_rsp_t* gecko_cmd_mesh_scheduler_client_deinit(uint16 elem_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_scheduler_client_deinit.elem_index=elem_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_scheduler_client_deinit_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_scheduler_client_deinit;
}

/** 
*
* gecko_cmd_mesh_scheduler_client_get
*
* Send a Scheduler Get message to get the Scheduler Register status of a
* Scheduler Server 
*
* @param elem_index   Client model element index
* @param server_address   Destination server model address
* @param appkey_index   The application key index to use.
*
* Events generated
*
* gecko_evt_mesh_scheduler_client_status - 
*
**/

static inline struct gecko_msg_mesh_scheduler_client_get_rsp_t* gecko_cmd_mesh_scheduler_client_get(uint16 elem_index,uint16 server_address,uint16 appkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_scheduler_client_get.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_scheduler_client_get.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_scheduler_client_get.appkey_index=appkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_scheduler_client_get_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_scheduler_client_get;
}

/** 
*
* gecko_cmd_mesh_scheduler_client_get_action
*
* Send a Scheduler Action Get message to get action defined by a Schedule
* Register state entry 
*
* @param elem_index   Client model element index
* @param server_address   Destination server model address
* @param appkey_index   The application key index to use.
* @param index   Index of the Scgeduler Register entry to get
*
* Events generated
*
* gecko_evt_mesh_scheduler_client_action_status - 
*
**/

static inline struct gecko_msg_mesh_scheduler_client_get_action_rsp_t* gecko_cmd_mesh_scheduler_client_get_action(uint16 elem_index,uint16 server_address,uint16 appkey_index,uint8 index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_scheduler_client_get_action.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_scheduler_client_get_action.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_scheduler_client_get_action.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_scheduler_client_get_action.index=index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_scheduler_client_get_action_id+(((7)&0xff)<<8)+(((7)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_scheduler_client_get_action;
}

/** 
*
* gecko_cmd_mesh_scheduler_client_set_action
*
* Send a Scheduler Action Set message to set the given entry of the Scheduler
* Register state
* 
* For the description of these fields, please see Scheduler Server 
*
* @param elem_index   Client model element index
* @param server_address   Destination server model address
* @param appkey_index   The application key index to use.
* @param flags   Bit 1 (0x02) defines whether response is required, othewise the unacknowledged
*  message is used.
* @param index   Index of the Scheduler Register entry to set
* @param year   Scheduled year for the action
* @param month   Scheduled month for the action
* @param day   Scheduled day of the month for the action
* @param hour   Scheduled hour for the action
* @param minute   Scheduled minute for the action
* @param second   Scheduled second for the action
* @param day_of_week   Scheduled days of the week for the action
* @param action   Action to be performed at the scheduled time
* @param transition_time   Transition time for this action
* @param scene_number   Scene number to be used for some actions
*
* Events generated
*
* gecko_evt_mesh_scheduler_client_action_status - 
*
**/

static inline struct gecko_msg_mesh_scheduler_client_set_action_rsp_t* gecko_cmd_mesh_scheduler_client_set_action(uint16 elem_index,uint16 server_address,uint16 appkey_index,uint8 flags,uint8 index,uint8 year,uint16 month,uint8 day,uint8 hour,uint8 minute,uint8 second,uint8 day_of_week,uint8 action,uint8 transition_time,uint16 scene_number)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_scheduler_client_set_action.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_scheduler_client_set_action.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_scheduler_client_set_action.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_scheduler_client_set_action.flags=flags;
    gecko_cmd_msg->data.cmd_mesh_scheduler_client_set_action.index=index;
    gecko_cmd_msg->data.cmd_mesh_scheduler_client_set_action.year=year;
    gecko_cmd_msg->data.cmd_mesh_scheduler_client_set_action.month=month;
    gecko_cmd_msg->data.cmd_mesh_scheduler_client_set_action.day=day;
    gecko_cmd_msg->data.cmd_mesh_scheduler_client_set_action.hour=hour;
    gecko_cmd_msg->data.cmd_mesh_scheduler_client_set_action.minute=minute;
    gecko_cmd_msg->data.cmd_mesh_scheduler_client_set_action.second=second;
    gecko_cmd_msg->data.cmd_mesh_scheduler_client_set_action.day_of_week=day_of_week;
    gecko_cmd_msg->data.cmd_mesh_scheduler_client_set_action.action=action;
    gecko_cmd_msg->data.cmd_mesh_scheduler_client_set_action.transition_time=transition_time;
    gecko_cmd_msg->data.cmd_mesh_scheduler_client_set_action.scene_number=scene_number;
    gecko_cmd_msg->header=(gecko_cmd_mesh_scheduler_client_set_action_id+(((20)&0xff)<<8)+(((20)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_scheduler_client_set_action;
}

/** 
*
* gecko_cmd_mesh_scheduler_server_init
*
* Initializes the Scheduler Server model 
*
* @param elem_index   Scheduler server model element index
*
**/

static inline struct gecko_msg_mesh_scheduler_server_init_rsp_t* gecko_cmd_mesh_scheduler_server_init(uint16 elem_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_scheduler_server_init.elem_index=elem_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_scheduler_server_init_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_scheduler_server_init;
}

/** 
*
* gecko_cmd_mesh_scheduler_server_deinit
*
* Deinitializes the Scheduler Server model 
*
* @param elem_index   Scheduler server model element index
*
**/

static inline struct gecko_msg_mesh_scheduler_server_deinit_rsp_t* gecko_cmd_mesh_scheduler_server_deinit(uint16 elem_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_scheduler_server_deinit.elem_index=elem_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_scheduler_server_deinit_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_scheduler_server_deinit;
}

/** 
*
* gecko_cmd_mesh_scheduler_server_get
*
* Get Scheduler Register status of Scheduler Server 
*
* @param elem_index   Scheduler server model element index
*
**/

static inline struct gecko_msg_mesh_scheduler_server_get_rsp_t* gecko_cmd_mesh_scheduler_server_get(uint16 elem_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_scheduler_server_get.elem_index=elem_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_scheduler_server_get_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_scheduler_server_get;
}

/** 
*
* gecko_cmd_mesh_scheduler_server_get_action
*
* Get the Scheduler Action defined by a Schedule Register state entry.
* 
* For the description of returned fields, please see Scheduler Server 
*
* @param elem_index   Scheduler server model element index
* @param index   Index of the Scgeduler Register entry to get
*
**/

static inline struct gecko_msg_mesh_scheduler_server_get_action_rsp_t* gecko_cmd_mesh_scheduler_server_get_action(uint16 elem_index,uint8 index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_scheduler_server_get_action.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_scheduler_server_get_action.index=index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_scheduler_server_get_action_id+(((3)&0xff)<<8)+(((3)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_scheduler_server_get_action;
}

/** 
*
* gecko_cmd_mesh_scheduler_server_set_action
*
* Set the given Scheduler Action entry of the Scheduler Register state
* 
* For the description of these fields, please see Scheduler Server 
*
* @param elem_index   Scheduler server model element index
* @param index   Index of the Scheduler Register entry to set
* @param year   Scheduled year for the action
* @param month   Scheduled month for the action
* @param day   Scheduled day of the month for the action
* @param hour   Scheduled hour for the action
* @param minute   Scheduled minute for the action
* @param second   Scheduled second for the action
* @param day_of_week   Scheduled days of the week for the action
* @param action   Action to be performed at the scheduled time
* @param transition_time   Transition time for this action
* @param scene_number   Scene number to be used for some actions
*
**/

static inline struct gecko_msg_mesh_scheduler_server_set_action_rsp_t* gecko_cmd_mesh_scheduler_server_set_action(uint16 elem_index,uint8 index,uint8 year,uint16 month,uint8 day,uint8 hour,uint8 minute,uint8 second,uint8 day_of_week,uint8 action,uint8 transition_time,uint16 scene_number)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_scheduler_server_set_action.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_scheduler_server_set_action.index=index;
    gecko_cmd_msg->data.cmd_mesh_scheduler_server_set_action.year=year;
    gecko_cmd_msg->data.cmd_mesh_scheduler_server_set_action.month=month;
    gecko_cmd_msg->data.cmd_mesh_scheduler_server_set_action.day=day;
    gecko_cmd_msg->data.cmd_mesh_scheduler_server_set_action.hour=hour;
    gecko_cmd_msg->data.cmd_mesh_scheduler_server_set_action.minute=minute;
    gecko_cmd_msg->data.cmd_mesh_scheduler_server_set_action.second=second;
    gecko_cmd_msg->data.cmd_mesh_scheduler_server_set_action.day_of_week=day_of_week;
    gecko_cmd_msg->data.cmd_mesh_scheduler_server_set_action.action=action;
    gecko_cmd_msg->data.cmd_mesh_scheduler_server_set_action.transition_time=transition_time;
    gecko_cmd_msg->data.cmd_mesh_scheduler_server_set_action.scene_number=scene_number;
    gecko_cmd_msg->header=(gecko_cmd_mesh_scheduler_server_set_action_id+(((15)&0xff)<<8)+(((15)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_scheduler_server_set_action;
}

/** 
*
* gecko_cmd_mesh_time_server_init
*
* Initializes the Time Server model 
*
* @param elem_index   Server model element index
*
**/

static inline struct gecko_msg_mesh_time_server_init_rsp_t* gecko_cmd_mesh_time_server_init(uint16 elem_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_time_server_init.elem_index=elem_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_time_server_init_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_time_server_init;
}

/** 
*
* gecko_cmd_mesh_time_server_deinit
*
* Deinitializes the Time Server model 
*
* @param elem_index   Server model element index
*
**/

static inline struct gecko_msg_mesh_time_server_deinit_rsp_t* gecko_cmd_mesh_time_server_deinit(uint16 elem_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_time_server_deinit.elem_index=elem_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_time_server_deinit_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_time_server_deinit;
}

/** 
*
* gecko_cmd_mesh_time_server_get_time
*
* Get the current time from Time Server> 
*
* @param elem_index   Server model element index
*
**/

static inline struct gecko_msg_mesh_time_server_get_time_rsp_t* gecko_cmd_mesh_time_server_get_time(uint16 elem_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_time_server_get_time.elem_index=elem_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_time_server_get_time_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_time_server_get_time;
}

/** 
*
* gecko_cmd_mesh_time_server_set_time
*
* Sets the current time for the element. 
*
* @param elem_index   Server model element index
* @param tai_seconds   The current TAI time in seconds
* @param subsecond   The sub-second time in units of 1/256th second
* @param uncertainty   The estimated uncertainty in 10 millisecond steps
* @param time_authority   0 = No Time Authority, 1 = Time Authority
* @param time_zone_offset   Current local time zone offset. Range is -64 to 191, representing -16 to 47.75
*  hours.
* @param tai_utc_delta   Current difference between TAI and UTC in seconds. Range is -255 to 32512.
*
**/

static inline struct gecko_msg_mesh_time_server_set_time_rsp_t* gecko_cmd_mesh_time_server_set_time(uint16 elem_index,uint64 tai_seconds,uint8 subsecond,uint8 uncertainty,uint8 time_authority,int16 time_zone_offset,int32 tai_utc_delta)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_time_server_set_time.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_time_server_set_time.tai_seconds=tai_seconds;
    gecko_cmd_msg->data.cmd_mesh_time_server_set_time.subsecond=subsecond;
    gecko_cmd_msg->data.cmd_mesh_time_server_set_time.uncertainty=uncertainty;
    gecko_cmd_msg->data.cmd_mesh_time_server_set_time.time_authority=time_authority;
    gecko_cmd_msg->data.cmd_mesh_time_server_set_time.time_zone_offset=time_zone_offset;
    gecko_cmd_msg->data.cmd_mesh_time_server_set_time.tai_utc_delta=tai_utc_delta;
    gecko_cmd_msg->header=(gecko_cmd_mesh_time_server_set_time_id+(((19)&0xff)<<8)+(((19)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_time_server_set_time;
}

/** 
*
* gecko_cmd_mesh_time_server_get_time_zone_offset_new
*
* Get the upcoming time zone offset from Time Server 
*
* @param elem_index   Server model element index
*
**/

static inline struct gecko_msg_mesh_time_server_get_time_zone_offset_new_rsp_t* gecko_cmd_mesh_time_server_get_time_zone_offset_new(uint16 elem_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_time_server_get_time_zone_offset_new.elem_index=elem_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_time_server_get_time_zone_offset_new_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_time_server_get_time_zone_offset_new;
}

/** 
*
* gecko_cmd_mesh_time_server_set_time_zone_offset_new
*
* Sets the upcoming time zone offset for the element 
*
* @param elem_index   Server model element index
* @param new_offset   Upcoming local time zone offset. Range is -64 to 191, representing -16 to
*  47.75 hours.
* @param tai_of_zone_change   Absolute TAI time when the Time Zone Offset will change from Current to New
*
**/

static inline struct gecko_msg_mesh_time_server_set_time_zone_offset_new_rsp_t* gecko_cmd_mesh_time_server_set_time_zone_offset_new(uint16 elem_index,int16 new_offset,uint64 tai_of_zone_change)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_time_server_set_time_zone_offset_new.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_time_server_set_time_zone_offset_new.new_offset=new_offset;
    gecko_cmd_msg->data.cmd_mesh_time_server_set_time_zone_offset_new.tai_of_zone_change=tai_of_zone_change;
    gecko_cmd_msg->header=(gecko_cmd_mesh_time_server_set_time_zone_offset_new_id+(((12)&0xff)<<8)+(((12)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_time_server_set_time_zone_offset_new;
}

/** 
*
* gecko_cmd_mesh_time_server_get_tai_utc_delta_new
*
* Get the upcoming TAI-UTC delta for the element 
*
* @param elem_index   Server model element index
*
**/

static inline struct gecko_msg_mesh_time_server_get_tai_utc_delta_new_rsp_t* gecko_cmd_mesh_time_server_get_tai_utc_delta_new(uint16 elem_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_time_server_get_tai_utc_delta_new.elem_index=elem_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_time_server_get_tai_utc_delta_new_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_time_server_get_tai_utc_delta_new;
}

/** 
*
* gecko_cmd_mesh_time_server_set_tai_utc_delta_new
*
* Sets the upcoming TAI-UTC delta for the element 
*
* @param elem_index   Server model element index
* @param new_delta   Upcoming difference between TAI and UTC in seconds
* @param tai_of_delta_change   Absolute TAI time when the TAI-UTC Delta will change from Current to New
*
**/

static inline struct gecko_msg_mesh_time_server_set_tai_utc_delta_new_rsp_t* gecko_cmd_mesh_time_server_set_tai_utc_delta_new(uint16 elem_index,int32 new_delta,uint64 tai_of_delta_change)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_time_server_set_tai_utc_delta_new.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_time_server_set_tai_utc_delta_new.new_delta=new_delta;
    gecko_cmd_msg->data.cmd_mesh_time_server_set_tai_utc_delta_new.tai_of_delta_change=tai_of_delta_change;
    gecko_cmd_msg->header=(gecko_cmd_mesh_time_server_set_tai_utc_delta_new_id+(((14)&0xff)<<8)+(((14)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_time_server_set_tai_utc_delta_new;
}

/** 
*
* gecko_cmd_mesh_time_server_get_time_role
*
* Get Time Role for the element 
*
* @param elem_index   Server model element index
*
**/

static inline struct gecko_msg_mesh_time_server_get_time_role_rsp_t* gecko_cmd_mesh_time_server_get_time_role(uint16 elem_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_time_server_get_time_role.elem_index=elem_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_time_server_get_time_role_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_time_server_get_time_role;
}

/** 
*
* gecko_cmd_mesh_time_server_set_time_role
*
* Sets Time Role for the element 
*
* @param elem_index   Server model element index
* @param time_role   Time Role of the element
*
**/

static inline struct gecko_msg_mesh_time_server_set_time_role_rsp_t* gecko_cmd_mesh_time_server_set_time_role(uint16 elem_index,uint8 time_role)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_time_server_set_time_role.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_time_server_set_time_role.time_role=time_role;
    gecko_cmd_msg->header=(gecko_cmd_mesh_time_server_set_time_role_id+(((3)&0xff)<<8)+(((3)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_time_server_set_time_role;
}

/** 
*
* gecko_cmd_mesh_time_server_get_datetime
*
* Returns the date and time from the Time Server 
*
* @param elem_index   Server model element index
*
**/

static inline struct gecko_msg_mesh_time_server_get_datetime_rsp_t* gecko_cmd_mesh_time_server_get_datetime(uint16 elem_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_time_server_get_datetime.elem_index=elem_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_time_server_get_datetime_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_time_server_get_datetime;
}

/** 
*
* gecko_cmd_mesh_time_client_init
*
* Initializes the Time Client model 
*
* @param elem_index   Client model element index
*
**/

static inline struct gecko_msg_mesh_time_client_init_rsp_t* gecko_cmd_mesh_time_client_init(uint16 elem_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_time_client_init.elem_index=elem_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_time_client_init_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_time_client_init;
}

/** 
*
* gecko_cmd_mesh_time_client_deinit
*
* Deinitializes the Time Client model 
*
* @param elem_index   Client model element index
*
**/

static inline struct gecko_msg_mesh_time_client_deinit_rsp_t* gecko_cmd_mesh_time_client_deinit(uint16 elem_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_time_client_deinit.elem_index=elem_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_time_client_deinit_id+(((2)&0xff)<<8)+(((2)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_time_client_deinit;
}

/** 
*
* gecko_cmd_mesh_time_client_get_time
*
* Sends a Time Get message to Time Server 
*
* @param elem_index   Client model element index
* @param server_address   Destination server model address
* @param appkey_index   The application key index to use.
*
**/

static inline struct gecko_msg_mesh_time_client_get_time_rsp_t* gecko_cmd_mesh_time_client_get_time(uint16 elem_index,uint16 server_address,uint16 appkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_time_client_get_time.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_time_client_get_time.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_time_client_get_time.appkey_index=appkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_time_client_get_time_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_time_client_get_time;
}

/** 
*
* gecko_cmd_mesh_time_client_set_time
*
* Sends a Time Set message to Time Server 
*
* @param elem_index   Client model element index
* @param server_address   Destination server model address
* @param appkey_index   The application key index to use.
* @param tai_seconds   The current TAI time in seconds since the epoch, 40-bit value
* @param subsecond   The sub-second in units of 1/256th second. Range is 0-255.
* @param uncertainty   The estimated uncertainty in 10-milliseconds steps. Range is 0-255,
*  representing up to 2.55 seconds.
* @param time_authority   0: No Time Authority, the element does not have a trusted source of time such
*  as GPS or NTP. 1: Time Authority, the element has a trusted source of time or
*  a battery-backed properly initialized RTC. Other values are prohibited.
* @param tai_utc_delta   Current difference between TAI and UTC in seconds. Range is -255 to 32512.
* @param time_zone_offset   The local time zone offset in 15-minute increments. Range is -64 to 191,
*  representing -16 to 47.75 hours.
*
**/

static inline struct gecko_msg_mesh_time_client_set_time_rsp_t* gecko_cmd_mesh_time_client_set_time(uint16 elem_index,uint16 server_address,uint16 appkey_index,uint64 tai_seconds,uint8 subsecond,uint8 uncertainty,uint8 time_authority,int32 tai_utc_delta,int16 time_zone_offset)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_time_client_set_time.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_time_client_set_time.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_time_client_set_time.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_time_client_set_time.tai_seconds=tai_seconds;
    gecko_cmd_msg->data.cmd_mesh_time_client_set_time.subsecond=subsecond;
    gecko_cmd_msg->data.cmd_mesh_time_client_set_time.uncertainty=uncertainty;
    gecko_cmd_msg->data.cmd_mesh_time_client_set_time.time_authority=time_authority;
    gecko_cmd_msg->data.cmd_mesh_time_client_set_time.tai_utc_delta=tai_utc_delta;
    gecko_cmd_msg->data.cmd_mesh_time_client_set_time.time_zone_offset=time_zone_offset;
    gecko_cmd_msg->header=(gecko_cmd_mesh_time_client_set_time_id+(((23)&0xff)<<8)+(((23)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_time_client_set_time;
}

/** 
*
* gecko_cmd_mesh_time_client_get_time_zone
*
* Sends a Time Zone Get message to Time Server 
*
* @param elem_index   Client model element index
* @param server_address   Destination server model address
* @param appkey_index   The application key index to use.
*
**/

static inline struct gecko_msg_mesh_time_client_get_time_zone_rsp_t* gecko_cmd_mesh_time_client_get_time_zone(uint16 elem_index,uint16 server_address,uint16 appkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_time_client_get_time_zone.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_time_client_get_time_zone.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_time_client_get_time_zone.appkey_index=appkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_time_client_get_time_zone_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_time_client_get_time_zone;
}

/** 
*
* gecko_cmd_mesh_time_client_set_time_zone
*
* Sends a Time Zone Set message to Time Server to set the Time Zone New state 
*
* @param elem_index   Client model element index
* @param server_address   Destination server model address
* @param appkey_index   The application key index to use.
* @param time_zone_offset_new   Upcoming local time zone offset. Range is -64 to 191, representing -16 to
*  47.75 hours.
* @param tai_of_zone_change   TAI Seconds time of upcoming Time Zone offset change
*
**/

static inline struct gecko_msg_mesh_time_client_set_time_zone_rsp_t* gecko_cmd_mesh_time_client_set_time_zone(uint16 elem_index,uint16 server_address,uint16 appkey_index,int16 time_zone_offset_new,uint64 tai_of_zone_change)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_time_client_set_time_zone.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_time_client_set_time_zone.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_time_client_set_time_zone.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_time_client_set_time_zone.time_zone_offset_new=time_zone_offset_new;
    gecko_cmd_msg->data.cmd_mesh_time_client_set_time_zone.tai_of_zone_change=tai_of_zone_change;
    gecko_cmd_msg->header=(gecko_cmd_mesh_time_client_set_time_zone_id+(((16)&0xff)<<8)+(((16)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_time_client_set_time_zone;
}

/** 
*
* gecko_cmd_mesh_time_client_get_tai_utc_delta
*
* Sends a TAI-UTC Delta Get message to Time Server 
*
* @param elem_index   Client model element index
* @param server_address   Destination server model address
* @param appkey_index   The application key index to use.
*
**/

static inline struct gecko_msg_mesh_time_client_get_tai_utc_delta_rsp_t* gecko_cmd_mesh_time_client_get_tai_utc_delta(uint16 elem_index,uint16 server_address,uint16 appkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_time_client_get_tai_utc_delta.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_time_client_get_tai_utc_delta.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_time_client_get_tai_utc_delta.appkey_index=appkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_time_client_get_tai_utc_delta_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_time_client_get_tai_utc_delta;
}

/** 
*
* gecko_cmd_mesh_time_client_set_tai_utc_delta
*
* Sends a TAI-UTC Delta Set message to Time Server, which responds with a TAI-
* UTC Delta Status message. 
*
* @param elem_index   Client model element index
* @param server_address   Destination server model address
* @param appkey_index   The application key index to use.
* @param tai_utc_delta_new   Upcoming difference between TAI and UTC is seconds. Range is -255 to 32512.
* @param tai_of_delta_change   TAI Seconds time of the upcoming TAI-UTC Delta change
*
**/

static inline struct gecko_msg_mesh_time_client_set_tai_utc_delta_rsp_t* gecko_cmd_mesh_time_client_set_tai_utc_delta(uint16 elem_index,uint16 server_address,uint16 appkey_index,int32 tai_utc_delta_new,uint64 tai_of_delta_change)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_time_client_set_tai_utc_delta.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_time_client_set_tai_utc_delta.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_time_client_set_tai_utc_delta.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_time_client_set_tai_utc_delta.tai_utc_delta_new=tai_utc_delta_new;
    gecko_cmd_msg->data.cmd_mesh_time_client_set_tai_utc_delta.tai_of_delta_change=tai_of_delta_change;
    gecko_cmd_msg->header=(gecko_cmd_mesh_time_client_set_tai_utc_delta_id+(((18)&0xff)<<8)+(((18)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_time_client_set_tai_utc_delta;
}

/** 
*
* gecko_cmd_mesh_time_client_get_time_role
*
* Sends a Time Role Get message to Time Server, which responds with a Time Role
* Status message. 
*
* @param elem_index   Client model element index
* @param server_address   Destination server model address
* @param appkey_index   The application key index to use.
*
**/

static inline struct gecko_msg_mesh_time_client_get_time_role_rsp_t* gecko_cmd_mesh_time_client_get_time_role(uint16 elem_index,uint16 server_address,uint16 appkey_index)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_time_client_get_time_role.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_time_client_get_time_role.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_time_client_get_time_role.appkey_index=appkey_index;
    gecko_cmd_msg->header=(gecko_cmd_mesh_time_client_get_time_role_id+(((6)&0xff)<<8)+(((6)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_time_client_get_time_role;
}

/** 
*
* gecko_cmd_mesh_time_client_set_time_role
*
* Sends Time Role Get message to Time Server, which responds with a Time Role
* Status message. 
*
* @param elem_index   Client model element index
* @param server_address   Destination server model address
* @param appkey_index   The application key index to use.
* @param time_role   The Time Role for the element.
*
**/

static inline struct gecko_msg_mesh_time_client_set_time_role_rsp_t* gecko_cmd_mesh_time_client_set_time_role(uint16 elem_index,uint16 server_address,uint16 appkey_index,uint8 time_role)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_mesh_time_client_set_time_role.elem_index=elem_index;
    gecko_cmd_msg->data.cmd_mesh_time_client_set_time_role.server_address=server_address;
    gecko_cmd_msg->data.cmd_mesh_time_client_set_time_role.appkey_index=appkey_index;
    gecko_cmd_msg->data.cmd_mesh_time_client_set_time_role.time_role=time_role;
    gecko_cmd_msg->header=(gecko_cmd_mesh_time_client_set_time_role_id+(((7)&0xff)<<8)+(((7)&0x700)>>8));
    
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_mesh_time_client_set_time_role;
}
#ifdef __cplusplus
}
#endif

#endif
